Limitations Vue.js
Vue CLI
v-model modificateurs
Getters, accès par propriété et accès par méthode
Form validation, client-side and server-side
v-if v-else et v-show particularités
Gestion des évènements, modificateurs, codes des touches
-------------------------------
Voir https://fr.vuejs.org/v2/guide/events.html


Limitations Vue.js
-------------------------------
1. On ne peux pas rajouter de propriétés à l'objet data de l'objet Vue à la volée
2. On ne peut pas accéder à un élément de tableau qui se trouve dans une propriété de data directement par son index


Vue CLI
-------------------------------
1. Command Line Interface (CLI)

2. Vue CLI fournit un système complet pour le développement rapide en Vue.js. Cela signifie qu'il fait beaucoup de travail fastidieux pour nous et nous fournit des fonctionnalités précieuses dès le départ.

3. Il nous permet de sélectionner les bibliothèques que notre projet utilisera, puis il les connecte automatiquement au projet.

4. Il configure Webpack Lorsque nous construisons notre application avec Webpack, tous nos fichiers JavaScript, notre CSS et nos dépendances sont correctement regroupés, minifiés et optimisés.

5. Il nous permet d'écrire notre HTML, CSS et JavaScript comme nous le souhaitons. Nous pouvons utiliser des composants .vue à fichier unique, TypeScript, SCSS, Pug, les dernières versions d'ECMAScript, etc.

6. Il permet le remplacement à chaud du module (HMR). Ainsi, lorsque vous enregistrez votre projet, les modifications apparaissent instantanément dans le navigateur. Cette configuration est basée sur webpack-dev-server.

Installation
	npm install -g @vue/cli
	# OR
	yarn global add @vue/cli

Check vue version
	vue --version

Global upgrading Vue CLI package
	npm update -g @vue/cli
	# OR
	yarn global upgrade --latest @vue/cli

To upgrade one or more @vue/cli related packages (including packages starting with @vue/cli-plugin-) inside your project
	# inside the project directory
	vue upgrade

Create a new project
	vue create hello-world

Lancer le projet
	npm run serve
	# OR
	yarn serve

Built le projet
 	npm run build
	# OR
	yarn build


v-model modificateurs
-------------------------------
Voir https://fr.vuejs.org/v2/guide/forms.html#vmodel-ime-tip

1. lazy
Par défaut, v-model synchronise le champ avec les données après chaque évènement input (à l’exception de l’exécution d’une méthode de saisie comme mentionné plus haut). Vous pouvez ajouter le modificateur lazy pour synchroniser après les évènements change à la place :

	////////////////////////////////////// EX:
	<!-- synchronisé après le "change" au lieu du "input" -->
	<input v-model.lazy="msg">

2. number
Si vous voulez que la saisie utilisateur soit automatiquement convertie en nombre, vous pouvez ajouter le modificateur number à vos champs gérés par v-model :

	////////////////////////////////////// EX:
	<input v-model.number="age" type="number">

C’est souvent utile, parce que même avec type="number", la valeur des éléments de saisie HTML retourne toujours une chaine de caractères. Si la valeur ne peut pas être transformée avec parseFloat(), alors la valeur originale est retournée.

3. trim
Si vous voulez que les espaces superflus des saisies utilisateur soient automatiquement retirés, vous pouvez ajouter le modificateur trim à vos champs gérés par v-model :

	////////////////////////////////////// EX:
	<input v-model.trim="msg">


getters, accès par propriété et accès par méthode
-------------------------------
1. Accès par propriété
Les getters seront exposés sur l'objet store.getters et vous accèderez aux valeurs comme des propriétés :
	////////////////////////////////////// EX:
	store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]

Les getters recevront également les autres getters en second argument :
	////////////////////////////////////// EX:
		getters: {
		  // ...
		  doneTodosCount: (state, getters) => {
		    return getters.doneTodos.length
		  }
		}
		store.getters.doneTodosCount // -> 1

Nous pouvons maintenant facilement les utiliser dans n'importe quel composant :
	////////////////////////////////////// EX:
	computed: {
	  doneTodosCount () {
	    return this.$store.getters.doneTodosCount
	  }
	}

Notez que les getters accédés par propriétés sont mis en cache par le système de réactivité de Vue.

2. Accès par méthode
Vous pouvez aussi passer des arguments aux accesseurs en retournant une fonction. Cela est particulièrement utile 
quand vous souhaitez interroger un tableau dans le store :

	////////////////////////////////////// EX:
	getters: {
	  // ...
	  getTodoById: (state) => (id) => {
	    return state.todos.find(todo => todo.id === id)
	  }
	}

Nous pouvons maintenant utiliser ce getter dans un composant :	
	////////////////////////////////////// EX:
	// On passe l'argument qui a pour valeur 2 à la fonction retourné par le getter
	store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }

Notez que les accesseur accédés par méthodes vont être exécuté chaque fois qu'il seront appelés. 
Le résultat ne sera donc pas mis en cache.


Form validation, client-side and server-side
-------------------------------
Voir https://vueschool.io/lessons/vuejs-form-validation-diy?friend=vuejs
Voir https://vuejs.org/v2/cookbook/form-validation.html#Another-Example-of-Custom-Validation


v-if v-else et v-show particularités
-------------------------------
1. v-if v-else rend le composant, c'est à dire qu'il est ajouté au DOM au moment où la condition est vrai, avant il n'est pas dans le DOM 
2. v-show cache le composant, il est dans le DOM mais est en display none jusqu'à que le condition soit vrai alors il n'est plus en display none.