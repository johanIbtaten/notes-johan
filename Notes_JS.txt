    Variables
    Le hoisting ou remontée des variables
    Évaluation de variables
    Les bouléens
    var, let, const
    Affectation par décomposition (Destructuring en anglais)
    Types de données
    Les opérateurs d'égalité
    Différence entre undefined et null
    Double ou simple quotes ou accent grave (backquote ou backtick en anglais)
    Opérateur void
    L'opérateur this
    La « remontée » des déclarations de fonction
    Définition d'un littéral
    Littéraux de gabarits (template strings en anglais)
    Les différents types de fonctions
    Les expressions de fonctions
    Les fonctions fléchées (arrow function en anglais)
    Raccourci ES6 pour écrire la méthode d'un objet
    IIFE (Expression de fonction invoquée immédiatement)
    L'instruction Return
    Différence entre argument et paramètre
    Objet Map
    Objet Set
    Map vs Object
    Set vs Array
    Convertir un Objet en Map et inversement et sérialiser
    Object Property Value Shorthand
    Noms de propriétés calculés (Computed Properties)
    Boucles
    Fonctions sur les tableaux
        FOREACH()
        CONSOLE.TABLE()
        REDUCE()
        MAP()
        ENTRIES()
        FROM()
        SLICE()
        FILTER()
        INCLUDES()
        FIND()
    Méthodes sur les objets
        KEYS()
        ASSIGN()
    Méthodes sur les fonctions
        CALL()
        APPLY()
        BIND()
    Méthodes sur les chaînes de caratères
        INCLUDES()
        STARTSWITH()
        SPLIT()
    Méthodes sur JSON
        PARSE()
    Rest parameters
    Spread operator (opérateur de décomposition)
    Le protocole « itérable » (Objets itérables)
    Le protocole « itérateur »
    Les générateurs function*
    Héritage et chaîne de prototype
    Les différentes façons de créer des objets et les impacts sur la chaîne de prototype
    Le mot clé static dans une classe javascript
    Comparer des objets
    Utiliser this
    Promise, Async et Await
    Fetch API
    AJAX
    Les modules JavaScript import / export
    Memoization
    Les valeurs évaluées à false
    Hashtable / Hashmap  vs Array (Data Normalization)
    Pattern Observable / Observer
    .json()
    Regression d'une application
    Les différents types de tests
    Les tests avec JEST
    Fonctions pures
    Fonction à effet de bord (side effects)
    Debugger
    Assignation par défaut avec les opérateurs || et &&
    JSDoc
    HTMLElement.dataset et les attributs data-*
    Paradigme de programmation définition
    Les closures
    Debounce et Trottle
    Primitive vs Reference



Variables
-------------------------------
1. Les noms des variables sont appelés identifiants.

2. Un identifiant JavaScript doit commencer par une lettre, un tiret bas (_) ou un symbole dollar ($).

3. Javascript est sensible à la casse (aux majuscules et minuscules).

4. On peut aussi utiliser la plupart lettres Unicode ou ISO 8859-1 (comme å et ü, pour plus de détails, au sein des identifiants).


Le hoisting ou remontée des variables
-------------------------------
1. Avant d'être exécuté, l'interpréteur va remonter toutes les déclarations de variables et de fonctions 
tout en haut de leur contexte d'exécution.

2. Il existe deux types de contexte :
La fonction dans laquelle la déclaration a été faite
Le contexte d'exécution globale si la déclaration a été faite en dehors de toute fonction

    Ex1:
    console.log(a);
    var a = 2;
    // Affiche undefined
    // L'interpréteur va remonter la déclaration de la variable avant le reste
    // Le code ci-dessus revient à écrire
    var a;
    console.log(a);
    a = 2;

    Ex2:
    a = 2;
    console.log(a);
    var a;
    // Affiche 2
    // Le code ci-dessus revient à écrire
    var a;
    a = 1;
    console.log(a);

    Ex3:
    var f = 'foo';
    foo();
    function foo() {
      console.log(f);
      var f = 'bar';
    }
    // f affiche undefined
    // Le code ci-dessus revient à écrire
    function foo() {
      var f;
      console.log(f);
      f = 'bar';
    }
    var f;
    f = 'foo';
    foo();
    // L'une est dans le contexte global, tandis que l'autre se trouve dans celui de la fonction. 
    // Elles sont remontées, mais pas au même niveau. Voilà pourquoi on obtient undefined à l'exécution de foo.

3. Faire attention à bien déclarer vos variables au tout début de votre code.




Évaluation de variables
-------------------------------
1. Une variable déclarée (déclaration) grâce à l'instruction var ou let sans valeur initiale définie (affectation ou initialisation ou  assignation) vaudra undefined.

    Ex1:
    var a;
    console.log("La valeur de a est " + a); // La valeur de a est undefined

    console.log("La valeur de b est " + b); // La valeur de b est undefined 
    var b; // La déclaration de la variable est "remontée"

    let y;
    console.log("La valeur de y est " + y); // La valeur de y est undefined

2. Toute variable non déclarée devient une variable globale. 
Elle est accessible depuis n'importe quelle ligne de code, qu'elle soit dans une fonction ou non.

    Ex1:
    uneVariableGlobale = 'Hello world';
    
    Ex2:
    function foo() {
      try {
        console.log(f);
      }
      catch (ex) {
        console.log("f n'existe pas");
      }
      f = 'bar'; // Variable globale
    }
    foo();
    foo();
    // affiche "f n'existe pas"
    // affiche bar


3. Tenter d'accéder à une variable qui n'a pas été déclarée ou tenter d'accéder à un identifiant déclaré 
avec let avant sa déclaration provoquera l'envoi d'une exception ReferenceError

    Ex1:
    console.log("La valeur de m est " + m); // signale une exception ReferenceError

    console.log("La valeur de x est " + x); // signale une exception ReferenceError
    let x;

4. Il est possible d'utiliser undefined pour déterminer si une variable possède une valeur. 

    Ex1:
    // La condition de l'instruction if sera validée car la variable n'a pas été initialisée (affectée) (elle a simplement été déclarée)
    var input;
    if (typeof input === undefined){
      faireCeci();
    } else {
      faireCela();
    }

5. La valeur undefined se comporte comme le booléen false lorsqu'elle est utilisée dans un contexte booléen.

    Ex1:
    // Le code qui suit exécutera la fonction maFonction puisque le premier élément de monTableau n'est pas défini
    var monTableau = new Array();
    if (!monTableau[0]){
      maFunction(); 
    }

6. La valeur undefined est convertie en NaN (pour Not a Number : « n'est pas un nombre ») lorsqu'elle est utilisée dans un contexte numérique.

    Ex1:
    var a;
    a + 2; // NaN

7. Une variable valant null sera toujours considérée comme 0 dans un contexte numérique et comme false dans un contexte booléen.

    Ex1:
    var n = null;
    console.log(n * 32); // Le log affichera 0


Les booléens
-------------------------------
1. Dans un contexte booléen, si la valeur d'une variable 
est omise ou est 0, -0, null, false, NaN, undefined ou une chaine de caractères vide (""), 
son évaluation est à false (faux).
Toutes les autres valeurs d'une variable, y compris n'importe quel objet, 
un tableau vide ([]), ou une chaine de caractères "false", 
est évaluer avec une valeur initiale à true (vrai).

    Ex1:
    // En javascript, l'opérateur || retourne la première valeur évaluée à true.
    // Tester si une variable est définie en javascript
    var language;
    var info = language || "en"; // langage vaut false car la variable renvoie undefined
    console.log(info) // "en"


var, let, const
-------------------------------
Déclaration (var a;) initialisation : var a=2;
Déclaration (let a;) initialisation : let a=2;
Déclaration, initialisation : const a=2;
Scope (ou Portée en français)

var   : Scope dans les fonctions 
        Pas de scope dans les blocs (blocs types if, for, while, etc.)
        Si var est déclaré sans valeur initiale (ex: var a;) elle aura la valeur undefined
        
        Lorsqu'une variable est déclarée avec var en dehors des fonctions, elle est appelée variable globale 
        car elle est disponible pour tout le code contenu dans le document. 
        Lorsqu'une variable est déclarée dans une fonction, elle est appelée variable locale 
        car elle n'est disponible qu'au sein de cette fonction.

let   : Scope dans les fonctions 
        Scope dans les blocs (blocs types if, for, while, etc.)
        Si let est déclaré sans valeur initiale (ex: let a;) elle aura la valeur undefined
        On déclare une variable dont la portée est celle du bloc courant, éventuellement en initialisant sa valeur

const : Scope dans les fonctions 
        Scope dans les blocs (blocs types if, for, while, etc.)
        const a besoin d'être déclaré avec une valeur initiale (ex: const a=2;)
        const est accessible en lecture seule
	      On ne peut pas réassigner la valeur d'une constante (ex: a=4;)
        On ne peut pas re-déclarer dans la même portée une autre constante avec le même nom (ex: const a=4;)
        Il est impossible de déclarer une constante avec le même nom qu'une autre variable ou fonction dans la même portée.

        Ex1:
        // Renverra une erreur
        function f() {};
        const f = 5;

        // Renverra également une erreur
        function f() {
          const g = 5;
          var g;
          //instructions
        }

        On peut ajouter ou supprimer les éléments d'un tableau dans une const
        On ne peut pas changer la structure d'un objet littéral dans une const
        On peut changer les valeurs d'un objet littéral dans un const


Affectation par décomposition (Destructuring en anglais)
-------------------------------
1. L'affectation par décomposition (destructuring en anglais) est une expression JavaScript qui permet d'extraire (unpack en anglais) 
des données d'un tableau ou d'un objet grâce à une syntaxe dont la forme ressemble à la structure du tableau ou de l'objet.

    Ex1:
    var a, b, rest;

    // Pour un array
    [a, b] = [10, 20];
    console.log(a); // 10
    console.log(b); // 20
    [a, b, ...rest] = [10, 20, 30, 40, 50];
    console.log(rest); // [30,40,50]
    // expected output: 

    // Pour un objet
    ({a, b} = {a: 10, b: 20}); // Ne pas oublier les parenthèses
    console.log(a); // 10
    console.log(b); // 20
    // Proposition de syntaxe (niveau 4)
    ({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
    console.log(a); // 10
    console.log(b); // 20
    console.log(rest); // {c: 30, d: 40}

    Ex2:
    var x = [1, 2, 3, 4, 5]; // On crée un "paquet" de donnée
    var [y, z] = x; // On utilise l'affectation par décomposition
    console.log(y); // 1
    console.log(z); // 2

    Ex3:
//Décomposition d'un tableau    
    var toto = ["un", "deux", "trois"];
    // sans utiliser la décomposition
    var un    = toto[0];
    var deux  = toto[1];
    var trois = toto[2];
    // en utilisant la décomposition
    var [un, deux, trois] = toto;

// Affectation sans déclaration
    var a, b;
    [a, b] = [1, 2];
    console.log(a);  // 1
    console.log(b);  // 2

// Valeurs par défaut 
    // On peut définir une valeur par défaut au cas où 
    // la valeur extraite du tableau soit undefined.
    var a, b;
    [a = 5, b = 7] = [1];
    console.log(a); // 1
    console.log(b); // 7

// Échange de variables
    var a = 1;
    var b = 3;
    [a, b] = [b, a];
    console.log(a); // 3
    console.log(b); // 1

// Renvoyer plusieurs valeurs
    function f() {
      return [1, 2];
    }
    var a, b;
    [a, b] = f();
    console.log("A vaut " + a + " B vaut " + b); // a vaut 1 et b vaut 2

// Ignorer certaines valeurs
    function f() {
      return [1, 2, 3];
    }
    var [a, , b] = f();
    console.log("A vaut " + a + " B vaut " + b); 
    // a égal à 1 et b égal à 3
    // La valeur 2 est ignorée
    [,,] = f(); // ignore toutes les valeurs

// Affecter le reste d'un tableau à une variable
    var [a, ...b] = [1, 2, 3];
    console.log(a); // 1
    console.log(b); // [2, 3]
    var [a, ...b,] = [1, 2, 3] 
    // SyntaxError : un élément du reste ne peut pas avoir
    //               de virgule à la fin

    Ex4:
// Décomposer un objet
    var o = {
      p: 42, 
      q: true
    };
    var {p, q} = o;
    console.log(p); // 42
    console.log(q); // true 

// Assign new variable names
    var {p: toto, q: truc} = o;
    console.log(toto); // 42
    console.log(truc); // true

// Affectation sans déclaration
    var a, b;
    ({a, b} = {a:1, b:2});
    // Les parenthèses ( ... ) utilisées autour de l'instruction sont nécessaires 
    // pour que la partie gauche soit bien interprétée comme un objet littéral 
    // et non comme un bloc. Il est également nécessaire d'avoir 
    // un point-virgule avant les parenthèses de l'instruction car sinon, 
    // ces parenthèses peuvent être interprétées comme un appel de fonction.

// Affecter avec un nom différent
    var o = {
      p: 42, 
      q: true
    };
    var {p: toto, q: truc} = o;
    console.log(toto); // 42
    console.log(truc); // true

// Valeurs par défaut
    // Une variable peut recevoir une valeur par défaut lors de la décomposition 
    // si la propriété correspondante de l'objet vaut undefined.
    var {a = 10; b = 5} = {a: 3};
    console.log(a); // 3
    console.log(b); // 5

// Affecter de nouveaux noms aux variables et fournir des valeurs par défaut
    var {a: aa = 10, b: bb = 5} = {a: 3};
    console.log(aa); // 3
    console.log(bb); // 5

    Ex5:
// Arguments par défaut d'une fonction
    // Avant ES6
    function dessinGrapheES5(options) {
      options = options === undefined ? {} : options;
      var size = options.size === undefined ? 'big' : options.size;
      var coords = options.coords === undefined ? { x: 0, y: 0 } : options.coords;
      var radius = options.radius === undefined ? 25 : options.radius;
      console.log(size, coords, radius);
      // seulement ensuite on dessine le graphe
    }
    dessinGrapheES5({
      coords: { x: 18, y: 30 },
      radius: 30
    });

    // Avec ES6
    function dessinGrapheES2015({size = 'big', coords = { x: 0, y: 0 }, radius = 25} = {})
    {
      console.log(size, coords, radius);
      // on dessine le graphe
    }
    dessinGrapheES2015({
      coords: { x: 18, y: 30 },
      radius: 30
    });
    // On aurait également pu écrire la fonction sans cet objet vide (= {}) mais, dans ce cas, 
    // il aurait fallu au moins un argument pour utiliser la fonction. Avec cette « forme », 
    //dessinGrapheES2015() pourra être appelée sans paramètre.

// Décomposition imbriquée avec objets et tableaux
    const metadata = {
        title: "Scratchpad",
        translations: [
          {
            locale: "de",
            localization_tags: [ ],
            last_edit: "2014-04-14T08:43:37",
            url: "/de/docs/Tools/Scratchpad",
            title: "JavaScript-Umgebung"
          }
        ],
        url: "/en-US/docs/Tools/Scratchpad"
    };
    let { title: englishTitle, translations: [{ title: localeTitle }] } = metadata;
    console.log(englishTitle); // "Scratchpad"
    console.log(localeTitle);  // "JavaScript-Umgebung"

    var objetCompliqué = {
      propTableau: [
        "Zapp",
        { second: "Brannigan" }
      ]
    };
    var { propTableau: [premier, { second }] } = objetCompliqué;
    console.log(premier);
    // "Zapp"
    console.log(second);
    // "Brannigan"

// Décomposition et utilisation de for of
    var personnes = [
      {
        nom: "Alain Dupont",
        famille: {
          mère: "Isabelle Dupont",
          père: "Jean Dupont",
          sœur: "Laure Dupont"
        },
        âge: 35
      },
      {
        nom: "Luc Marchetoile",
        famille: {
          mère: "Patricia Marchetoile",
          père: "Antonin Marchetoile",
          frère: "Yann Marchetoile"
        },
        âge: 25
      }
    ];
    for (var {nom: n, famille: { père: f } } of personnes) {
      console.log("Nom : " + n + ", Père : " + f);
    }
    // "Nom : Alain Dupont, Père : Jean Dupont"
    // "Nom : Luc Marchetoile, Père : Antonin Marchetoile"

// Décomposer les propriétés d'objets passés en arguments
    function userId({id}) {
      return id;
    }
    function whois({displayName: displayName, fullName: {firstName: name}}){
      console.log(displayName + " est " + name);
    }
    var user = { 
      id: 42, 
      displayName: "jbiche",
      fullName: { 
          firstName: "Jean",
          lastName: "Biche"
      }
    };
    console.log("userId: " + userId(user)); // "userId: 42"
    whois(user); // "jbiche est Jean"
    // Cela permet d'accéder directement à id, displayName et firstName depuis l'objet user.

// Noms de propriétés calculés et la décomposition
    let clé = "z";
    let { [clé]: toto } = { z: "truc" };
    console.log(toto); // "truc"

// Combiner la décomposition de tableaux et d'objets
    const props = [
      { id: 1, nom: "Toto"},
      { id: 2, nom: "Truc"},
      { id: 3, nom: "Bidule"}
    ];
    const [,, {nom}] = props;
    console.log(nom); // Bidule
    

Types de données
-------------------------------
Numbers — var age = 23
Variables — var x
Text (strings) — var a = "init"
Operations — var b = 1 + 2 + 3
True or false statements (boolean) — var c = true
Constant numbers — const PI = 3.14
Objects — var name = {firstName:"John", lastName:"Doe"}
Undefined — var a; console.log(a); retourne undefined
Null  — var a = null

1. Excepté dans les cas de null ou undefined, pour chaque valeur primitive il existe un objet équivalent 
qui la contient:
String pour la primitive string ;
Number pour la primitive number ;
Boolean pour la primitive boolean ;
Symbol pour la primitive symbol


Les opérateurs d'égalité
-------------------------------
/// Égalité simple (==) ///
1. L'opérateur d'égalité simple convertit les deux opérandes s'ils ne sont pas du même type, 
ensuite la comparaison stricte est appliquée. Si les deux opérandes sont des objets, le moteur JavaScript 
comparera les références internes pour voir si elles réfèrent au même objet en mémoire.

    Ex1:
    1  ==  1;        // true
    "1"  ==  1;        // true
    1  == '1';       // true
    0  == false;     // true
    0  == null;      // false
    0  == undefined  // false
    null == undefined  // true
    var obj1 = { "clé": "valeur"};
    var obj2 = { "clé": "valeur"};
    obj1 == obj2       // false

2. Lorsqu'une comparaison est opérée entre une chaîne de caractères et un nombre, 
Javascript tente de convertir la chaine en une valeur numérique. Une valeur mathématique est 
obtenue à partir de la chaîne littérale numérique, puis celle-ci est arrondie à une valeur de type Nombre.

3. Si l'un des opérandes est de type booléen, true sera converti en 1 et false en +0.

4. Si on compare un objet avec un nombre ou une chaîne, le moteur JavaScript tentera de renvoyer la valeur par défaut de l'objet. 
Les opérateurs opèrent une conversion grâce aux méthodes valueOf (pour obtenir un nombre) et toString (pour obtenir une chaîne de caractères). 
Si cela ne fonctionne pas, une exception sera levée. Un objet sera converti en un type primitif autre uniquement si l'autre 
opérande est un type primitif (autre qu'objet). Si les deux opérandes sont des objets, 
ils seront comparés comme deux objets (voir ci-avant) et l'égalité ne sera vérifiée que si les opérandes font référence au même objet en mémoire

    Ex1:
    // true car les deux opérandes sont du type primitif chaîne de caractères
    'toto' === 'toto'
    var a = new String('toto');
    var b = new String('toto');
    // false car a et b sont du type objet mais font référence à deux objets distincts
    a == b 
    // false car a et b sont du type objet mais font référence à deux objets distincts
    a === b 
    // true car a et 'toto' sont de type différents et lorsque a est
    // converti, la fonction de conversion renvoie bien la chaîne 'toto'
    a == 'toto'

/// Égalité stricte (===) ///
1. L'opérateur d'égalité stricte renvoie true si les opérandes sont strictement égaux (voir ci-avant), aucune conversion de type n'est effectuée.

    Ex1:
    3 === 3   // true
    3 === '3' // false
    var objet1 = {'clé': 'valeur'}, objet2 = {'clé', 'valeur'};
    objet1 === objet2; // false


Différence entre undefined et null
-------------------------------
/// undefined : ///
1. Une variable possède la valeur undefined si elle n'est pas déclarée ou si elle est déclarée mais n'a pas encore eu de valeur d'assignée.

    Ex1: 
    var maVariable;
    alert(maVariable); // Le texte undefined s'affichera à l'écran, car la variable est non définie.
   
    Ex2: 
    function direBonjour(message) {
      console.log(message)
    }
    direBonjour(); // Le texte undefined s'affichera à l'écran, car la variable message déclarée en paramètre est non définie.

2. Il y a une faille dans JavaScript à connaître : le mot undefined n'est pas un mot-clé du langage. Il est donc possible de nommer une variable undefined, puis de lui attribuer une valeur.

    Ex1: 
    var undefined = toto; //Cette déclaration n'est pas fausse, contrairement à ce que l'on pourrait croire.
    if(maVariable === undefined) {
      alert(Vous avez été trompés!);
    }

3. Pour tester si une variable n'a pas été déclaré ou assignée, il faut utiliser typeof. 
typeof renvoie une chaîne qui indique le type de l'opérande (Quantité, donnée qui entre dans une opération arithmétique, une instruction informatique).

    Ex1:
    if (typeof maVariable === "undefined") {
      alert("La variable maVariable n'est pas définie");
    }

    Ex2:
    var x;
    if (typeof x === 'undefined') {
       // ces instructions seront exécutées
    }
    if (typeof x !== 'undefined') {
       // ces instructions ne seront pas exécutées
    }

4. Pour tester si une propriété d'objet est indéfinie on peut aussi utiliser typeof

    Ex1:
    const list = []
    const count = 2
    typeof list // "object"
    typeof count // "number"
    typeof "test" // "string"
    typeof color // "undefined"
    const car = {
      model: 'Fiesta'
    }
    if (typeof car.color === "undefined") {
      // color is undefined
    }

5. Une fonction qui n'a pas de valeur de return affiche undefined

    Ex1:
    function add() {
      const a = 3;
    }
    add(); // affiche undefined

/// null : ///
1. null sert à définir l'absence de valeur, on s'en sert par exemple pour assigner une valeur par défaut à des variables ou des paramètres de fonction, c'est une méthode beaucoup plus propre que d'assigner une valeur arbitraire comme 0 pour un entier, ou une chaine de caractère vide pour une chaine de caractère.

    Ex1:
    // toto n'existe pas, n'a pas été défini (déclaré) et n'a jamais été initialisé (assigné)
    toto;
    "ReferenceError: toto is not defined"
    // toto existe mais n'a ni type ni valeur
    var toto = null;
    console.log(toto); // null

    Ex2:
    function direBonjour(message = null) { // Valeur par défaut de message égale à null
      console.log(message); // null
    }

    Ex3:
    typeof null;           // "object" (pas null pour des raisons historiques)
    typeof undefined;      // "undefined"
    null === undefined;    // false
    null == undefined;    // true
    null === null;         // true
    null == null;         // true
    !null;                 // true
    isNaN(1 + null);       // false
    isNaN(1 + undefined);  // true


Double ou simple quotes ou accent grave (backquote ou backtick en anglais)
-------------------------------
1. C'est selon les préférences. L'avantage des doubles quotes est qu'il permet d'échapper les apostrophes et se conforme à JSON

    Ex1:
    alert('Say "Hello"');
    alert("Say 'Hello'");
    alert("It's \"game\" time.");
    alert('It\'s "game" time.');

2. En ES6 on peut aussi utiliser les template literals

    Ex1:
    alert(`Use "double" and 'single' quotes in the same string`);
    alert(`Escape the \` back-tick character and the \${ dollar-brace sequence in a string`);


Opérateur void
-------------------------------
1. L'opérateur void évalue (exécute) l'expression donnée void(0) équivaut à void 0 et retourne ensuite undefined.
    
    Ex1:
    void 2 == '2';    // renvoie false, attention à la précédence et donc mieux vaut utiliser des parenthèses
    void (2 === '2'); // renvoie undefined

2. On peut utiliser void pour ajouter un comportement preventDefault () pour un lien
    
    Ex1:
    <a href="javascript: void(0)"> À propos de </a>

3. On peut utiliser void pour qu'une function retourne undefined même si elle possède une valeur de retour.
    
    Ex1:
    function add() {
      const a = 3; return a
    };
    console.log(add()); // affiche 3
    console.log(void add()); // affiche undefined


L'opérateur this
-------------------------------
Voir https://www.youtube.com/watch?v=NV9sHLX-jZU

1. this est un opérateur qui permet de retourner une valeur en fonction de son contexte. Deux éléments peuvent influer dessus :
- Le contexte dans lequel this est appelé : global, fonction, fonction fléchée, méthode d'un objet…
- Le mode utilisé : strict ou non-strict.
Attention par contre, quand this est utilisé sans qu'il soit défini à son appel.
Grâce à apply() et call(), il est en effet possible de définir une valeur de this au sein de la fonction, 
ce qui change forcément l'utilisation que l'on peut en faire.

    Ex1:
    // Un objet peut être passé en premier argument
    // de call ou de apply
    var obj = { a: "Toto" };

    // Ici, on définit une propriété sur l'objet
    // global
    var a = "Global";

    function whatsThis(arg) {
      // La valeur de this ici dépend de la façon
      // dont la fonction est appelée
      return this.a;
    }

    whatsThis();          // "Global"
    whatsThis.call(obj);  // "Toto"
    whatsThis.apply(obj); // "Toto"

2. this dans un contexte global
Le contexte global, c'est lorsque l'on exécute du code en dehors de toute fonction, de tout bloc. 
Si on utilise this dans ce contexte, il retourne l'objet global.

    Ex1:
    console.log(this); // Dans un navigateur, cela retourne l'objet DOM window    
    this.alert('Message'); // Ouvre une boite de dialogue avec comme contenu : "Message".    
    window.alert('Message'); // C'est donc le même résultat que window.alert()    

    Ex2:
    // En mode strict, this retourne exactement la même chose qu'en mode non-strict
    "use strict";
    console.log(this);
    // Retourne l'objet DOM window dans le navigateur

3. this dans une fonction classique
Lorsque l'on utilise this dans une fonction classique, il retourne un objet, 
l'objet global (comme si on l'utilise hors de toute fonction).

    Ex1:
    function maFonction() {
      return this;
    }
    maFonction();
    // Dans un navigateur, cela retourne l'objet global window
    
    Ex2:
    // En mode strict, c'est un peu différent, this retourne undefined
    "use strict";

4. this dans une fonction fléchée (arrow function)
Le cas des fonctions fléchées est un peu particulier car elles ne créent pas de nouveau contexte. 
Du coup, la valeur de this reprend celle du contexte dans laquelle la fonction est définie.

    Ex1:
    const maFonction = () => { return this };
    maFonction();
    // Retourne window dans mon navigateur, this ayant la valeur de l'objet global.

    Ex2:
    // Si on utilise this dans une fonction fléchée définie dans une méthode d'un objet, 
    // this retourne bien l'objet
    const commentaire = {
      getAuthor: function() {
        const value = (() => this);
        return value;
      },
    };
    const test = commentaire.getAuthor();
    console.log(test());
    // Retourne bien l'objet complet

    Ex3:
    // En mode strict, le comportement est exactement le même
    const maFonction = () => { "use strict"; return this };
    maFonction();
    // Retourne window dans mon navigateur, this ayant la valeur de l'objet global.

5. this dans une méthode d'un objet
En POO, il est souvent nécessaire d'accéder aux propriétés et méthodes de l'objet courant pour 
les utiliser ailleurs. this est parfait pour y faire référence. Dans ce contexte, 
this retourne l'objet dans lequel la méthode est définie. 

    Ex1:
    const commentaire = {
      id: 7,
      author: 'Jean',
      content: 'Juste un simple commentaire',
      getAuthor: function(){
        return this.author
      },
    };
    commentaire.getAuthor();
    // Retourne 'Jean', this faisant référence à notre objet commentaire, this.author correspond à l'auteur de commentaire.

    Ex2:
    // En mode strict, le comportement est exactement le même
    "use strict";
    const article = {
      title: 'Un article',
      content: 'Contenu de mon article',
    };
    article.getTitle = function(){
      return this.title;
    };
    article.getTitle();
    // Retourne bien "Un article"

6. this dans une méthode de type constructeur
this fait référence à l’objet nouvellement créé.

    Ex1:
    function Jeu(){
      this.points = 120;
    }
    var j = new Jeu();
    console.log(Jeu.points);
    // Retourne 120
    // En mode strict, la valeur de this est similaire au mode non-strict

7. Voir https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_this

La « remontée » des déclarations de fonction
-------------------------------
1. Lorsqu'on utilise une déclaration de fonction pour créer une fonction, la définition de la fonction 
est « remontée » (hoisting). Il devient donc possible d'utiliser la fonction avant de l'avoir déclarée.
    
    Ex1:
    remontee(); // affiche "toto" dans la console
    function remontee() {
      console.log("toto");
    }

2. En tant qu'expression de fonction, l'interpréteur JavaScript ne va ni plus ni moins que remonter 
la déclaration de la variable et laisser l'affectation à son emplacement initial. Cela revient donc à écrire le code suivant.
    
    Ex1:
    foo();
    var foo = function() {
      console.log('foo');
    }
    // Affiche "Uncaught TypeError : foo is not a function"
    // Le code ci-dessus revient à écrire
    var foo;
    foo();
    foo = function() {
    console.log('foo');
    }

3. Il faut donc bien faire la distinction entre expression et déclaration de fonction, 
car l'interpréteur va les traiter de manière différente l'une de l'autre.

Définition d'un littéral
-------------------------------
En programmation informatique, une valeur littérale est une valeur donnée explicitement dans le code source d'un programme


Littéraux de gabarits (template strings en anglais)
-------------------------------
1. Les littéraux de gabarits sont des littéraux de chaînes de caractères permettant d'intégrer des expressions. 
Avec eux, on peut utiliser des chaînes de caractères multi-lignes et des fonctionnalités d'interpolation.
Pour utiliser des accents graves dans un gabarit, on les échappera avec une barre oblique inverse (\)

    Ex1:
    `texte`

    `ligne de texte 1
    ligne de texte 2`

    `texte ${expression} texte`

    etiquette `texte ${expression} texte`

    Ex2:
    // Les chaînes de caractères multi-lignes
    // Sans template strings
    console.log(
    'ligne de texte 1\n'+
    'ligne de texte 2'
    );
    // "ligne de texte 1
    // ligne de texte 2"

    // Avec template strings
    console.log(
    `ligne de texte 1
    ligne de texte 2`
    );
    // "ligne de texte 1
    //  ligne de texte 2"

    Ex3:
    // Interpolation d'expressions
    var a = 5;
    var b = 10;
    console.log(`Quinze vaut ${a + b}
    et non ${2 * a + b}.`);
    // "Quinze vaut 15 et
    // non 20."

    Ex4:
    // Imbrication de gabarits
    // Avant ES6
    var classes = 'header'
    classes += (isLargeScreen() ? '' : item.isCollapsed ? ' icon-expander' : ' icon-collapser');

    // Avec ES6 avec des gabarits et sans imbrication
    const classes = `header ${ isLargeScreen() ? '' : (item.isCollapsed ? 'icon-expander' : 'icon-collapser') }`;

    // Avec ES6 avec des gabarits imbriqués
    const classes = `header ${ isLargeScreen() ? '' : `icon-${item.isCollapsed ? 'expander' : 'collapser'}` }`;

2. Les gabarits étiquetés (tagged templates) sont une forme plus avancée de gabarits. On peut ici utiliser une fonction pour analyser les différents fragments du gabarit. 
Le premier argument passé à la fonction est l'ensemble de valeurs issues de chaînes de caractères sous la forme d'un tableau. 
Les arguments ensuite passés à la fonction seront les expressions contenues dans le gabarit. 
La fonction pourra ainsi créer une chaîne avec une autre forme de concaténation et utiliser une logique spécifique. 
La fonction utilisée pour le formatage du gabarit peut être nommée comme n'importe quelle autre fonction.

    Ex1:
    var personne = 'Michou';
    var age = 28;

    function monEtiquette(chaines, expPersonne, expAge) {
      var chn0 = chaines[0]; // "ce "
      var chn1 = chaines[1]; // " est un "

      // Techniquement, il y a une chaîne après
      // l'expression finale (dans notre exemple),
      // mais elle est vide (""), donc ne pas en tenir compte.
      // var chn2 = chaines[2];

      var chnAge;
      if (expAge > 99){
        chnAge = 'centenaire';
      } else {
        chnAge = 'jeunot';
      }
      // On peut tout à fait renvoyer une chaîne construite
      // avec un gabarit
      return `${chn0}${expPersonne}${chn1}${chnAge}`;
    }
    var sortie = monEtiquette`ce ${ personne } est un ${ age }`;
    console.log(sortie);
    // ce Michou est un jeunot

    Ex2:
    // Lors de l'exécution, le contenu du littéral est transmis à la fonction
    // strings : reçoit dans un tableau les chaînes intermédiaires (« Le résultat de la somme de » , « et » , « est ») ;
    // ...values : reçoit dans un tableau les valeurs des interpolations (a, b et a + b)
    var a = 2.3265;
    var b = 5.02154;
    function tag(strings, ...values) {
      var sortie = strings[0]
      + values[0].toFixed(2)
      + strings[1]
      + values[1].toFixed(2)
      + strings[2]
      + values[2].toFixed(2);
      return sortie;
    }
    var message = tag`Le résultat de la somme de ${a} et ${b} est ${a + b}`;

3. La propriété spéciale raw, disponible sur le premier argument de la fonction du gabarit étiqueté, vous permet d'accéder aux chaînes brutes, 
telles qu'elles ont été entrées, sans traiter les séquences d'échappement.

    Ex1:
    function etiquette(chaines) {
      console.log(chaines.raw[0]);
    }
    etiquette`ligne de texte 1 \n ligne de texte 2`;
    // affichera dans la console : 
    // "ligne de texte 1 \n ligne de texte 2"

    Ex2:
    // La méthode String.raw() a pour fonction de créer des chaînes de caractères brutes, 
    // exactement comme la fonction de gabarit et de concaténation de chaînes par défaut
    var chn = String.raw`Salut\n${2+3}!`; 
    // "Salut\n5!"
    chn.length;
    // 9
    chn.split('').join(',');
    // "S,a,l,u,t,\,n,5,!"
  

Les différents types de fonctions
-------------------------------
1. Une fonction anonyme est une fonction sans nom de fonction
    Ex1:    
    function () {};
    // ou en utilisant la notation de flèche de ECMAScript 2015
    () => {};

2. Une fonction nommée est une fonction avec un nom de fonction
    Ex1:
    function foo() {};
    // ou en utilisant la notation de flèche de ECMAScript 2015
    const foo = () => {};

3. Une fonction imbriquée (ou fonction interne) est une fonction à l'intérieur d'une autre fonction (square dans l'exemple suivant). 
Une fonction externe est une fonction qui contient une fonction (addSquares dans l'exemple suivant)
    Ex1:
    function addSquares(a,b) {
      function square(x) {
          return x * x;
      }
      return square(a) + square(b);
    };
    //En utilisant la notation de flèche de ECMAScript 2015
    const addSquares = (a,b) => {
      const square = x => x*x;
      return square(a) + square(b);
    };

4. Une fonction récursive est une fonction qui fait appel à elle-même
    Ex1:
    function loop(x) {
      if (x >= 10)
          return;
      loop(x + 1);
    };
    //En utilisant la notation de flèche de ECMAScript 2015
    const loop = x => {
      if (x >= 10)
          return;
      loop(x + 1);
    };

5. Une expression de fonction invoquée immédiatement (IIFE) est une fonction appelée directement après le chargement de la fonction dans le compilateur du navigateur. 
La façon d'identifier une IIFE est de localiser les parenthèses gauche et droite supplémentaires à la fin de la déclaration de la fonction.
    Ex1:
    (function foo() {
        console.log("Hello Foo");
    }());

6. Fonction qui retourne une autre fonction (Currying)
Le currying Permet de passer un paramètre à la fois grâce à des fonctions imbriquées. 
Cela permet de garder en mémoire un paramètre et de n'exécuter que la fonction imbriquée
plutôt que toute la fonction.

    Ex1:
    // Sans currying
    const multiply = (a, b) => a * b

    // Avec currying
    const curriedMultiply = (a) => (b) => a * b

    const curriedMultiplyBy5 = curriedMultiply(5)

    // Le premier paramètre 5 est gardé en mémoire de curriedMultiplyBy5...
    // ...on a plus qu'à passer le deuxième paramètre pour utiliser la fonction
    // Cette fonction avec currying s'exécute plus rapidement que sans currying
    curriedMultiplyBy5(4) // 20
    curriedMultiplyBy5(4) // 20
    curriedMultiplyBy5(3) // 15

	Ex2:
	function add(x){
	  return function(y){
	    return x + y;
	  };
	}
	var addTwo = add(2);

	addTwo(4) === 6; // true
	add(3)(4) === 7; // true


L'objet arguments
-------------------------------
1. Les arguments d'une fonction sont maintenus dans un objet semblable à un tableau. 
Dans une fonction, il est possible d'utiliser les arguments passés 
à la fonction de la façon suivante : arguments[i]
ù i représente l'index ordinal de l'argument (le premier argument ayant un indice à 0). On accède donc au premier argument avec arguments[0]. 
Le nombre total d'arguments est fourni grâce à arguments.length. En utilisant l'objet arguments, il est possible de recenser 
les arguments supplémentaires fournis à la fonction si jamais il y a plus d'arguments fournis que requis. 
Cet objet est souvent utile si on ne connaît pas le nombre d'arguments passés à la fonction. 
La propriété arguments.length permet de déterminer le nombre d'arguments réellement passés à la fonction. 
On peut donc ensuite accéder aux différents arguments en parcourant l'objet arguments.
    Ex1:
    // Fonction qui concatène plusieurs chaînes
    // Le seul argument formellement défini sera la chaîne utilisée comme séparateur 
    // pour concaténer les différentes chaînes. 
    function monConcat(séparateur) {
      var result = ""; // on initialise la liste
      var i;
      // on parcourt les arguments
      for (i = 1; i < arguments.length; i++) {
          result += arguments[i] + séparateur;
      }
      return result;
    }
    // On peut passer autant d'arguments que nécessaire à cette fonction. Ils seront tous concaténés dans une chaîne finale
    // renverra "rouge, orange, bleu, "
    monConcat(", ", "red", "orange", "blue");

    // renverra "éléphant; girafe; lion; singe; "
    monConcat("; ", "éléphant", "girafe", "lion", "singe");

    // renverra "sauge. basilic. origan. poivre. échalotte. "
    monConcat(". ", "sauge", "basilic", "origan", "poivre", "échalotte");    

Les expressions de fonctions
-------------------------------
1. Une expression de fonction est très similaire et a presque la même syntaxe qu'une déclaration de fonction. La différence principale entre une expression de fonction et une instruction est le nom de la fonction. En effet, pour les expressions, celui peut être omis (on parle alors d'une fonction anonyme). 
    Ex1:
    var getRectArea = function(width, height) {
    return width * height;
    }
    console.log(getRectArea(3,4));
    // expected output: 12    

2. En JavaScript, les expressions de fonction ne sont pas remontées (à la différence des déclarations de fonction). Il est donc impossible d'utiliser les expressions de fonction avant leur définition.
    Ex1:
    nonRemontée(); // TypeError: nonRemontée is not a function
    var nonRemontée = function() {
      console.log("truc");
    }

3. On peut utiliser une expression de fonction pour créer une « IIFE » (Immediately Invoked Function Expression), c'est-à-dire une expression de fonction qu'on appelle dès sa définition.
    Ex1:
    var a = "coucou";
    var b = "monde";
    // IIFE
    (function(x, y) {
      console.log(x + " " + y);
    })(a, b);
    // coucou monde


Les fonctions fléchées (arrow function en anglais)
-------------------------------
    // Avant ES6
    const add = function(x, y) {
        return x + y
    }
    console.log(add(5, 4)) // 9
1. Une expression de fonction fléchée permet d'avoir une syntaxe plus courte que les expressions de fonction. Les fonctions fléchées sont souvent anonymes et ne sont pas destinées à être utilisées pour déclarer des méthodes.    
    Ex1:    
    // ES6
    const addES6 = (x, y) => { return x + y }
    console.log(addES6(5, 6)) // 11

2. Les accolades ne sont même pas obligatoire ici et le mot clé return aussi, parce que l'on renvoie une seule instruction.
    Ex1:
    // ES6
    const addES6 = (x, y) => x + y
    console.log(addES6(5, 6)) // 11

3. Quand on a un seul paramètre, nous n'avons donc pas besoin des parenthèses, on renseigne juste le nom du paramètre.
    Ex1:
    // ES6
    const hello = name => `Hello ${name}`
    console.log(hello('Niang')) // Hello Niang

    Ex2:
    var simple = a => a > 15 ? 15 : a; 
    simple(16); // 15
    simple(10); // 10


4. Pour définir une fonction sans paramètre, on met juste des parenthèses vides.
    Ex1:
    // ES6
    const helloWorld = () => 'Hello World!'
    console.log(helloWorld()) // Hello World!

5. Pour retourner un objet, il y a une petite différence, parce que l'objet doit être dans des accolades, il faut donc mettre le return entre parenthèses cette fois-ci pour faire la différence.
    Ex1:
    const setContent = (title, content) => ({title: title, content: content})
    console.log(setContent('Hello', 'ES6')) // {title: "Hello", content: "ES6"}

6. Il ne peut pas y avoir de saut de ligne entre les paramètres et la flèche d'une fonction fléchée.
    Ex1:
    var func = ()
            => 1; // SyntaxError: expected expression,
                  //              got '=>'

7. La flèche utilisée pour une fonction fléchée n'est pas un opérateur. Les fonctions fléchées ont des règles spécifiques quant à leur place dans la syntaxe et interagissent différemment de la précédence des opérateurs par rapport à une fonction classique.
    Ex1:
    let fonctionRappel;
    fonctionRappel = fonctionRappel || function () {};
    // OK
    fonctionRappel = fonctionRappel || () => {};
    // SyntaxError: invalid arrow-function arguments
    fonctionRappel = fonctionRappel || (() => {});
    // OK

8. Les fonctions fléchées sont mieux indiquées pour les fonctions qui ne sont pas des méthodes (fonctions dans un objet).
    Ex1:
    'use strict';
    var objet = {
      i: 10,
      b: () => console.log(this.i, this),
      c: function() {
        console.log(this.i, this);
      }
    }
    objet.b(); 
    // affiche undefined, Window (ou l'objet global de l'environnement)
    objet.c();
    // affiche 10, Object {...}

9. Les fonctions fléchées ne créent pas de nouveau contexte, elles utilisent la valeur this de leur contexte. Aussi, si le mot-clé this est utilisé dans le corps de la fonction, le moteur recherchera la référence à cette valeur dans une portée parente.
    Ex1:
    // Avant ES6
    function Personne () {
      var that = this; 
      that.age = 0;
      setInterval(function grandir () {
        // La fonction callback se réfère à la variable `that`
        // qui est le contexte souhaité
        that.age++;
      }, 1000);
    }
    // ES6
    function Personne () {
      this.age = 0;
      setInterval(() => {
        this.age++; 
          // |this| fait bien référence à l'objet personne
      }, 1000);
    }
    var p = new Personne();

    Ex2:
    // Dans React
    class App extends Component {
        constructor( {
            super()

            this.state = {
                monster: [],
                searchfield: ''
            };


            // Sans utilisation d'une arrow function pour la méthode handlechange
            // On doit attacher le contexte de la classe au this de la méthode handlechange
            // this.handleChange = this.handleChange.bind(this);
        })        

        handleChange = e => {
            // Avec une arrow function le this est automatiquement attaché au contexte
            // où la méthode est déclarée, ici la class App
            this.setState({ searField: e.target.value });
        }

        [...]
    }



10. Exemples d'utilisation
    Ex1:
    (() => "tototruc")() 
    // exemple d'une fonction immédiatement 
    // invoquée (IIFE en anglais) qui renvoie 
    // "tototruc" 

    var complexe = (a, b) => {
      if (a > b) {
          return a;
      } else {
          return b;
      }
    }

    var arr = [5, 6, 13, 0, 1, 18, 23];
    var sum = arr.reduce((a, b) => a + b);
    // 66
    var even = arr.filter(v => v % 2 == 0);
    // [6, 0, 18]
    var double = arr.map(v => v * 2);       
    // [10, 12, 26, 0, 2, 36, 46]


Raccourci ES6 pour écrire la méthode d'un objet
-------------------------------
    ////////////////////////////////////// EX:
    // Sans ES6
    var chopper = {
        owner: 'Zed',
        getOwner: function() {
            return this.owner;
        }
    };

    // Avec ES6

    var chopper = {
        owner: 'Zed',
        getOwner() {
            return this.owner;
        }
    };


IIFE (Expression de fonction invoquée immédiatement)
-------------------------------
1. IIFE (Immediately Invoked Function Expression) (Expression de fonction invoquée immédiatement) 
est une fonction JavaScript qui est exécutée dès qu'elle est définie.
C'est un modèle de conception qui est également connu sous le nom de Fonction anonyme auto-exécutable et contient deux parties principales. 
La première est la fonction anonyme avec portée lexicale incluse dans le groupement opérateur(). Cela empêche l'accès aux variables dans 
l'expression idiomatique IIFE ainsi que la pollution de la portée globale.
La deuxième partie crée la fonction immédiatement exécutable (), à travers laquelle le moteur JavaScript interprétera directement la fonction.
La fonction devient une expression de fonction qui est immédiatement exécutée. La variable dans l'expression ne peut pas être atteinte de l'extérieur.

    Ex1:
    (function () { 
        var aName = "Barry";
    })();
    // Le nom de la variable n'est pas accessible depuis le périmètre externe
    aName // lancement "Exception ReferenceError: aName n'est pas défini"

2. Affecter l'IIFE à une variable ne la stocke pas mais reçoit son résultat.

    Ex1:
    var result = (function () { 
        var name = "Barry"; 
        return name; 
    })(); 
    // Crée immédiatement la sortie: 
    result; // "Barry"

    var myFunction = function hello() {
        console.log(hello.name); //affiche hello
    }();
    console.log(myFunction); //affiche undefined


L'instruction Return
-------------------------------
1. Les fonctions JavaScript retournent undefined si aucun retour n'est
spécifié ou si un retour vide est spécifié.
    EX:
    function test(){}
    test() // undefined

    EX:
    function test(){ let a = 2; return; }
    test() // undefined

2. L'instruction return met fin à l'exécution de la fonction. Toutes
les instructions après l'exécution du return ne seront pas exécutées.

3. Il ne faut pas de retour à la ligne entre return et la valeur que l'on
souhaite retournée.
    EX:
    return
    a+b; // Le retour à la ligne peut poser problème.

    return a+b // Bon 

    return ( // Bon avec des parenthèses
        a+b 
    );

4. L'instruction return peut renvoyer une fonction.
    EX:
    function magique() {
        return function calc(x {return x * 42})
    }

    var reponse = magique()
    reponse(1337) // 56154

5. L'instruction return peut interrompre une boucle au milieu de son
exécution.
    EX:
    function stopAtThree() {
        for(var i = 0; i <= 10; i++){
            if(i === 3) return i
        }
    }

    stopAtThree() // 3
        

Différence entre argument et paramètre
-------------------------------
1. Un argument est une valeur qui est passée au moment d'appeler une fonction.

2. Un paramètre est une variable définie par une fonction qui reçoit une valeur lorsque la fonction est appelée.
Un paramètre est dans la fonction appelée.


Objet Map
-------------------------------
1. L'objet Map représente un dictionnaire, autrement dit une carte de clés/valeurs. 
N'importe quelle valeur valable en JavaScript (que ce soit les objets ou les valeurs de types primitifs) 
peut être utilisée comme clé ou comme valeur. Un objet Map permet de retrouver ses éléments dans leur ordre d'insertion. 
Par exemple, une boucle for...of renverra un tableau de [clé, valeur] pour chaque itération.

//new Map([itérable])
    [itérable]
        Un tableau (Array) ou tout autre objet itérable dont les éléments sont des paires clé/valeur (par exemple un tableau de la forme [[1 , "toto"],[2, "truc"]]). Chaque paire clé/valeur sera ajoutée au nouvel objet Map. null est traité comme undefined.
    
    Ex1:
    // Utiliser un objet Map
    var maMap = new Map();
    var objetCle = {},
        fonctionCle = function () {},
        chaineCle = "une chaîne";
    // définir les valeurs
    maMap.set(chaineCle, "valeur associée à 'une chaîne'");
    maMap.set(objetCle, "valeur associée à objetCle");
    maMap.set(fonctionCle, "valeur associée à fonctionCle");
    maMap.size; // 3
    // récupérer les valeurs
    maMap.get(chaineCle);     // "valeur associée à 'une chaîne'"
    maMap.get(objetCle);      // "valeur associée à objetCle"
    maMap.get(fonctionCle);   // "valeur associée à fonctionCle"
    maMap.get("une chaîne");  // "valeur associée à 'une chaîne'"
                              // car chaineCle === 'une chaîne'

    Ex2:
    // Parcourir des objets Maps avec for..of
    var maMap = new Map();
    maMap.set(0, "zéro");
    maMap.set(1, "un");
    for (var [cle, valeur] of maMap) {
      console.log(cle + " = " + valeur);
    }
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"
    for (var cle of maMap.keys()) {
      console.log(cle);
    }
    // On aura 2 lignes : la première avec "0"
    // et la seconde avec "1"
    for (var valeur of maMap.values()) {
      console.log(valeur);
    }
    // On aura 2 lignes : la première avec "zéro"
    // et la seconde avec "un"
    for (var [cle, valeur] of maMap.entries()) {
      console.log(cle + " = " + valeur);
    }
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"
    maMap.forEach(function(valeur, cle) {
      console.log(cle + " = " + valeur);
    });
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"

    Ex3:
    // Relation avec les objets Array
    var tableauCleValeur = [["cle1", "valeur1"], ["cle2", "valeur2"]];
    // On utilise le constructeur Map
    // pour transformer un tableau de cles/valeurs
    // en un objet map
    var maMap = new Map(tableauCleValeur);
    maMap.get("cle1"); // renvoie "valeur1"
    // On utilise la fonction Array.from pour transformer
    // une map en un tableau de cles/valeurs
    console.log(Array.from(maMap)); // affichera la même chose que tableauCleValeur
    // On peut aussi l'utiliser pour n'extraire que les cles
    // ou les valeurs et créer le tableau associé
    console.log(Array.from(maMap.keys())); // affichera ["cle1", "cle2"]

    Ex4:
    // Fusionner des objets Map
    var premier = new Map([
      [1, 'un'],
      [2, 'deux'],
      [3, 'trois'],
    ]);
    var second = new Map([
      [1, 'uno'],
      [2, 'dos']
    ]);
    // On fusionne les deux maps. C'est la "dernière" version
    // de la clé qui l'emporte.
    // L'opérateur de décomposition nous permet principalement ici
    // de convertir une map en un tableau
    var fusion = new Map([...premier, ...second]);
    console.log(fusion.get(1)); // uno
    console.log(fusion.get(2)); // dos
    console.log(fusion.get(3)); // trois

    // Fusionner des objets Map avec des objets Array
    var premier = new Map([
      [1, 'un'],
      [2, 'deux'],
      [3, 'trois'],
    ]);
    var second = new Map([
      [1, 'uno'],
      [2, 'dos']
    ]);
    // On peut fusionner des Maps avec un tableau 
    // Là encore c'est le dernier exemplaire de la clé qui l'emporte
    var fusion = new Map([...premier, ...second, [1, 'eins']]);
    console.log(fusion.get(1)); // eins
    console.log(fusion.get(2)); // dos
    console.log(fusion.get(3)); // trois


Object Set
-------------------------------
1. L'objet Set (Ensemble en français) permet de stocker des valeurs uniques, de n'importe quel type, que ce soit des valeurs d'un type primitif ou des objets.

Les objets Set sont des ensembles de valeurs. Il est possible d'itérer sur
les éléments contenus dans l'objet Set dans leur ordre d'insertion. Une
valeur donnée ne peut apparaître qu'une seule fois par Set.

//new Set([itérable]);
    [itérable]
        Paramètre optionnel. Si un objet itérable est donné comme argument, l'ensemble de ses éléments sera ajouté au nouvel objet Set. Si null est fourni comme argument ou qu'aucun argument n'est fourni, il sera traité comme undefined.

    Valeur de retour
        Un nouvel objet Set.    

    EX:
    // Utiliser un objet Map
    var monSet = new Set();

    monSet.add(1);         // { 1 }
    monSet.add(5);         // { 1, 5 }
    monSet.add("du texte");// { 1, 5, "du texte" }

    monSet.has(1); // true
    monSet.has(3); // false, 3 n'a pas été ajouté à l'ensemble
    monSet.has(5);              // true
    monSet.has(Math.sqrt(25));  // true
    monSet.has("Du Texte".toLowerCase()); // true

    monSet.size; // 3

    monSet.delete(5); // retire 5 du set
    monSet.has(5);    // false, 5 a été retiré de l'ensemble

    monSet.size; // 2, on a retiré une valeur de l'ensemble
    console.log(monSet); // Set [ 1, "du texte" ]

    EX:
    // Itérer sur des ensembles (Set)
    // On itère sur les différents éléments de l'ensemble
    // ici on affiche : 1, "du texte" 
    for (let item of monSet) console.log(item);

    // ici on affiche les clés de l'ensemble : 1, "du texte"  
    for (let item of monSet.keys()) console.log(item);
     
    // ici on affiche les valeurs de l'ensemble : 1, "du texte" 
    for (let item of monSet.values()) console.log(item);

    // ici on affiche les clés de l'ensemble : 1, "du texte" 
    //(ici, les clés et les valeurs sont les mêmes)
    for (let [clé, valeur] of monSet.entries()) console.log(clé);

    // Une méthode de conversion avec Array.from
    var monTableau = Array.from(monSet);    // [1, "du texte"]

    // Cela fonctionnera également dans un document HTML
    monSet.add(document.body);
    monSet.has(document.querySelector("body")); // true

    // convertir un tableau (Array) en ensemble (Set) et vice versa
    monSet2 = new Set([1,2,3,4]);
    monSet2.size; // 4
    [...monSet2]; // [1,2,3,4]

    // L'intersection peut être calculée avec
    var intersection = new Set([...set1].filter(x => set2.has(x)));

    // La différence pourra être simulée avec 
    var différence = new Set([...set1].filter(x => !set2.has(x)));

    // On peut itérer sur les entrées d'un ensemble avec forEach
    mySet.forEach(function(value) {
      console.log(value);
    });

    // 1
    // 2
    // 3
    // 4

    EX:
    // Implémenter des opérations ensemblistes
    function isSuperset(set, subset) {
      for (var elem of subset) {
        if (!set.has(elem)) {
          return false;
        }
      }
      return true;
    }

    function union(setA, setB) {
      var union = new Set(setA);
      for (var elem of setB) {
        union.add(elem);
      }
      return union;
    }

    function intersection(setA, setB) {
      var intersection = new Set();
      for (var elem of setB) {
        if (setA.has(elem)) {
          intersection.add(elem);
        }
      }
      return intersection;
    }

    function difference (setA, setB) {
      var difference = new Set(setA);
      for (var elem of setB) {
        difference.delete(elem);
      }
      return difference;
    }

    // Exemples
    var setA = new Set([1,2,3,4]),
        setB = new Set([2,3]),
        setC = new Set([3,4,5,6]);

    isSuperset(setA, setB);   // => true
    union(setA, setC);        // => Set [1, 2, 3, 4, 5, 6]
    intersection(setA, setC); // => Set [3, 4]
    difference(setA, setC);   // => Set [1, 2]

    EX:
    // Les relations avec les objets Array
    var monTableau = ["valeur1", "valeur2", "valeur3"];

    // On peut utiliser le constructeur Set pour transformer un Array en Set
    var monSet = new Set(monTableau);

    monSet.has("valeur1"); // renvoie true

    // Et utiliser l'opérateur de décomposition pour transformer un Set en Array.
    console.log([...monSet]); // affichera la même chose que monTableau

    EX:
    // Les relations avec les objets String
    var maChaine = "CouCou";

    var monEnsemble = new Set(maChaine);
    // Set {"C","o","u" }
    monEnsemble.size; // 3

    EX:
    // Dédoublonner un tableau
    const nombres = [2,3,4,4,2,2,2,4,4,5,5,6,6,7,5,32,3,4,5];
    console.log([...new Set(nombres)]);
    // affichera [2, 3, 4, 5, 6, 7, 32]


Object Property Value Shorthand
-------------------------------
1. If you want to define or set an object who's keys have the same name as the variables passed-in as properties, you can use the shorthand and simply pass the key name.
    Ex1:
    // Avant ES6
    var cat = 'Miaow';
    var dog = 'Woof';
    var bird = 'Peet peet';
    var someObject = {
      cat: cat,
      dog: dog,
      bird: bird
    }
    // ES6
    let cat = 'Miaow';
    let dog = 'Woof';
    let bird = 'Peet peet';
    let someObject = {
      cat,
      dog,
      bird
    }
    console.log(someObject);
    //{
    //  cat: "Miaow",
    //  dog: "Woof",
    //  bird: "Peet peet"
    //}

    Ex2:
    state = {
      text: sampleText
    };

    editText = (event) => {
      const text = event.target.value;
      this.setState({ text }); // au lieu de this.setState({ text: text});
    };


Noms de propriétés calculés (Computed Properties)
-------------------------------
1. Avec ECMAScript 2015 (ES6), on peut utiliser un initialisateur et avoir des noms de propriétés qui soient calculés lors de l'exécution. Ainsi, en plaçant une expression entre crochets [], celle-ci sera calculée pour déterminer le nom de la propriété. Cette notation est la symétrique des crochets utilisés pour accéder aux propriétés. Il est désormais possible d'utiliser cette notation dans les littéraux objets
    Ex1:
	// Calcul des noms de propriétés (ES2015)
	var i = 0;
	var a = {
	  ['toto' + ++i]: i,
	  ['toto' + ++i]: i,
	  ['toto' + ++i]: i
	};

	console.log(a.toto1); // 1
	console.log(a.toto2); // 2
	console.log(a.toto3); // 3

	var param = 'taille';
	var config = {
	  [param]: 12,
	  ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
	};

	var prop = "toto";
	var o = {
	  [prop]: "hey",
	  ["tr" + "uc"]: "ho",
	};


Boucles
-------------------------------
FOR...OF (ES6)
for (variable of iterable)
  instruction

    [variable]
      À chaque itération, la valeur d'une propriété différente est affectée à variable (cette variable peut être déclarée avec const, let ou var).
    [iterable]
      L'objet dont on parcourt les propriétés énumérables.
    [instruction]
      Une instruction à exécuter pour chaque propriété, cette instruction peut être composée de plusieurs instructions en utilisant un bloc d'instructions.

1. L'instruction for...of permet de créer une boucle Array qui parcourt un objet itérable 
(ce qui inclut les objets Array, Map, Set, String, TypedArray, l'objet arguments, etc.) et 
qui permet d'exécuter une ou plusieurs instructions pour la valeur de chaque propriété.

    Ex1:
    // Sur un tableau
    let tableauIterable = [1, 2, 3];
    for (let valeur of tableauIterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3

    Ex2:
    // Parcourir une chaîne de caractères
    let iterable = 'pixel';
    for (let valeur of iterable) {
      console.log(valeur);
    }
    // p
    // i
    // x
    // e
    // l

    Ex3:
    // Parcourir une Map
    let iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);
    for (let element of iterable) {
      console.log(element);
    }
    // ['a', 1]
    // ['b', 2]
    // ['c', 3]
    for (let [clef, valeur] of iterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3


FOR...IN
for (variable in objet) {...
}

    [variable]
      Un nom de propriété différent est assigné à la variable à chaque itération de la boucle.
    [objet]
      L'objet dont les propriétés énumérables et qui ne sont pas des symboles sont parcourues par la boucle.

1. L'instruction for...in permet d'itérer sur les propriétés énumérables d'un objet qui ne sont pas des symboles. 
Pour chaque propriété obtenue, on exécute une instruction (ou plusieurs grâce à un bloc d'instructions).
for...in ne doit pas être utilisée pour parcourir un Array lorsque l'ordre des éléments est important.

    Ex1:
    // Sur un objet
    var obj = {a:1, b:2, c:3};    
    for (var prop in obj) {
      console.log(`obj.${prop} = ${obj[prop]}`);
    }
    // Affiche dans la console :
    // "obj.a = 1"
    // "obj.b = 2"
    // "obj.c = 3"

    Ex2:
    // Parcourir une chaîne de caractères
    let iterable = 'pixel';
    for (let valeur of iterable) {
      console.log(valeur);
    }
    // p
    // i
    // x
    // e
    // l


LES DIFFÉRENCES ENTRE FOR...OF ET FOR...IN
1. (Voir exemple ci-dessous) Chaque objet héritera de la propriété objCustom et chaque objet qui est un tableau (Array) héritera de la propriété arrCustom car 
on les ajoute aux prototypes Object.prototype et Array.prototype. L'objet iterable hérite donc des propriétés objCustom et 
arrCustom grâce à l'héritage et à la chaîne de prototypes.
Cette boucle ne parcourt que les propriétés énumérables de l'objet iterable dans un ordre arbitraire. 
Les éléments du tableau 3, 5, 7 ou "coucou" ne sont pas affichés car ce ne sont pas des propriétés 
(et encore moins des propriétés énumérables). En revanche, on retrouve bien les indices du tableau et 
les propriétés arrCustom et objCustom. Pour décrire plus précisément ce comportement, vous pouvez consulter for...in.

    Ex1:
    Object.prototype.objCustom = function() {}; 
    Array.prototype.arrCustom = function() {};
    let iterable = [3, 5, 7];
    iterable.toto = 'coucou';
    for (let i in iterable) {
      console.log(i); // affiche 0, 1, 2, "toto",
                      // "arrCustom", "objCustom"
    }
    for (let i in iterable) {
      if (iterable.hasOwnProperty(i)) {
        console.log(i); // affiche 0, 1, 2, "toto"
      }
    }
    // Cette boucle parcourt les valeurs définies comme itérables par l'objet itérable et 
    // dans ce cas ce sont les éléments du tableau 3, 5, 7 et pas les propriétés de l'objet (ici toto et sa valeur "coucou")
    for (let i of iterable) {
      console.log(i); // affiche 3, 5, 7
    }

Fonctions sur les tableaux
-------------------------------
FOREACH()
// arr.forEach(callback);
// arr.forEach(callback, thisArg);
1. Permet d'exécuter une fonction donnée sur chaque élément du tableau. 
forEach exécute la fonction callback une fois pour chaque élément ; 
contrairement à every et some, cette méthode renvoie toujours undefined et ne peut pas être enchaînée.
Il n'existe aucun moyen d'arrêter une boucle forEach en dehors de lever une exception.
L'ensemble des éléments traités par forEach est défini avant le premier appel à callback. 
Les éléments ajoutés au tableau après que l'appel à forEach ait commencé ne seront pas visités par callback. 
Si des éléments déjà présents dans le tableau sont modifiés, leur valeur telle qu'elle est passée au callback 
sera la valeur au moment du passage du forEach ; les éléments supprimés ne sont pas parcourus.
    
    [callback] est appelé avec trois arguments :
      - la valeur de l'élément
      - l'index de l'élément
      - le tableau utilisé

    [thisArg] (Facultatif)
      La valeur à utiliser pour this lors de l'exécution de callback. La valeur par défaut 
      est l'objet global de l'environnement (Window pour un navigateur).

    Valeur de retour :
        undefined

    Ex1:
    var array1 = ['a', 'b', 'c'];
    array1.forEach(function(element) {
      console.log(element);
    });

    Ex2:
    let arr = [3, 5, 7];
    arr.toto = "coucou";
    arr.forEach(function (element, index) {
      console.log(element); // affiche "3", "5", "7"
      console.log(index);  // affiche "0", "1", "2"
    });

    Ex3:
    function logArrayElements(element, index, array) {
        console.log("a[" + index + "] = " + element);
    }
    [2, 5, , 9].forEach(logArrayElements);
    // logs:
    // a[0] = 2
    // a[1] = 5
    // a[3] = 9

    Ex4:
    // Utiliser this
    function Compteur() {
      this.somme = 0;
      this.compte = 0;
    }

    Compteur.prototype.ajouter = function(tableau) {
      tableau.forEach(function(element) {
        this.somme += element;
        ++this.compte;
      },  this);
      //  ^---- On a ajouté l'argument this ici.
    };

    var obj = new Compteur();
    obj.ajouter([2, 5, 9]);
    console.log(obj.compte); // 3
    console.log(obj.somme);  // 16


CONSOLE.TABLE()
// console.table(data [, columns]);
    [data]
      La donnée à afficher. Doit être un tableau ou un objet.
    [columns]
      Un tableau contenant les noms des colonnes à inclure dans la sortie.

    Ex1:
    // data peut contenir un tableau ou un objet.
    // un tableau de chaînes de caractères
    console.table(["apples", "oranges", "bananas"]);

    Ex2:
    // un objet dont les propriétés sont des chaînes de caractères
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var me = new Person("John", "Smith");
    console.table(me);

    Ex3:
    // un tableau de tableaux
    var people = [["John", "Smith"], ["Jane", "Doe"], ["Emily", "Jones"]]
    console.table(people);

    Ex4:
    // un tableau d'objets
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var john = new Person("John", "Smith");
    var jane = new Person("Jane", "Doe");
    var emily = new Person("Emily", "Jones");
    console.table([john, jane, emily]);

    Ex5:
    // un objet contenant des propriétés qui sont des objets
    var family = {};
    family.mother = new Person("Jane", "Smith");
    family.father = new Person("John", "Smith");
    family.daughter = new Person("Emily", "Smith");
    console.table(family);

    Ex6:
    // un tableau d'objets, affichant seulement firstName
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var john = new Person("John", "Smith");
    var jane = new Person("Jane", "Doe");
    var emily = new Person("Emily", "Jones");
    console.table([john, jane, emily], ["firstName"]);


REDUCE()
// arr.reduce(callback, [, valeurInitiale])
// callback(accumulator, currentElement)
1. reduce() permet d'accumuler les valeurs d'un tableau
selon la fonction passée en callback.
valeurInitiale permet de charger l'accumulateur avec une valeur
de départ et ensuite accumule le reste du tableau.
Si valeurInitiale n'est pas fournie, reduce exécutera la fonction de callback à partir 
de l'indice 1 et la première valeur du tableau (d'indice 0) sera utilisée pour valeurInitiale.
La fonction callback ignore les éléments vides du tableau.

    [callback]
      La fonction à exécuter sur chaque valeur de la liste (sauf le premier si aucune valeurInitiale n'est fournie), elle prend quatre arguments en entrée :
        [accumulateur]
          La valeur précédemment retournée par le dernier appel du callback, ou valeurInitiale, si elle est fournie (voir ci-après) (c'est la valeur « accumulée » au fur et à mesure des appels)
        [valeurCourante]
          La valeur de l'élément courant actuellement manipulé dans le tableau.
        [index] (Facultatif)
          L'index de l'élément courant actuellement manipulé dans le tableau.
        [array] (Facultatif)
          Le tableau sur lequel on a appelé la méthode reduce().
    [valeurInitiale] (Facultatif)
      Une valeur utilisée comme premier argument lors du premier appel de la fonction callback. Si aucune valeur initiale n'est fournie, le premier élément du tableau est utilisé. Si on appelle reduce() sur un tableau vide sans fournir de valeur initiale, on aura une erreur.
      Pour être sûr d'accumuler tous les éléments du tableau mettre comme valeur 0 ou un tableau vide [] ou un objet vide {}

    Valeur de retour :
        La valeur obtenue grâce à la fonction de réduction.

    Ex1:
    // Sans fonction fléchée
    [0, 1, 2, 3, 4].reduce(function(accumulateur, valeurCourante, index, array){
      return accumulateur + valeurCourante;
    });
    // 10

    // Avec fonction fléchée
    [0, 1, 2, 3, 4].reduce((accumulateur, valeurCourante) => accumulateur + valeurCourante);
    // 10
    // Premier appel du callback : accumulateur vaut 0 et valeurCourante vaut 1
    // le callback retourne accumulateur + valeurCourante soit 1 et le place dans l'accumulateur
    // Deuxième appel du callback : accumulateur vaut 1 et valeurCourante vaut 2
    // le callback retourne accumulateur + valeurCourante soit 3 et le place dans l'accumulateur
    // Troisième appel du callback : accumulateur vaut 3 et valeurCourante vaut 3
    // le callback retourne accumulateur + valeurCourante soit 6 et le place dans l'accumulateur
    // Quatrième appel du callback : accumulateur vaut 6 et valeurCourante vaut 4
    // le callback retourne accumulateur + valeurCourante soit 10 et le place dans l'accumulateur
    // reduce retourne la valeur de l'accumulateur à la fin des appels du callback soit 10


    Ex2:
    // Avec valeurInitiale
    [0, 1, 2, 3, 4].reduce((accumulateur, valeurCourante) => accumulateur + valeurCourante, 10);
    // 20
    // Premier appel du callback : accumulateur vaut 10 et valeurCourante vaut 0
    // le callback retourne accumulateur + valeurCourante soit 10 et le place dans l'accumulateur
    // Deuxième appel du callback : accumulateur vaut 10 et valeurCourante vaut 1
    // le callback retourne accumulateur + valeurCourante soit 11 et le place dans l'accumulateur
    // Troisième appel du callback : accumulateur vaut 11 et valeurCourante vaut 2
    // le callback retourne accumulateur + valeurCourante soit 13 et le place dans l'accumulateur
    // Quatrième appel du callback : accumulateur vaut 13 et valeurCourante vaut 3
    // le callback retourne accumulateur + valeurCourante soit 16 et le place dans l'accumulateur
    // Cinquième appel du callback : accumulateur vaut 16 et valeurCourante vaut 4
    // le callback retourne accumulateur + valeurCourante soit 20 et le place dans l'accumulateur
    // reduce retourne la valeur de l'accumulateur à la fin des appels du callback soit 20

MAP()
// let nouveauTableau = arr.map(callback [, thisArg])
1. La fonction callback fournie en argument est exécutée une fois pour chacun des éléments du tableau, dans l'ordre du tableau. 
Chaque résultat de l'opération sur un élément sera un élément du nouveau tableau. La fonction callback est appelée uniquement pour les indices du tableau 
pour lesquels il y a des valeurs affectées (y compris si cette valeur est undefined). Si les valeurs ont été supprimées ou qu'elles n'ont jamais été initialisées, la fonction ne sera pas appelée.
Si on utilise cette méthode sans utiliser le résultat, mieux vaudra utiliser forEach ou for...of. 

    [callback]
      La fonction qui est utilisée pour créer un élément du nouveau tableau. Elle utilise trois arguments
        [valeurCourante]
          La valeur de l'élément du tableau à traiter.
        [index]
          L'index de l'élément qui est traité par la fonction.
        [tableau] (Facultatif)
          Le tableau sur lequel on a appelé la méthode map.
    [thisArg] (Facultatif)
      La valeur à utiliser pour this lors de l'exécution de callback. La valeur par défaut est l'objet global de l'environnement (Window pour un navigateur).
    
    Ex1:
    // On crée un tableau composé des racines carrées des éléments d'un premier tableau
    var nombres = [1, 4, 9];
    var racines = nombres.map(Math.sqrt);
    // racines vaut désormais [1, 2, 3]
    // nombres vaut toujours [1, 4, 9]

    Ex2:
    // Créer un tableau de nombres avec une fonction à un argument. 
    // Cet argument sera automatiquement remplacé par chaque élément du tableau au fur et à mesure que map parcourt le tableau
    var nombres = [1, 4, 9];
    var doubles = nombres.map(function(num) {
      return num * 2;
    });
    // doubles vaut désormais [2, 8, 18].
    // nombres vaut toujours [1, 4, 9]

    Ex3:
    // On utilise un tableau d'objets pour créer un autre tableau contenant de nouveaux objets dans un autre format 
    var tableauOrig = [{cle:1, valeur:10}, {cle:2, valeur:20}, {cle:3, valeur: 30}];
    var tableauFormaté = tableauOrig.map(obj => { 
      var rObj = {};
      rObj[obj.cle] = obj.valeur; 
      return rObj;
    });
    // tableauFormaté vaut maintenant [{1:10}, {2:20}, {3:30}], 
    // tableauOrig vaut toujours 
    // [{cle:1, valeur:10},
    //  {cle:2, valeur:20},
    //  {cle:3, valeur: 30}
    // ]

    Ex4:
    // Utiliser map de façon générique sur autre chose qu'un tableau
    // Sur une chaine de caractère
    var map = Array.prototype.map;
    var a = map.call('Hello World', function(x) { return x.charCodeAt(0); });
    // a vaut désormais [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
    
    Ex5:
    // Utiliser map de façon générique sur autre chose qu'un tableau
    // Sur un tableau d'objets collectés grâce à querySelectorAll
    var elems = document.querySelectorAll('select option:checked');
    var values = Array.prototype.map.call(elems, function(obj) {
      return obj.value;
    });

    Ex6:
    // On peut passer à map() simplement le nom de la fonction sans paramètres
    myArray = [1,2,3]
    add3 = function(val) {
      return val+2;
    }
    myArray.map(add3) // [3,4,5]
    // Equivaut à 
    myArray.map(function(valCouranteDuTableau) {
      return valCouranteDuTableau+2;
    })

ENTRIES()
// arr.entries()
1. La méthode entries() renvoie un nouvel objet de type Array Iterator qui contient le couple clef/valeur pour chaque éléments du tableau.

    Ex1:
    var array1 = ['a', 'b', 'c'];
    var iterator1 = array1.entries();
    console.log(iterator1.next().value);
    // expected output: Array [0, "a"]
    console.log(iterator1.next().value);
    // expected output: Array [1, "b"]

FROM()
// Array.from(arrayLike [, fonctionMap[, thisArg]])
1. La méthode Array.from() permet de créer une nouvelle instance d'Array (une copie superficielle) 
à partir d'un objet itérable ou semblable à un tableau.

    [arrayLike]
        Un objet semblable à un tableau ou bien un objet itérable dont on souhaite créer un tableau, instance d'Array.
    [fonctionMap] (Facultatif)
        Argument optionnel, une fonction à appliquer à chacun des éléments du tableau.
    [thisArg] (Facultatif)
        Argument optionnel. La valeur à utiliser pour this lors de l'exécution de la fonction fonctionMap.

    Valeur de retour :
        Une nouvelle instance de Array.

    Ex1:
    // créer une instance d'Array à partir de l'objet arguments qui est semblable à un tableau
    function f() {
      return Array.from(arguments);
    }
    f(1, 2, 3); 
    // [1, 2, 3]

    Ex2:
    // Ça fonctionne avec tous les objets itérables...
    // Set
    const s = new Set(["toto", "truc", "truc", "bidule"]);
    Array.from(s);   
    // ["toto", "truc", "bidule"]
    // Map
    const m = new Map([[1, 2], [2, 4], [4, 8]]);
    Array.from(m);                          
    // [[1, 2], [2, 4], [4, 8]]  
    const mapper = new Map([["1", "a"], ["2", "b"]]);
    Array.from(mapper.values());
    // ["a", "b"] 
    Array.from(mapper.keys());
    // ["1", "2"]
    // String
    Array.from("toto");                      
    // ["t", "o", "t", "o"]

SLICE()
// arr.slice()
// arr.slice(début)
// arr.slice(début, fin)
1. La méthode slice() renvoie un objet tableau, contenant une copie superficielle (shallow copy) d'une portion du tableau d'origine, 
la portion est définie par un indice de début et un indice de fin (EXCLUS). Le tableau original ne sera pas modifié.

    [début] (Facultatif)
        Indice (à partir de zéro) depuis lequel commencer l'extraction.
        S'il s'agit d'un indice négatif, début indique un décalage depuis la fin de la séquence. Par exemple, slice(-2) 
        extrait les avant-dernier et dernier éléments dans la séquence.
        Si début est absent, slice() commencera depuis 0. 
        Si début est supérieur à la taille du tableau, c'est un tableau vide qui sera renvoyé.
    [fin] (Facultatif)
        Indice (à partir de zéro) auquel arrêter l'extraction. slice() extrait jusqu'à cet indice, 
        mais pas l'élément situé en fin lui-même. slice(1,4) extrait du deuxième au quatrième élément (les éléments d'indices 1, 2 et 3).
        S'il s'agit d'un indice négatif, fin indique un décalage depuis la fin de la séquence. slice(2,-1) extrait du troisième à l'avant-dernier élément dans la séquence.
        Si fin n'est pas fourni, slice() extraira jusqu'à la fin de la séquence (arr.length). 
        Si fin est supérieur à la longueur de la séquence, slice() fera une extraction jusqu'à la fin de la séquence.

    Valeur de retour :
        Un nouveau tableau contenant les éléments extraits.

2. slice() ne modifie pas le tableau original, mais renvoie une nouvelle copie du tableau (shallow copy — copie superficielle) dont les éléments sont des copies des éléments extraits du tableau original. 
Les éléments du tableau original sont copiés dans le nouveau tableau de la manière suivante :
Pour les références à des objets (et non les objets eux-mêmes), slice() copie ces références dans le nouveau tableau. 
Tant l'original que le nouveau tableau font référence au même objet. Si un objet référencé est modifié, ces changements sont visibles tant pour le nouveau que pour l'ancien tableau.
Pour les chaines de caractères, les nombres et les booléens, slice() copie ces chaines de caractères, ces nombres et ces valeurs booléennes dans le nouveau tableau. 
Les modifications sur ces chaînes, nombres ou booléens dans l'un des tableaux n'affectent pas l'autre tableau 
(NB : lorsque l'on parle de chaine de caractères, de nombre ou de booléen ici, on parle exclusivement de leur type primitif, 
pas des objets String, Number ou Boolean — voir par exemple différences entre objet String et type primitif pour les chaines de caractères).
Si un nouvel élément est ajouté à l'un ou l'autre tableau, le second n'est pas affecté.

    Ex1:
    var fruits = ["Banane", "Orange", "Citron", "Pomme", "Mangue"];
    var agrumes = fruits.slice(1, 3);
    // fruits vaut --> ["Banane", "Orange", "Citron", "Pomme", "Mangue"]
    // agrumes vaut --> ["Orange", "Citron"]

    Ex2:
    var animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];
    console.log(animals.slice(2));
    // expected output: Array ["camel", "duck", "elephant"]
    console.log(animals.slice(2, 4));
    // expected output: Array ["camel", "duck"]
    console.log(animals.slice(1, 5));
    // expected output: Array ["bison", "camel", "duck", "elephant"]

    Ex3:
    var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
    var myBest = fruits.slice(-2); // Equivaut à fruits.slice(fruits.length-2) équivaut à fruits.slice(3)
    // Apple,Mango
    var myBest = fruits.slice(-4, -2); // Equivaut à fruits.slice(fruits.length-4, fruits.length-2) équivaut à fruits.slice(1, 3)
    // Orange,Lemon
    var myBest = fruits.slice(-4, 2);  // Equivaut à fruits.slice(fruits.length-4, 2) équivaut à fruits.slice(1, 2)
    // Orange

FILTER()
// var nouveauTableau = arr.filter(callback, thisArg);
// callback(elementCourant[, index[, tableauEntier]])
1. filter() appelle la fonction callback fournie pour chacun des éléments d'un tableau, et 
construit un nouveau tableau contenant tous les éléments pour lesquels l'appel de callback 
retourne true ou une valeur équivalente à true dans un contexte booléen. La fonction callback 
n'est utilisée que pour les éléments du tableau ayant une valeur assignée — les index supprimés 
ou pour lesquels il n'y a jamais eu de valeur ne sont pas pris en compte. Les éléments du tableau 
qui ne passent pas le test effectué par la fonction callback sont ignorés, ils ne sont pas 
inclus dans le nouveau tableau.
La liste des éléments parcourus par filter() est définie avant la première invocation de la fonction callback. 
Les éléments qui sont ajoutés à la liste après le début de l'appel de filter() (grâce à la fonction callback par exemple) 
ne seront pas concernés par le filtre. Si des éléments de la liste sont modifiés ou supprimés au cours du traitement, 
la valeur fournie à la fonction callback sera la valeur de ces éléments au moment où filter() les traite — 
les éléments supprimés ne seront pas traités par la fonction.

    [callback] 
        La fonction de test (ou prédicat) à appliquer à chaque élément du tableau. Cette fonction est appelée avec les arguments suivants :

        [elementCourant]
            L'élément à traiter

        [index] (Facultatif)
            Son indice
            
        [tableauEntier] (Facultatif)            
            Le tableau complet

        Valeur de retour :
            Cette fonction renvoie true — ou une valeur équivalente — si l'élément doit être conservé pour le tableau résultat et false dans le cas contraire.        

    [thisArg] (Facultatif)
        Objet à utiliser en tant que this quand la fonction callback est exécutée.

    Valeur de retour :
        Un nouveau tableau contenant les éléments qui respectent la condition du filtre. Si aucun élément ne respecte la condition, c'est un tableau vide qui est renvoyé.

    Ex1:
    // Filtrer les petites valeurs
    function suffisammentGrand(element) {
      return element >= 10;
    }
    var filtre = [12, 5, 8, 130, 44].filter(suffisammentGrand);
    // filtre vaut [12, 130, 44]

    Ex2:
    Filtrer des éléments JSON invalides en fonction d'un id
    var arr = [
      { id: 15 },
      { id: -1 },
      { id: 0 },
      { id: 3 },
      { id: 12.2 },
      { },
      { id: null },
      { id: NaN },
      { id: 'undefined' }
    ];
    var elementsInvalides = 0;

    function filtrerParID(obj) {
      // Si c'est un nombre
      if (obj.id !== undefined && typeof(obj.id) === 'number' && !isNaN(obj.id)) {
        return true;
      } else {
        elementsInvalides++;
        return false;
      }
    }
    var arrByID = arr.filter(filtrerParID);

    console.log('Tableau filtré\n', arrByID);
    // Le tableau filtré est :
    // [{ id: 15 }, { id: -1 }, { id: 0 }, { id: 3 }, { id: 12.2 }]
    console.log('Nombre d\'éléments invalides = ', elementsInvalides);
    // Nombre d'éléments invalides 4

INCLUDES()
// arr.includes(élémentRecherché)
// arr.includes(élémentRecherché, indiceDépart)
1. Permet de déterminer si un tableau contient une valeur et renvoie true si c'est le cas, false sinon.
includes() est une méhtode générique : l'objet sur lequel elle est appelée ne doit pas nécessairement être un tableau. 
On peut l'utiliser sur des objets semblables à des tableaux (ex. arguments ou des chaînes de caractères)

    [élémentRecherché] 
        La valeur qu'on souhaite trouver dans le tableau (lorsqu'on manipule des caractères et des chaînes, 
        la comparaison est sensible à la casse).

    [indiceDépart]  (Facultatif)
        La position du tableau à partir de laquelle commencer à chercher élémentRecherché. 
        Si on utilise une valeur négative, la recherche commencera à partir de la fin du tableau (autrement dit à l'indice array.length - indiceDépart). 
        La valeur par défaut est 0.
        SI indiceDépart est supérieur ou égal à la longueur du tableau, la méthode retourne false. Le tableau n'est pas parcouru.
        Si indiceDépart est strictement négatif, l'indice de départ effectif est la somme entre la taille du tableau et indiceDépart. 
        Si cette somme est toujours négative, le tableau est intégralement parcouru.

    Valeur de retour :
        Un booléen qui vaut true si élémentRecherché est trouvé dans le tableau (à partir de l'indiceDépart si celui-ci est indiqué). 
        Les valeurs -0, +0 et 0 sont considérées comme équivalentes mais false n'est pas considéré comme équivalent à 0.

    Ex1:
    [1, 2, 3].includes(2);     // true
    [1, 2, 3].includes(4);     // false
    [1, 2, 3].includes(3, 3);  // false
    [1, 2, 3].includes(3, -1); // true
    [1, 2, NaN].includes(NaN); // true
    ['a', 'b', 'c'].includes('c', 5);    // false
    ['a', 'b', 'c'].includes('c', -100); // true

    var array1 = [1, 2, 3];
    console.log(array1.includes(2));
    // expected output: true

    var pets = ['cat', 'dog', 'bat'];
    console.log(pets.includes('cat'));
    // expected output: true
    console.log(pets.includes('at'));
    // expected output: false

    // indiceDépart supérieur ou égal à la longueur du tableau
    var arr = ['a', 'b', 'c'];
    arr.includes('c', 3);   // false
    arr.includes('c', 100); // false

    // indiceDépart strictement négatif
    // Le tableau a une taille de 3
    // indiceDépart vaut -2
    // L'indice de départ effectif vaut is 3 + (-2) = 1
    var arr = ['a', 'b', 'c'];
    arr.includes('a', -2); // false
    arr.includes('b', -2); // true
    arr.includes('c', -100); // true

FIND()
// var premierElémentTrouvé = arr.find(callback, thisArg);
// callback(elementCourant[, index[, tableauEntier]])
1.La méthode find() renvoie la valeur du premier élément trouvé dans le tableau qui respecte la condition donnée 
par la fonction de test passée en argument. Sinon, la valeur undefined est renvoyée.
La méthode callback est seulement appelée pour les index du tableau pour lesquels on dispose d'une valeur. 
Elle n'est pas appelée pour les index supprimés ou pour ceux qui n'ont pas de valeur.

	[callback] 
        Fonction à exécuter sur chaque valeur du tableau. Cette fonction est appelée avec les arguments suivants :

        [elementCourant]
            L'élément actuellement traité dans le tableau.

        [index] (Facultatif)
            Son indice
            
        [tableauEntier] (Facultatif)            
            Le tableau pour lequel la méthode find a été appelée.   

    [thisArg] (Facultatif)
        Objet à utiliser en tant que this quand la fonction callback est exécutée.

    Valeur de retour :
        La valeur du premier élément du tableau qui réussit le test, 
        sinon undefined.

    Ex1:
    // Trouver un objet dans un tableau grâce à une de ses propriétés
    const inventaire = [
	  {nom: 'pommes', quantité: 2},
	  {nom: 'bananes', quantité: 0},
	  {nom: 'cerises', quantité: 5}
	];
	function estCerises(fruit) {
	  return fruit.nom === 'cerises';
	}
	console.log(inventaire.find(estCerises));
	// { nom: 'cerises', quantité: 5}

	// Avec une fonction fléchée
	const resultat = inventaire.find( fruit => fruit.nom === 'cerises');
	console.log(resultat);
	// { nom: 'cerises', quantité: 5}

    Ex2:
    // Trouver un nombre premier dans un tableau
	function estPremier(element, index, array) {
	    let début = 2;
	    while (début <= Math.sqrt(element)) {
	        if (element % début ++ < 1) return false;
	    }
	    return (element > 1);
	}

	console.log( [4, 6, 8, 12].find(estPremier) ); // undefined, rien trouvé
	console.log( [4, 5, 8, 12].find(estPremier) ); // 5


Méthodes sur les objets
-------------------------------
KEYS()
// Object.keys(obj)
1. La méthode Object.keys() renvoie un tableau contenant les noms des propriétés propres à un objet 
(qui ne sont pas héritées via la chaîne de prototypes) et qui sont énumérables. L'ordre de ce tableau est le même que celui obtenu par une boucle for...in 
(à la différence qu'une boucle for-in liste également les propriétés héritées).
Si on souhaite lister toutes les propriétés, y compris celles qui ne sont pas énumérables, on pourra utiliser Object.getOwnPropertyNames().

    [obj]
        L'objet dont on souhaite lister les propriétés propres et énumérables.
   
    Valeur de retour :
        Un tableau de chaînes de caractères qui sont les noms des propriétés énumérables de l'objet passé en argument.

    Ex1:
    const object1 = {
      a: 'somestring',
      b: 42,
      c: false
    };
    console.log(Object.keys(object1));
    // expected output: Array ["a", "b", "c"]

    Ex2:
    var arr = ["a", "b", "c"];
    console.log(Object.keys(arr));
    // affichera ['0', '1', '2']

    Ex3:
    // un objet semblable à un tableau
    var obj = { 0 : "a", 1 : "b", 2 : "c"};
    console.log(Object.keys(obj));
    // affichera ['0', '1', '2']

    Ex4:
    // un objet semblable à un tableau avec
    // un ordre de clé aléatoire
    var an_obj = { 100: "a", 2: "b", 7: "c"};
    console.log(Object.keys(an_obj));
    // affichera ['2', '7', '100'] Les clés se classent dans l'ordre croissant de la valeur des indices

ASSIGN()
// Object.assign(cible, ...sources)

    [cible]
        L'objet cible. Ce peut être un objet vide {}

    [sources]
        Le(s) objet(s) source(s).
   
    Valeur de retour :
        L'objet cible, éventuellement modifié, est renvoyé.

1. La méthode Object.assign permet de ne copier que les propriétés énumérables et propres 
(les propriétés qui ne sont pas héritées) depuis un objet source vers un objet cible. 
Elle utilise [[Get]] sur l'objet source et [[Set]] sur l'objet cible, ainsi, elle déclenchera 
les accesseurs/mutateurs. De cette façon, elle affecte les propriétés plutôt que de juste 
les copier ou d'en définir de nouvelles. Aussi, il est déconseillé d'utiliser cette méthode 
si on souhaite uniquement fusionner de nouvelles propriétés dans un prototype si un des 
objets sources contient des accesseurs. Pour uniquement copier les définitions des 
propriétés (y compris leur énumérabilité) dans des prototypes, on utilisera plutôt 
Object.getOwnPropertyDescriptor() et Object.defineProperty().

Les propriétés String et Symbol sont copiées. Les propriétés de l'objet cible sont 
surchargées par celles de l'objet source si elles ont la même clé.

En cas d'erreur, si une propriété n'est pas accessible en écriture par exemple, une 
exception TypeError sera levée mais l'objet cible aura été modifié avec les propriétés ajoutées avant l'erreur.

Object.assign ne donnera pas d'erreur si on fournit les valeurs null ou undefined pour la valeur source.

2. Cloner un objet
Attention, pour un clone réel (deep clone), il faudra utiliser d'autres méthodes car Object.assign() 
ne copie que les valeurs des propriétés depuis l'objet source, il ne recopie pas intégralement une nouvelle propriété. 
Si la valeur est une référence à un objet, il copiera uniquement la référence.
    
    Ex1:
    var obj = { a: 1 };
    var copie = Object.assign({}, obj);
    console.log(copie); // {a: 1}

3. Fusionner des objets

    Ex1:
    var o1 = { a: 1 };
    var o2 = { b: 2 };
    var o3 = { c: 3 };

    var obj = Object.assign(o1, o2, o3);
    console.log(obj); // { a: 1, b: 2, c: 3 }
    console.log(o1);  // { a: 1, b: 2, c: 3 }, l'objet cible est aussi modifié

4. Fusionner des objets partageant des propriétés

    Ex1:
    var o1 = { a: 1, b: 1, c: 1 };
    var o2 = { b: 2, c: 2 };
    var o3 = { c: 3 };

    var obj = Object.assign({}, o1, o2, o3);
    console.log(obj); // { a: 1, b: 2, c: 3 }
    // Les propriétés communes sont surchargées selon l'ordre des paramètres.

ENTRIES()
// Object.entries(obj)

    [obj]
        L'objet dont on souhaite connaître les propriétés propres énumérables 
        dont la clé est une chaîne de caractères, sous la forme de paires [clé, valeur].
   
    Valeur de retour :
        Un tableau qui contient les propriétés énumérables propres de l'objet 
        sous la forme de paires (tableau à deux éléments) [clé, valeur].

1. Object.entries() renvoie un tableau dont les éléments sont des paires (des tableaux à deux éléments)  [clé, valeur] qui correspondent aux propriétés énumérables qui sont directement présentes sur l'objet passé en argument (on ne parcours pas la chaîne des prototypes).
L'ordre du tableau renvoyé par cette méthode ne dépend pas de la façon dont l'objet est défini.
    EX:
    var obj = { toto: "truc", machin: 42 };
    console.log(Object.entries(obj)); // [ ['toto', 'truc'], ['machin', 42] ]

    // Un objet semblable à un tableau
    var obj = { 0: 'a', 1: 'b', 2: 'c' };
    console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]

    // Un objet semblable à un tableau
    // dont les clés sont aléatoirement ordonnées
    var un_obj = { 100: 'a', 2: 'b', 7: 'c' };
    console.log(Object.entries(un_obj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]

    // getToto est une propriété non énumérable
    var mon_obj = Object.create({}, { getToto: { value: function() { return this.toto; } } });
    mon_obj.toto = "truc";
    console.log(Object.entries(mon_obj)); // [ ['toto', 'truc'] ]

    // un argument de type primitif sera
    // converti en un objet
    console.log(Object.entries("toto")); // [ ['0', 't'], ['1', 'o'], ['2', 't'],  ['3', 'o'] ]

    // Un tableau vide pour les types primitifs qui n'ont pas de propriétés
    console.log(Object.entries(100)); // [ ]

    // parcourir les clés-valeurs
    var autreObjet = {a:5, b:7, c:9};

    for (var [cle, valeur] of Object.entries(autreObjet)){
      console.log(cle + ' ' + valeur);
    }

    // Ou encore, en utilisant les méthodes génériques
    Object.entries(autreObjet).forEach(([clé, valeur]) => {
      console.log(clé + ' ' + valeur);
    });

    EX:
    // Parcourir un objet
    // En utilisant la décomposition des tableaux, on peut simplement 
    // parcourir les différentes propriétés d'un objet.
    const obj = { toto: "truc", bidule: 42 };
    Object.entries(obj).forEach(
      ([clé, valeur]) => console.log(`${clé}: ${valeur}`)
    );
    // "toto: truc"
    // "bidule: 42"


Méthodes sur les fonctions
-------------------------------
Voir https://www.youtube.com/watch?v=c0mLRpw-9rI
Voir https://www.youtube.com/watch?v=AYVYxezrMWA

CALL()
//fun.call(thisArg, arg1, arg2, ...)
1. La méthode call() réalise un appel à une fonction avec une valeur this donnée et des arguments fournis individuellement.
Ce qui peut se traduire par : J'appelle ma fonction avec call et je remplace le this qui se trouve 
dans la fonction par l'objet que je passe en premier argument et j'utilise les arguments attendus 
passé par call dans les arguments passés en second et après.

    [thisArg]
        La valeur this fournie pour l'appel de la fonction fun.

    [arg1, arg2, ...]
        Les arguments pour la fonction.
       
    Valeur de retour :
        Le résultat de l'appel de la fonction invoquée avec la valeur this indiquée et les arguments fournis.

2. La méthode call() permet d'appeler une fonction rattachée à un objet donné sur un autre objet. Il est possible d'utiliser call pour chaîner le constructeur d'un objet.

    Ex1:
    /* 
    Dans l'exemple suivant, le constructeur de l'objet Product est défini avec deux paramètres, name et price. 
    Deux autres fonctions, Food et Toy invoquent Product en passant this, name et price. 
    Product initialise les propriétés name et price, tandis que les fonctions spécialisées définissent la propriété category.
    */

    function Product(name, price) {
      this.name = name;
      this.price = price;
    }

    function Food(name, price) {
      Product.call(this, name, price);
      this.category = 'food';
    }

    function Toy(name, price) {
      Product.call(this, name, price);
      this.category = 'toy';
    }

    var cheese = new Food('feta', 5);
    var fun = new Toy('robot', 40);


    Ex2:
    function Product(name, price) {
      this.name = name;
      this.price = price;
    }

    function Food(name, price) {
      Product.call(this, name, price);
      this.category = 'food';
    }

    console.log(new Food('cheese', 5).name);
    // expected output: "cheese"

3. Utiliser call() pour invoquer une fonction anonyme

    Ex1:
    /*
    Dans cet exemple (purement inventé), on crée une fonction anonyme et on utilise call pour 
    l'invoquer sur chaque objet d'un tableau. Le principal but de cette fonction anonyme est 
    d'ajouter une fonction print sur chaque élément qui permet d'afficher l'index de l'objet
    */

    var animaux = [
      {espece: 'Lion', nom: 'Roi'},
      {espece: 'Éléphant', nom: 'Dumbo'}
    ];

    for (var i = 0; i < animaux.length; i++) {
      (function (i) { 
        this.print = function () { 
          console.log('#' + i  + ' ' + this.espece + ' : ' + this.nom); 
        } 
        this.print();
      }).call(animaux[i], i);
      // Ce qui peut se traduire par : J'appelle ma fonction anonyme avec call et je remplace le this 
      // qui se trouve dans la fonction par l'objet que je passe en premier argument et j'utilise les arguments attendus
      // passé par call dans les arguments passés en second et après.
    }

4. Utiliser call() pour appeler une fonction avec un objet pour this

    Ex1:
    /*
    Dans l'exemple qui suit, on utilise la méthode call() 
    sur la fonction saluer() afin de l'appliquer à l'objet personne1
    */

    function saluer() {
      var reponse = [this.nom, "est un", this.role, "."].join(" ");
      console.log(reponse);
    }

    var personne1 = {
      nom: "Sénèque",
      role: "philosophe"
    };

    saluer.call(personne1); // Sénèque est un philosophe.

5. Utiliser call() pour appeler une fonction sans indiquer de premier argument

    Ex1:
    /*
    Dans l'exemple qui suit, on appelle la fonction afficher() sans lui passer d'argument. 
    C'est donc l'objet global qui est utilisé comme contexte
    */
    var prenom = 'Archibald';

    function afficher() {
      console.log('prenom vaut ' + this.prenom);
    }
    afficher.call(); // prenom est Archibald

    /*
    La valeur de this sera undefined en mode strict.
    */
    'use strict';

    var prenom = 'Archibald';

    function afficher() {
      console.log('prenom vaut ' + this.prenom);
    }
    afficher.call(); // Cannot read the property prenom' of undefined


APPLY()
//fun.apply(thisArg, argsArray)
1. La méthode apply() appelle une fonction en lui passant une valeur this et des arguments sous forme d'un tableau (ou d'un objet semblable à un tableau).
apply() est similaire à call(), hormis pour le type d'arguments supporté. Il est possible d'utiliser un tableau à la place d'un ensemble de paramètres. 
Avec apply(), il est également possible d'utiliser un littéral de tableau, par exemple, fun.apply(this, ['manger', 'bananes']), 
ou un objet Array, par exemple, fun.apply(this, new Array('manger', 'bananes')).

On peut aussi passer arguments en tant que paramètre argsArray. arguments étant une variable locale à la fonction. 
Celle-ci peut également être utilisée pour tous les arguments non spécifiés de l'objet appelé. 
Ainsi, il n'est pas nécessaire de connaître les arguments de l'objet appelé lors d'un appel à la méthode apply. 
arguments peut être utilisé pour passer tous les arguments à l'objet appelé. L'objet appelé gèrera alors la manipulation des arguments.

Depuis la cinquième édition d'ECMAScript, il est possible d'utiliser des objet semblables à des tableaux à la place. 
En pratique tout objet possédant une propriété length et une propriété entière comprise entre [0..length[ est un objet semblable à un tableau. 
On peut ainsi, par exemple, utiliser un objet NodeList ou un objet quelconque comme {'length': 2, '0': 'manger', '1': 'bananes'}.

    [thisArg]
        La valeur this fournie pour l'appel de la fonction fun.

    [argsArray]
        Un objet semblable à un tableau qui définit les arguments avec lesquel fun devrait être appelée, 
        ou null ou undefined si aucun argument n'est passé à la fonction. Avec ECMAScript 5, 
        ces arguments peuvent être représentés par un objet semblable un tableau. 
       
    Valeur de retour :
        Le résultat de l'appel de la fonction invoquée avec la valeur this indiquée et les arguments fournis.

2. Utiliser apply et des fonctions natives.
Quand on utilise undefined ou null comme premier argument pour cette fonction, on peut obtenir un résultat similaire à la syntaxe de décomposition.

    Ex1:
    function sum(x, y, z) {
      return x + y + z;
    }

    const numbers = [1, 2, 3];

    console.log(sum.apply(null, numbers));
    // expected output: 6

    console.log(sum(...numbers));
    // expected output: 6


    Ex2:
    var numbers = [5, 6, 2, 3, 7];

    var max = Math.max.apply(null, numbers);

    console.log(max);
    // expected output: 7

    var min = Math.min.apply(null, numbers);

    console.log(min);
    // expected output: 2


BIND()
//fun.bind(thisArg, arg1, arg2, ...)
1. La fonction bind() crée une nouvelle fonction qui, lorsqu'elle est appelée, 
a pour contexte this la valeur passée en paramètre et éventuellement une suite d'arguments 
qui précéderont ceux fournis à l'appel de la fonction créée.
Ce qui peut se traduire par : Je crée une nouvelle fonction avec bind et je remplace le this qui se trouve 
dans la fonction par l'objet que je passe en premier argument et je précède les arguments attendus par ma fonction
par les arguments passés en second et après dans bind. 

    [thisArg]
        La valeur que l'on doit passer au paramètre this de la fonction cible quand la fonction est appelée. 
        La valeur est ignorée si la fonction liée est construite en utilisant l'opérateur new.

    [arg1, arg2, ...]
        Les arguments qui doivent précéder les arguments fournis lors de l'appel à la fonction liée lors 
        de l'appel à la fonction cible.
       
    Valeur de retour :
        Une copie de la fonction fournie avec la valeur this indiquée et les arguments initiaux fournis.

2. Créer une fonction liée

    Ex1:
    this.x = 9; // en dehors de tout contexte,
                // pour un navigateur, this est
                // l'objet window
    var module = {
      x: 81,
      getX: function() { return this.x; }
    };

    module.getX(); // 81

    var getX = module.getX;
    getX(); // 9, car ici, this fait référence à l'objet global

    // On crée une nouvelle fonction à laquelle on lie module en
    // tant que 'this'
    var boundGetX = getX.bind(module);
    boundGetX(); // 81


    Ex2:
    var module = {
      x: 42,
      getX: function() {
        return this.x;
      }
    }

    var unboundGetX = module.getX;
    console.log(unboundGetX()); // The function gets invoked at the global scope
    // expected output: undefined

    var boundGetX = unboundGetX.bind(module);
    console.log(boundGetX());
    // expected output: 42

3. Utiliser bind() afin de créer une fonction avec des arguments initiaux prédéfinis.

    Ex1:
    /*
    Dans l'exemple suivant, on utilise bind() afin de créer une fonction avec des arguments initiaux prédéfinis.
    Ces arguments, s'il y en a, suivent le this fourni et sont ensuite insérés au début des arguments passés 
    à la fonction cible, suivis par les arguments passés à la fonction liée au moment où celle-ci est appelée.
    */

    function list() {
      // Retourne un tableau à partir du tableau arguments des paramètres que l'on passe à la fonction list
      return Array.prototype.slice.call(arguments); 
    }

    var list1 = list(1, 2, 3); // [1, 2, 3]

    // Créer une fonction avec un argument prédéfini (ici 37)
    var leadingThirtysevenList = list.bind(null, 37); 

    var list2 = leadingThirtysevenList(); // [37]
    var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]


    function sommeArguments(arg1, arg2){
      return arg1 + arg2;
    }

    var ajouter37 = sommeArguments.bind(null, 37);

    var resultat = ajouter37(5); // 37 + 5 = 42


Méthodes sur les chaînes de caratères
-------------------------------
INCLUDES()
// str.includes(chaîneRecherchée);
// str.includes(chaîneRecherchée, position);
1. La méthode includes() détermine si une chaîne de caractères est contenue dans une 
autre et renvoie true ou false selon le cas de figure. includes() est sensible à la casse.

    [chaîneRecherchée]
        Une chaîne à rechercher dans la chaîne courante.

    [position] (Facultatif)
        La position dans la chaîne à partir de laquelle commencera la recherche. La valeur par défaut de position est 0.
       
    Valeur de retour :
        true si la chaîne de caractères contient la sous-chaîne recherchée, false sinon.


    Ex1:
    // includes() est sensible à la casse
    'Baleine bleue'.includes('baleine'); // false

    Ex2:
    const str = "Être ou ne pas être, telle est la question.";
    console.log(str.includes("Être"));       // true
    console.log(str.includes("question"));   // true
    console.log(str.includes("pléonasme"));  // false
    console.log(str.includes("Être", 1));    // false
    console.log(str.includes("ÊTRE"));       // false
    console.log(str.includes(""));           // true

STARTSWITH()
// str.startsWith(chaîneRecherchée);
// str.startsWith(chaîneRecherchée, position);
1. La méthode startsWith() renvoie un booléen indiquant si la chaine de caractères 
commence par la chaine de caractères fournie en argument.

2. Cette méthode permet de savoir si une chaine de caractères commence avec une autre chaine de caractères 
(comme pour les autres méthodes fonctionnant avec les chaînes de caractères, cette méthode est sensible à la casse).

    [chaîneRecherchée]
        Les caractères à rechercher au début de la chaine de caractères.

    [position] (Facultatif)
        La position dans la chaîne à partir de laquelle commencera la recherche. La valeur par défaut de position est 0.
       
    Valeur de retour :
        true si la chaîne de caractères commence avec la sous-chaîne en argument, false sinon.

    Ex1:
    const str1 = 'Saturday night plans';

    console.log(str1.startsWith('Sat'));
    // expected output: true

    console.log(str1.startsWith('Sat', 3));
    // expected output: false

    Ex2:
    var str = "Être, ou ne pas être : telle est la question.";

    console.log(str.startsWith("Être"));         // true
    console.log(str.startsWith("pas être"));     // false
    console.log(str.startsWith("pas être", 12)); // true

SPLIT()
// str.split([séparateur[, qtéMax]])
1. La méthode split() permet de diviser une chaîne de caractères à partir 
d'un séparateur pour fournir un tableau de sous-chaînes.

2. Lorsqu'il est trouvé, le séparateur est supprimé de la chaîne et les 
sous-chaînes sont retournées dans un tableau. Si le séparateur est omis, 
le tableau contiendra un élément correspondant à la chaîne courante. 
Si le séparateur est une chaîne vide, la chaîne courante est convertie en 
un tableau composé des caractères de la chaîne. Si le séparateur est 
uniquement présent au début et/ou à la fin de la chaîne, le tableau 
contiendra une chaîne vide comme premier et/ou dernier élément (si on 
utilise cette méthode sur une chaîne qui ne contient que le séparateur, 
le tableau obtenu aura deux éléments qui seront chacun une chaîne vide).

Si le séparateur est une expression rationnelle qui contient des parenthèses 
groupantes, à chaque fois que le séparateur correspond, les résultats 
(incluant tout résultat indéfini) des groupes iront dans le tableau retourné. 
Cependant, tous les navigateurs ne supportent pas cette possibilité.

La méthode split() ne modifie pas le tableau courant, elle renvoie un nouveau tableau.

Lorsque le séparateur fourni est un tableau, le tableau est automatiquement
 converti en une chaîne de caractères et c'est cette chaîne qui est utilisée comme séparateur.

3. Quand la chaîne est vide, split() retourne un tableau contenant une chaîne vide, 
plutôt qu'un tableau vide. Si la chaîne et le séparateur sont tous les deux des chaînes vides, 
un tableau vide sera renvoyé.

    [séparateur] (Facultatif)
        Paramètre optionnel qui définit le ou les caractères à utiliser
        pour scinder la chaîne. Le séparateur est considéré comme une
        chaîne ou une expression rationnelle. Si le séparateur est omis
        ou qu'il n'apparaît pas dans la chaîne, le tableau retourné contiendra
        un unique élément contenant la chaîne entière. Si le séparateur est 
        une chaîne vide, la chaîne str sera convertie en un tableau dont 
        les éléments seront les caractères de la chaîne. Si le séparateur 
        contient un ou plusieurs caractères, la chaîne de caractères 
        entière doit être trouvée pour effectuer une césure.

    [qtéMax] (Facultatif)
        Paramètre optionnel. Un entier définissant la limite sur le nombre 
        de sous-chaînes à retourner. La méthode split scindera toujours 
        la chaîne à partir du séparateur, mais le tableau retourné 
        contiendra au plus qtéMax sous-chaînes.
       
    Valeur de retour :
        Un tableau (Array) qui contient les fragments de la chaîne appelante, 
        découpée en fonction du séparateur indiqué.

    /////////////////////////// EX:
    const str = 'The quick brown fox jumps over the lazy dog.';

    const words = str.split(' ');
    console.log(words[3]);
    // expected output: "fox"

    const chars = str.split('');
    console.log(chars[8]);
    // expected output: "k"

    const strCopy = str.split();
    console.log(strCopy);
    // expected output: Array ["The quick brown fox jumps over the lazy dog."]

    /////////////////////////// EX:
    function splitString(stringToSplit, separator) {
      var arrayOfStrings = stringToSplit.split(separator);

      console.log('La chaine d\'origine est : "' + stringToSplit + '"');
      console.log('Le délimiteur est : "' + separator + '"');
      console.log("Le tableau comporte " + arrayOfStrings.length + " elements : ");

      for (var i=0; i < arrayOfStrings.length; i++)
        print(arrayOfStrings[i] + " / ");
    }

    var tempestString = "Oh brave new world that has such people in it.";
    var monthString = "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec";

    var espace = " ";
    var virgule = ",";

    splitString(tempestString, espace);
    splitString(tempestString);
    splitString(monthString, virgule);

    // Sortie console
    La chaine d'origine est : "Oh brave new world that has such people in it."
    Le délimiteur est : " "
    Le tableau comporte 10 elements : Oh / brave / new / world / that / has / such / people / in / it. /

    La chaine d'origine est : "Oh brave new world that has such people in it."
    Le délimiteur est : "undefined"
    Le tableau comporte 1 elements : Oh brave new world that has such people in it. /

    La chaine d'origine est : "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec"
    Le délimiteur est : ","
    Le tableau comporte 12 elements : Jan / Feb / Mar / Apr / May / Jun / Jul / Aug / Sep / Oct / Nov / Dec /

    /////////////////////////// EX:
    // Supprimer les espaces d'une chaîne
    // Dans l'exemple suivant, split recherche zéro ou plusieurs espaces suivis d'un point-virgule, 
    // lui-même suivi par zéro ou plus espaces. Lorsque ce « motif » est trouvé, 
    // cela supprime celui-ci de la chaîne. nameList est le tableau retourné du résultat de split.

    var names = "Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ;Chris Hand ";

    console.log(names);

    var re = /\s*(;|$)\s*/;
    var nameList = names.split(re);

    console.log(nameList);

    // Sortie console
    Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ;Chris Hand
    ["Harry Trump","Fred Barney","Helen Rigby","Bill Abel","Chris Hand"]


    /////////////////////////// EX:
    // Retourner un nombre limité de sous-chaînes

    var myString = "Hello World. How are you doing?";
    var splits = myString.split(" ", 3);

    console.log(splits);

    // ["Hello", "World.", "How"]

    /////////////////////////// EX:
    // Si le paramètre séparateur est une regex qui contient des parenthèses de capture, 
    // les résultats seront retournés dans le tableau.

    var myString = "Hello 1 word. Sentence number 2.";
    var splits = myString.split(/(\d)/); /* Ce motif correspond à un chiffre et est équivalent à [0-9] */

    console.log(splits);

    // ["Hello ", "1", " word. Sentence number ", "2", "."]

    /////////////////////////// EX:
    // Découper une chaîne avec un tableau comme séparateur

    var maChaine = "Ceci|est|un|test";
    var morceaux = maChaine.split(['|']);

    console.log(morceaux); // ["Ceci", "est", "un", "test"]

    var maChaine2 = "ca,bc,a,bca,bca,bc";
    var morceaux2 = maChaine2.split(["a", "b"]);

    console.log(morceaux2); // ["c", "c,", "c", "c", "c"]

    /////////////////////////// EX:
    // Inverser une chaîne en utilisant split()

    var str = 'asdfghjkl';
    var strReverse = str.split('').reverse().join(''); // 'lkjhgfdsa'
    // split renvoie un tableau sur lequel on peut appliquer reverse
    // enfin on utilise join pour assembler le tout.

Méthodes sur JSON
-------------------------------
PARSE()
// JSON.parse(texte[, reviver])
1. La méthode JSON.parse() analyse une chaîne de caractères JSON et construit la valeur JavaScript ou l'objet décrit par cette chaîne. 
On peut éventuellement utiliser cette fonction avec un paramètre de modification permettant de traiter l'objet avant qu'il soit renvoyé.

    [texte]
        La chaine de caractère à analyser comme du JSON.

    [reviver] (Facultatif)
        Si l'argument est une fonction, effectue une opération de transformation sur la valeur analysée avant de la renvoyer.
       
    Valeur de retour :
        Un objet (Object) correspondant au texte envoyé.

    Exceptions:
        Lève une exception SyntaxError si la chaine de caractère à analyser ne contient pas du JSON valide.

    EX:
    var json = '{"result":true, "count":42}';
    obj = JSON.parse(json);
    console.log(obj);
    // expected output: {result: true, count: 42}

    EX:
    try {
      JSON.parse('{}');              // {}
      JSON.parse('true');            // true
      JSON.parse('"toto"');          // "toto"
      JSON.parse('[1, 5, "false"]'); // [1, 5, "false"]
      JSON.parse('null');            // null
    } catch (e) {
      console.error("Parsing error:", e); 
    }

2. Si un reviver est spécifié, la valeur obtenue par l'analyse est transformée avant d'être renvoyée. 
Plus précisément, la valeur calculée, et toutes les propriétés (commençant avec les propriétés les plus imbriquées), 
sont passées individuellement au reviver, qui est appelé avec : l'objet contenant la propriété en cours de traitement, 
le nom de la propriété en chaine de caractères et la valeur de la propriété. Si la fonction reviver retourne undefined 
(ou ne retourne aucune valeur, par exemple si l'exécution s'arrête à la fin de la fonction), la propriété est supprimée de l'objet. 
Autrement la propriété est redéfinie avec la valeur retournée.
Si le reviver ne transforme que certaines valeurs et pas d'autres, assurez-vous que les valeurs inchangées soient renvoyées telles quelles. 
En effet, si elles ne sont pas renvoyées, elles seront supprimés sur l'objet obtenu !

    EX:
    JSON.parse(
        '{"p": 5, "d": 10, "b": "v" "c": {"z": 5}}', 
        (key, value) => {
            if (typeof value === 'number') {
                return value * 2;  // renvoie value * 2 pour les nombres
            }
            return value;        // pour le reste, la valeur est inchangée
        }
    )
    

    // {p: 10, d: 20, b: "v", c: {…}}

STRINGIFY()
// JSON.stringify( valeur[, remplaçant [, espace]])
1. La méthode JSON.stringify() convertit une valeur JavaScript en chaîne JSON. Optionnellement, 
elle peut remplacer des valeurs ou spécifier les propriétés à inclure si un tableau de propriétés a été fourni.

    [valeur]
        La valeur à convertir en chaîne JSON.

    [remplaçant] (Facultatif)
        Une fonction qui modifie le processus de transformation ou un tableau de chaînes de caractères 
        et de nombres qui sont utilisés comme liste blanche pour sélectionner/filtrer les propriétés 
        de l'objet à inclure dans la chaîne JSON. Si cette valeur est null ou n'est pas fournie, 
        toutes les propriétés de l'objet seront inclues dans la chaîne résultante.

    [espace] (Facultatif)
        Un objet String ou Number qui est utilisé pour insérer des blancs dans la chaîne JSON produite afin de faciliter la lisibilité.
            - Si cet argument est un nombre, il indiquera le nombre d'espaces à utiliser pour l'indentation (la valeur est ramenée à 10 si elle dépasse 10).
            - Si l'argument est une chaîne, les 10 premiers caractères (ou la chaîne si elle est plus courte) seront utilisés pour les blancs.
            - Si le paramètre n'est pas fourni (ou s'il est null), aucun blanc ne sera utilisé.
       
    Valeur de retour :
        Une chaîne de caractères JSON qui représente la valeur indiquée.

    Exceptions:
        - Cette méthode lève une exception TypeError (« cyclic object value ») lorsqu'elle trouve une référence circulaire.
        - Cette méthode lève une exception TypeError (« BigInt value can't be serialized in JSON ») lorsqu'on 
        tente de convertir une valeur BigInt en une chaîne de caractères JSON.

    EX:
    console.log(JSON.stringify({ x: 5, y: 6 }));
    // expected output: "{"x":5,"y":6}"

    console.log(JSON.stringify([new Number(3), new String('false'), new Boolean(false)]));
    // expected output: "[3,"false",false]"

    console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol('')] }));
    // expected output: "{"x":[10,null,null,null]}"

    console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
    // expected output: ""2006-01-02T15:04:05.000Z""

2. voir https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/JSON/stringify pour plus de détails


Rest parameters
-------------------------------
1. Cette syntaxe permet de représenter un nombre indéfini d'arguments sous forme d'un tableau.
    Ex1:
    // ES6
    function sum(...theArgs) {
      return theArgs.reduce((previous, current) => {
        return previous + current;
      });
    }
    console.log(sum(1, 2, 3));
    // expected output: 6
    console.log(sum(1, 2, 3, 4));
    // expected output: 10

    Ex2:
    // S'il n'y a qu'un seul argument qui est décomposé par la syntaxe, la valeur sera toujours un tableau
    function maFonction(a, b, ...autres);
      console.log(a);
      console.log(b);
      console.log(autres);
    }
    maFonction("un", "deux", "trois");
    // affichera ceci dans la console
    // "un"
    // "deux"
    // ["trois"]
    maFonction("un", "deux", "trois", "quatre", "cinq");
    // affichera ceci dans la console :
    // "un"
    // "deux"
    // ["trois", "quatre", "cinq"]

    Ex3:
    // S'il n'y a pas suffisamment d'arguments, ce sera un tableau vide
    function maFonction(a, b, ...autres);
      console.log(a);
      console.log(b);
      console.log(autres);
    }
    maFonction("un", "deux");
    // affichera ceci dans la console
    // "un"
    // "deux"
    // []

    Ex4:
    // lesArguments est un tableau et dispose donc d'une propriété length permettant de compter ses éléments
    function fun1(...lesArguments) {
      console.log(lesArguments.length);
    }
    fun1();  // 0
    fun1(5); // 1
    fun1(5, 6, 7); // 3

  
Spread operator (opérateur de décomposition)
-------------------------------
1. Il permet de développer un objet itérable (comme un Array) en plusieurs arguments (pour les appels de fonctions) 
ou en plusieurs éléments (pour les littéraux de tableaux) ou en paires clés-valeurs (pour les littéraux d'objets)

    Ex1:
    // Dans les appels de fonction
    f(...objetIterable);
    // Pour les littéraux de tableaux
    [...objetIterable, 4, 5, 6]
    // Pour les littéraux objets
    let objClone = { ...obj };

    Ex2:
    // Utiliser la décomposition dans les appels de fonction
    const myArray = [1991, 8, 1]
    new Date(...myArray) // object Date - équivaut à: new Date(1991, 8, 1)
    // spread peut être mélangé aux autres arguments d'une fonction
    const myArray = [8, 1];
    new Date(1991, ...myArray, 12); 
    // object Date - équivaut à: new Date(1991, 8, 1, 12)
    
    Ex3:
    // Les objets String étant itérables
    const myString = "foo bar"    
    [...myString] // ["f", "o", "o", " ", "b", "a", "r"]

    Ex4:
    // Éviter l'utilisation de .apply()
    // ES5
    console.log.apply(console, ["foo", "bar"]);
    // ES6
    console.log(...["foo", "bar"]); // même résultat

    Ex5:
    // Concaténer plusieurs itérables
    const stronglyTyped = ["scala", "haskell"]
    // ES5
    ["go", "rust"].concat(stronglyTyped) 
    // ["go", "rust", "scala", "haskell"]
    // ES6 / ES2015
    ["go", "rust", ...stronglyTyped] 
    // ["go", "rust", "scala", "haskell"]
    var articulations = ['épaules', 'genoux'];
    var corps = ['têtes', ...articulations, 'bras', 'pieds'];
    // ["têtes", "épaules", "genoux", "bras", "pieds"]
    var arr1 = [4, 5, 6];
    var arr2 = [1, 2, 3];
    arr1 = [...arr2, ...arr1];
    // arr1 vaut désormais [1, 2, 3, 4, 5, 6]

    Ex6:
    // Copier un tableau (seulement au premier niveau de profondeur)
    var arr = [1, 2, 3];
    var arr2 = [...arr];
    arr2.push(4);
    console.log(arr2); // [1, 2, 3, 4]
    console.log(arr);  // [1, 2, 3] (inchangé)

    Ex7:
    // Clonage superficiel d'objet   
    const cat = { age: 4 };
    const kitten = { ...cat }; // Nouvel objet créé
    kitten.age = 1;
    console.log(kitten.age); // 1
    console.log(cat.age); // 4
    // Superficiel car les valeurs des propriétés de l'objet cloné pointent vers les mêmes références que l'objet copié et ne sont pas de nouvelles instances) 
    const cat = { age: 4, toys: ["mouse", "catnip"] };
    const kitten = { ...cat };
    kitten.toys[1] = "yarn";
    console.log(kitten.toys); // ["mouse", "yarn"]
    console.log(cat.toys); // ["mouse", "yarn"] <-- problem!

2. Il permet de mettre une ou plusieurs valeurs de propriété d'un objet. 
Les propriétés sont ajoutées dans l'ordre. Par conséquent, si vous souhaitez remplacer des propriétés existantes, 
vous devez les placer à la fin et non au début

  Ex1:
  const obj1 = {
    a: "original a",
    b: "original b"
  }
  // Doesn't work
  const obj2 = {
    a: "updated a",
    ...obj1
  }
  console.log(obj2); // Affiche Object {a: "original a", b: "original b"}
  // Works
  const obj3 = {
    ...obj1, 
    a: "updated a"
  }
  console.log(obj3); // Affiche Object {a: "updated a", b: "original b"}


Le protocole « itérable » (Objets itérables)
-------------------------------
1. Le protocole « itérable » permet aux objets JavaScript de définir ou de personnaliser leur comportement lors d'une itération, 
par exemple la façon dont les valeurs seront parcourues avec une boucle for..of. 
Certains types natifs tels que Array ou Map possèdent un comportement itératif par défaut, d'autres types, 
comme Object n'ont pas ce type de comportement.

    Ex1:
    // Certains types natifs possèdent un comportement par défaut pour l'itération, d'autres types (tels qu'Object) n'ont pas de tel comportement. Les types natifs qui disposent d'une méthode @@iterator sont :
    Array.prototype[@@iterator]()
    TypedArray.prototype[@@iterator]()
    String.prototype[@@iterator]()
    Map.prototype[@@iterator]()
    Set.prototype[@@iterator]()

    Ex2:
    // Les API natives utilisant des itérables
    Map([itérable])
    WeakMap([itérable])
    Set([itérable])
    WeakSet([itérable])
    Promise.all(itérable)
    Promise.race(itérable)
    Array.from()

    var monObjet = {};
    new Map([[1,"a"],[2,"b"],[3,"c"]]).get(2); // "b"
    new WeakMap([[{},"a"],[monObjet,"b"],[{},"c"]]).get(monObjet); // "b"
    new Set([1, 2, 3]).has(3); // true
    new Set("123").has("2"); // true
    new WeakSet(function*() {
        yield {};
        yield monObjet;
        yield {};
    }()).has(monObjet);  // true

    Ex3:
    // Les éléments de syntaxe utilisant des itérables
    for..of
    la syntaxe de décomposition (opérateur spread)
    yield*
    l'affectation par décomposition

    for(let value of ["a", "b", "c"]){
      console.log(value);
    }
    // "a"
    // "b"
    // "c"
    [..."abc"]; // ["a", "b", "c"]
    function* gen(){
      yield* ["a", "b", "c"];
    }
    gen().next(); // { value:"a", done:false }
    [a, b, c] = new Set(["a", "b", "c"]);
    a; // "a"

2. Afin d'être itérable, un objet doit implémenter la méthode @@iterator, cela signifie que l'objet (ou un des objets de sa chaîne de prototypes) 
doit avoir une propriété avec une clé @@iterator qui est accessible via Symbol.iterator. 
Lorsqu'on doit itérer sur un objet (ex. : au début d'une boucle for..of), sa méthode @@iterator est appelée sans argument et l'itérateur 
qui est renvoyé est utilisé afin d'obtenir les valeurs sur lesquelles itérer.

    Ex1:
    // Itérables définis par l'utilisateur
    const iterable1 = new Object();
    iterable1[Symbol.iterator] = function* () {
      yield 1;
      yield 2;
      yield 3;
    };
    console.log([...iterable1]);
    // expected output: Array [1, 2, 3]

    // Dans des déclarations de classe ou dans des littéraux objets
    class Toto {
      *[Symbol.iterator] () {
        yield 1;
        yield 2;
        yield 3;
      }
    }
    const monObj = {
      *[Symbol.iterator] () {
        yield "a";
        yield "b";
      }
    }
    [... new Toto] // [1, 2, 3]
    [... monObj]   // ["a", "b"]

3. Si une méthode @@iterator d'un objet itérable ne renvoie pas d'objet itérateur,
on dira que cet objet est un itérable mal-formé. Utiliser de tels itérables peut provoquer 
des exceptions lors de l'exécution ou un comportement erratique
    Ex1:
    // Itérables mal-formés
    var itérableMalForme = {}
    iterableMalForme[Symbol.iterator] = () => 1
    [...iterableMalForme] // TypeError: [] is not a function


Le protocole « itérateur »
-------------------------------
1.Le protocole « itérateur » définit une façon standard pour produire une suite de valeurs (finie ou infinie) 
ainsi qu'une valeur de retour lorsque toutes les valeurs ont été générées.
Un objet est considéré comme un itérateur lorsqu'il implémente une méthode next() avec la sémantique suivante:
Une fonction sans argument qui doit toujours renvoyer un objet contenant les propriétés done et value. 
Si c'est une valeur primitive qui est renvoyée (ex. false ou undefined), une exception TypeError sera levée ("iterator.next() returned a non-object value").
  [done] (un booléen)
      Qui vaut true lorsque l'itérateur a fini la suite. Dans ce cas, la propriété value sera facultative et permettra de spécifier la valeur de retour de l'itérateur. Les valeurs de retour sont détaillées ici.
      Qui vaut false lorsque l'itérateur a pu produire la prochaine valeur de la suite. Si on ne définit pas la propriété done, on aura ce comportement par défaut.
  [value]
      N'importe quelle valeur JavaScript, renvoyée par l'itérateur. Cette propriété peut être absente lorsque done vaut true.

    Ex1:
    // L'itérateur par défaut d'un objet String renverra les caractères de la chaîne les uns à la suite des autres
    var uneChaine = "coucou";
    typeof uneChaine[Symbol.iterator]; // "function"
    var iterateur = uneChaine[Symbol.iterator](); // On récupère l'objet itérateur de l'objet String
    iterateur + "";     // "[object String Iterator]"
    iterateur.next();  // { value: "c", done: false }
    iterateur.next();  // { value: "o", done: false }
    iterateur.next();  // { value: "u", done: false }
    iterateur.next();  // { value: "c", done: false }
    iterateur.next();  // { value: "o", done: false }
    iterateur.next();  // { value: "u", done: false }
    iterateur.next();  // { value: undefined, done: true }

    Ex2:
    // Redéfinir le comportement par défaut de l'itérateur en définissant soi-même le symbole @@iterator
    var uneChaine = new String("yo"); // on construit un objet String explicitement afin d'éviter la conversion automatique
    uneChaine[Symbol.iterator] = function() {
      return { // l'objet itérateur qui renvoie un seul élément, la chaîne "bop"
        next: function() {
          if (this._first) {
            this._first = false;
            return { value: "bop", done: false };
          } else {
            return { done: true };
          }
        },
        _first: true
      };
    };
    [...uneChaîne];  // ["bop"]
    uneChaîne + "";  // "yo"

    Ex3:
    // Un itérateur simple
    function creerIterateur(tableau){
        var nextIndex = 0;
        
        return {
          next: function(){
              return nextIndex < tableau.length ?
                  {value: tableau[nextIndex++], done: false} :
                  {done: true};
          }
        }
    }
    var it = creerIterateur(['yo', 'ya']);
    console.log(it.next().value); // 'yo'
    console.log(it.next().value); // 'ya'
    console.log(it.next().done);  // true

    Ex4:
    // Un itérateur infini
    function créateurID(){
        var index = 0;
        
        return {
          next: function(){
              return {value: index++, done: false};
          }
        };
    }
    var it = créateurID();
    console.log(it.next().value); // '0'
    console.log(it.next().value); // '1'
    console.log(it.next().value); // '2'
    // ...

    Ex5:
    // Avec un générateur
    function* creerUnGenerateurSimple(tableau){
        var nextIndex = 0;
        
        while(nextIndex < tableau.length){
            yield tableau[nextIndex++];
        }
    }
    var gen = creerUnGenerateurSimple(['yo', 'ya']);
    console.log(gen.next().value); // 'yo'
    console.log(gen.next().value); // 'ya'
    console.log(gen.next().done);  // true

    Ex6:
    // Avec une classe (ES6)
    class ClasseSimple {
      constructor(data) {
        this.index = 0;
        this.data = data;
      }
      [Symbol.iterator]() {
        return {
          next: () => {
            if (this.index < this.data.length) {
              return {value: this.data[this.index++], done: false};
            } else {
              this.index = 0; 
              // En réinitialisant l'index, on peut 
              // "reprendre" l'itérateure sans avoir
              // à gérer de mise à jour manuelle
              return {done: true};
            }
          }
        };
      }
    }
    const simple = new ClasseSimple([1,2,3,4,5]);
    for (const val of simple) {
      console.log(val);  // '1' '2' '3' '4' '5' 
    }


Les générateurs function*
-------------------------------
1. La déclaration function* (le mot-clé function suivi par un astérisque) permet de définir un générateur
(aussi appelé une fonction génératrice).
Les générateurs sont des fonctions qu'il est possible de quitter puis de reprendre. 
Le contexte d'un générateur (les liaisons avec ses variables) est sauvegardé entre les reprises successives.

2. Un générateur retourne un itérateur. Lorsqu'il est appelé, il ne va pas s'exécuter. À la place, il va retourner un objet spécial appelé itérateur.
L'itérateur posséde une fonction next (iterator.next), qui va exécuter le générateur jusqu'au premier yield.
next retourne un objet contenant deux clefs : 
value: indiquant la valeur retournée par yield.
done: un booléen indiquant si le générateur est arrivé à la fin de son éxécution.
Un générateur se termine toujours par la valeur retournée par return (done vaudra true), ou undefined si aucun return n'est spécifié.
Une fois qu'un générateur est terminé, il ne peut plus produire d'autres valeurs.

3. Nous avons donc une fonction capable de produire des valeurs sur demande. 
Mais, les générateurs, ne s'arrêtent pas là. En plus de donner des valeurs, ils peuvent en recevoir.
Un indice yield fonctionne dans les deux sens et next accepte un paramètre.
La ligne i += yield i; se lit de droite à gauche. D'abord, i est retourné. 
Le générateur attend alors que next soit appelé. Puis il reçoit la valeur passée à next et résume son exécution, en l'additionnant à i.
La valeur passée au premier next, est toujours ignorée, c'est la valeur passée en argument au générateur qui est prise en compte.

4. À l'instar d'une instruction return, une exception levée à l'intérieur du générateur entraînera la terminaison du 
générateur sauf si cette exception est interceptée. Lorsqu'un générateur est terminé, les appels suivants à next() n'exécuteront 
aucun code provenant du générateur, ils renverront simplement un objet de la forme {value: undefined, done: true}.

5. Lorsqu'on appelle la méthode next() avec un argument, cela remplacera 
la valeur de l'expression yield précédente avec la valeur de l'argument passé à next().
Si aucun argument n'est pas à next() l'expression yield précédente est remplacée par undefined.  
Une valeur passée au premier appel de next() sera toujours ignorée.

6. Une expression yield* est utilisée afin de déléguer 
le mécanisme d'itération/génération à un autre générateur 
ou à un autre objet itérable. yield* est une expression et non 
une instruction, elle est donc évaluée et fournit une valeur.
yield* peut également être utilisé avec d'autres sortes 
d'itérables (chaînes, tableaux ou arguments)

7. Le mot-clé yield suspend une fonction génératrice et la valeur 
de l'expression suivant le mot-clé yield est retournée à l'appelant 
du générateur. Il peut être vu comme une version générateur 
du mot-clé return.

8. La fin de la fonction génératrice est atteinte ; dans ce cas, l'exécution du générateur se termine et un IteratorResult est retourné à l'appelant, dans lequel la valeur est undefined et done est true.
Une instruction return est atteinte ; dans ce cas, l'exécution du générateur se termine et un IteratorResult est retourné à l'appelant dans lequel la value est la valeur spécifiée par l'instruction return et done vaut true.

    Ex1:
    // Exemple simple
    function* creerID(){
      var index = 0;
      while(index < 3){
        yield index++;
      }
    }
    var gen = creerID();
    console.log(gen.next().value); // 0
    console.log(gen.next().value); // 1
    console.log(gen.next().value); // 2
    console.log(gen.next().value); // undefined

    Ex2:
    // Avec des arguments
    function* logGenerator() {
      console.log(yield);
      console.log(yield);
      console.log(yield);
    }
    var gen = logGenerator();
    // le premier appel à next exécute la fonction depuis son 
    // début jusqu'au premier yield rencontré
    gen.next(); 
    gen.next('bretzel');    // bretzel
    gen.next('california'); // california
    gen.next('mayonnaise'); // mayonnaise

    Ex3:
    // Exemple utilisant yield* (Pour déléguer la génération des valeurs à un autre générateur)
    function* autreGenerateur(i) {
      yield i + 1;
      yield i + 2;
      yield i + 3;
    }
    function* generateur(i){
      yield i;
      yield* autreGenerateur(i);
      yield i + 10;
    }
    var gen = generateur(10);
    console.log(gen.next().value); // 10
    console.log(gen.next().value); // 11
    console.log(gen.next().value); // 12
    console.log(gen.next().value); // 13
    console.log(gen.next().value); // 20

    Ex4:
    // Utilisation de return
    function* yieldAndReturn() {
      yield "Y";
      return "R";
      yield "inaccessible";
    }
    var gen = yieldAndReturn();
    console.log(gen.next()); // { value: "Y", done: false }
    console.log(gen.next()); // { value: "R", done: true }
    console.log(gen.next()); // { value: undefined, done: true }

    Ex5:
    // Utiliser un générateur comme propriété
    const monObj = {
      *generator () {
        yield "a";
        yield "b";
      }
    }
    const gen = monObj.generator();
    console.log(gen.next()); // { value: "a", done: false }
    console.log(gen.next()); // { value: "b", done: false }
    console.log(gen.next()); // { value: undefined, done: true }

    Ex6:
    // Utiliser un générateur comme propriété calculée
    class Toto {
      *[Symbol.iterator] () {
        yield 1;
        yield 2;
      }
    }
    const monObj = {
      *[Symbol.iterator] () {
        yield "a";
        yield "b";
      }
    }
    console.log(Array.from(new Toto)); // [1, 2]
    console.log(Array.from(monObj));   // [ "a", "b"]

    Ex7:
    // Générateur défini avec une expression
    const toto = function* () {
      yield 10;
      yield 20;
    };
    const truc = toto();
    console.log(truc.next()); // {value: 10, done: false}

    Ex8:
    function* gen(i) {
        yield i
        yield i + 10
        return 25
    }
    const g = gen(5)
    g.next() // {value: 5, done: false}
    g.next() // {value: 15, done: false}
    g.next() // {value: 25, done: true }

    Ex9:
    // In the example the generator function accessed directly without a wrapper always executes only until the first yield. 
    // Hence, by definition you need to assign the Generator to a variable to properly iterate over it
    function* genFunction(i) {
        yield i
        yield i + 1
    }
    let generator = genFunction(5) // Create a generator

    console.log(generator.next()); // {value: 5, done: false}
    console.log(generator.next()); // {value: 6, done: false}

    // Accessing genFunction directly
    console.log(genFunction(5).next()); // {value: 5, done: false}
    console.log(genFunction(5).next()); // {value: 5, done: false}

    Ex9:
    // Passer un argument à next() pour modifier l'état interne du générateur
    function* fibonacci(){
      var fn1 = 0;
      var fn2 = 1;
      while (true){
        var current = fn1;
        fn1 = fn2;
        fn2 = fn1 + current;
        var reset = yield current;
        if (reset){
            fn1 = 0;
            fn2 = 1;
        }
      }
    }

    var sequence = fibonacci();
    console.log(sequence.next().value);     // 0
    console.log(sequence.next().value);     // 1
    console.log(sequence.next().value);     // 1
    console.log(sequence.next().value);     // 2
    console.log(sequence.next().value);     // 3
    console.log(sequence.next().value);     // 5
    console.log(sequence.next().value);     // 8
    console.log(sequence.next(true).value); // 0
    console.log(sequence.next().value);     // 1
    console.log(sequence.next().value);     // 1
    console.log(sequence.next().value);     // 2

    Ex10:
    // Assigner yield à une variable
    function* gen(i) {
        // 
        const x = yield 1
        console.log(x)
        const y = yield 2
        console.log(y)
    }
    let g = gen()
    console.log(g.next()) // {value: 1, done: false}, x undefined
    console.log(g.next()) // {value: 2, done: false}, y undefined
    console.log(g.next()) // {value: undefined, done: true}

    Ex11:
    function* gen() {
       yield 5;
    }    
    // équivaut à
    function* gen() {
       yield 5;
       return undefined;
    }

    Ex12:
    function* addGenerator(i) {
        while (true) {
            i += yield i;
        }
    }
    const iterator = addGenerator(0);
    iterator.next(); // { value: 0, done: false }
    iterator.next(2); // { value: 2, done: false }
    iterator.next(5); // { value: 7, done: false }

    Ex14:
    function* gen(arg) {
        return arg;
    }
    const it = gen('foo');
    it.next('bar'); // { value: 'foo', done: true }

    Ex15:
    function* gen(i) {
        console.log(i)
        const j = 5 * (yield (i*10))
        console.log(j)
        const k = yield (2*j/4)
        console.log(k)
        return (i+j+k)
    }
    let iterator = gen(10)

    console.log(iterator.next(20)) 
    // La valeur passée au premier next, est toujours ignorée, 
    // c'est la valeur passée en argument au générateur qui est prise en compte.
    // i vaut donc 10
    // next(20) renvoie un objet ayant pour valeur i*10 soit 10*10 soit 100

    console.log(iterator.next(10))
    // La valeur 10 passée au next remplace l'expression du yield précédent yield (i*10) soit 10
    // j vaut donc 5*10 soit 50
    // next(10) renvoie un objet ayant pour valeur le résultat de l'expression 2*j/4 du yield courant soit 2*50/4 soit 25

    console.log(iterator.next(5))
    // La valeur 5 passée au next remplace l'expression du yield précédent yield (2*j/4) soit 5
    // k vaut 5
    // next(5) renvoie un objet ayant pour valeur le résultat de l'expression i+j+k du return soit 10+50+5 soit 65 et une valeur done à true
    // Le générateur est terminé

    // Sortie console
    // 10
    // {value: 100, done: false}
    // 50
    // {value: 25, done: false}
    // 5
    // {value: 65, done: true}

    Ex16:
    function* gen(i) {
        yield
        foo(yield "Iam")
    }
    function foo(x) {
        console.log("Just printing", x)
    }
    var iterator = gen()

    console.log(iterator.next())
    // Le premier yield ne retourne aucune valeur 
    // next() renvoie donc un objet ayant pour valeur undefined

    console.log(iterator.next())
    // Ce deuxième yield possède la valeur "Iam"
    // next() renvoie donc un objet ayant pour valeur "Iam"

    console.log(iterator.next())
    // Aucune valeur n'est passée au next, il remplace donc l'expression du yield précédent yield "Iam" par undefined
    // La fonction foo est éxécuté avec l'argument undefined passé en paramètre ce qui affiche Just printing undefined
    // Comme il n'y a plus de yield, next() renvoie un objet ayant pour valeur undefined et done à true

    // Sortie console
    // {value: undefined, done: false}
    // {value: "Iam", done: false}
    // Just printing undefined
    // {value: undefined, done: true}

    Ex17:
    function* fetchUser() {
        const user = yield getData()
        console.log("User", user)
    }
    function getData() {
        return {name:'Johan', dob: '1979'}
    }
    var iterator = fetchUser()

    console.log(iterator.next().value)
    // next().value renvoie un objet ayant pour valeur le résultat de l'expression getData() soit {name: "Johan", dob: "1979"}

    console.log(iterator.next())
    // Aucune valeur n'est passée au next, il remplace donc l'expression du yield précédent yield getData() par undefined
    // user vaut donc undefined et s'affiche
    // Comme il n'y a plus de yield, next() renvoie un objet ayant pour valeur undefined et done à true

    // {name: "Johan", dob: "1979"}
    // User undefined
    // {value: undefined, done: true}

    Ex18:
    // Yield with Promises
    function* fetchUser(action) {
        const user = yield apiCall()
    }
    function apiCall() {
        return new Promise(resolve => {
            settimeout(() => {
                resolve ( {name:'Johan', dob: '1979'} )
            }, 2000);
        })
    }
    var iteratorFetch = fetchUser()

    // prints user data after 2 seconds
    console.log(iteratorFetch.next().value.then(n => console.log(n))):
    
    Ex19:
    // Délégation de la génération avec yield*
    function* g1() {
      yield 2;
      yield 3;
      yield 4;
    }
    function* g2() {
      yield 1;
      yield* g1();
      yield 5;
    }
    var iterator = g2();
    console.log(iterator.next()); // { value: 1, done: false }
    console.log(iterator.next()); // { value: 2, done: false }
    console.log(iterator.next()); // { value: 3, done: false }
    console.log(iterator.next()); // { value: 4, done: false }
    console.log(iterator.next()); // { value: 5, done: false }
    console.log(iterator.next()); // { value: undefined, done: true }

    Ex20:
    // Les autres objets itérables 
    function* g3() {
      yield* [1, 2];
      yield* "34";
      yield* Array.from(arguments);
    }
    var iterator = g3(5, 6);
    console.log(iterator.next()); // { value: 1, done: false }
    console.log(iterator.next()); // { value: 2, done: false }
    console.log(iterator.next()); // { value: "3", done: false }
    console.log(iterator.next()); // { value: "4", done: false }
    console.log(iterator.next()); // { value: 5, done: false }
    console.log(iterator.next()); // { value: 6, done: false }
    console.log(iterator.next()); // { value: undefined, done: true }

    Ex21:
    // La valeur de l'expression yield*
    function* g4() {
      yield* [1, 2, 3];
      return "toto";
    }
    var résultat;
    function* g5() {
      résultat = yield* g4();
    }
    var iterator = g5();
    console.log(iterator.next()); // { value: 1, done: false }
    console.log(iterator.next()); // { value: 2, done: false }
    console.log(iterator.next()); // { value: 3, done: false }
    console.log(iterator.next()); // { value: undefined, done: true },
                                  // g4() renvoie{ value: "toto", done: true } at this point
    console.log(résultat);          // "toto"



Héritage et chaîne de prototype
-------------------------------
1. JavaScript continue de reposer sur l'héritage prototypique. En ce qui concerne l'héritage, JavaScript n'utilise qu'une seule structure : les objets. 
Chaque objet possède une propriété privée qui contient un lien vers un autre objet appelé le prototype. Ce prototype possède également son prototype et 
ainsi de suite, jusqu'à ce qu'un objet ait null comme prototype. Par définition, null ne possède pas de prototype et est ainsi le dernier maillon de la chaîne de prototype.

2. La majorité des objets JavaScript sont des instances de Object qui est l'avant dernier maillon de la chaîne de prototype.

3. Les objets JavaScript sont des ensembles dynamiques de propriétés (les propriétés directement rattachées à un objet sont 
appelées propriétés en propre (own properties)). Les objets JavaScript possèdent également un lien vers un objet qui est leur prototype. 
Lorsqu'on tente d'accéder aux propriétés d'un objet, la propriété sera recherchée d'abord sur l'objet même, puis sur son prototype, puis 
sur le prototype du prototype et ainsi de suite jusqu'à ce qu'elle soit trouvée ou que la fin de la chaîne de prototype ait été atteinte.

4. Dans la spécification ECMAScript, on utilise la notation unObjet.[[Prototype]] pour faire référence au prototype de unObjet. 
Depuis ECMAScript 2015, on peut accéder à [[Prototype]] grâce aux accesseurs Object.getPrototypeOf() et Object.setPrototypeOf(). 
Cela est équivalent à la propriété JavaScript __proto__ qui était non-standard avant ES2015 mais qui était de fait implémentée par la majorité des navigateurs.

    Ex1:
    // On commence par créer un objet o pour lequel la fonction f sera 
    // son constructeur et lui créera deux propriétés en propre
    // a et b :
    let f = function () {
      this.a = 1;
      this.b = 2;
    }
    let o = new f(); // {a: 1, b: 2}

    // on ajoute des propriétés au prototype de la fonction
    // f
    f.prototype.b = 3;
    f.prototype.c = 4;

    // Note : on ne définit pas le prototype de f avec f.prototype = {b:3,c:4};
    // car cela briserait la chaîne de prototype

    // o.[[Prototype]] possède les propriétés b and c.
    // o.[[Prototype]].[[Prototype]] est Object.prototype.
    // Enfin, o.[[Prototype]].[[Prototype]].[[Prototype]] vaut null.
    // On a alors atteint la fin de la chaîne de prototype car,
    // par définition, null n'a pas de [[Prototype]].
    // Ainsi, la chaîne complète est ici :
    // {a: 1, b: 2} ---> {b: 3, c: 4} ---> Object.prototype ---> null

    console.log(o.a); // 1
    // Existe-t-il une propriété 'a' en propre sur o ? Oui, elle vaut 1.

    console.log(o.b); // 2
    // Existe-t-il une propriété 'b' en propre sur o ? Oui, elle vaut 2.
    // Le prototype possède également une propriété 'b' mais elle n'est pas
    // utilisée.
    // C'est ce qu'on appelle l'ombrage (shadowing en anglais)

    console.log(o.c); // 4
    // Existe-t-il une propriété 'c' en propre sur o ? Non, on vérifie le
    // prototype.
    // Existe-t-il une propriété 'c' en propre sur o.[[Prototype]] ?
    // Oui, elle vaut 4.

    console.log(o.d); // undefined
    // Existe-t-il une propriété 'd' en propre sur o ? Non, on vérifie le
    // prototype.
    // Existe-t-il une propriété 'd' en propre sur o.[[Prototype]] ? Non, on vérifie le 
    // prototype.
    // o.[[Prototype]].[[Prototype]] est Object.prototype et ne contient pas 
    // de propriété 'd' par défaut. On vérifie son prototype.
    // o.[[Prototype]].[[Prototype]].[[Prototype]] est null, on arrête la recherche
    // aucune propriété n'est trouvée, le moteur renvoie undefined.

5. Si un objet et son prototype possèdent la même propriété, celle du prototype n'est pas utilisée.
C'est ce qu'on appelle l'ombrage (shadowing en anglais)

6.Lorsquon définit une propriété sur un objet, cela définit une propriété en propre. 
La seule exception se produit lorsqu'on définit un accesseur et/ou un mutateur sur une propriété héritée.

7. JavaScript ne possède pas de méthodes au sens des langages de classe. En effet, en JavaScript, toute fonction associée à un objet est également une propriété. 
Une fonction héritée se comportera comme n'importe quelle autre propriété (y compris pour l'ombrage mentionné ci-avant où on pourra parler de surcharge).

8. Lorsqu'une fonction héritée est exécutée, la valeur de this pointe vers l'objet hérité et non vers l'objet prototype qui possède la fonction comme propriété en propre.

    Ex1:
    var o = {
      a: 2,
      m: function() {
        return this.a + 1;
      }
    };

    console.log(o.m()); // 3
    // Quand on appelle o.m ici, 'this' fera référence à o

    var p = Object.create(o);
    // p est un objet qui hérite de o

    p.a = 4; // on crée une propriété 'a' en propre sur p
    console.log(p.m()); // 5
    // lorsque p.m est appelée, 'this' fait référence à p.
    // Ainsi quand p hérite de m via o, 
    // 'this.a' signifie p.a, soit la propriété 'a' de p

9. En JavaScript, les fonctions peuvent avoir des propriétés. Toutes les fonctions ont une propriété spéciale intitulée prototype.

    Ex1:
    function faireUnTruc(){}
    console.log( faireUnTruc.prototype ); // Object {...}
    // Peu importe comment vous déclarez la fonction.
    // une fonction en JavaScript aura toujours une propriété
    // prototype par défaut.
    var faireUnTruc= function(){}; 
    console.log(faireUnTruc.prototype); // Object {...}
    
    Ex2:
    // Ajouter des propriétés au prototype de faireUnTruc()
    function faireUnTruc(){}
    faireUnTruc.prototype.toto = "truc";
    console.log( faireUnTruc.prototype );
    // {
    //   toto: "truc",
    //   constructor: ƒ faireUnTruc(),
    //   __proto__: {
    //       constructor: ƒ Object(),
    //       hasOwnProperty: ƒ hasOwnProperty(),
    //       isPrototypeOf: ƒ isPrototypeOf(),
    //       propertyIsEnumerable: ƒ propertyIsEnumerable(),
    //       toLocaleString: ƒ toLocaleString(),
    //       toString: ƒ toString(),
    //       valueOf: ƒ valueOf()
    //   }
    // }

    Ex3:
    // Toute fonction déclaré possède nativement une propriété « prototype » initialement vide
    var Dog = function() {}; // declaring constructor
    Dog.prototype;     // prints "{}" : prototype exists and is empty

10. On peut utiliser l'opérateur new afin de créer une instance de faireUnTruc() basée sur ce prototype. 
Pour utiliser l'opérateur new, il suffira d'appeler la fonction et de précéder cet appel avec le mot-clé new. 
Lorsqu'on appelle une fonction avec un opérateur new, celle-ci renvoie un objet qui est une instance de la fonction. 
On peut ensuite ajouter des propriétés sur cet objet.
    
    Ex1:
    function faireUnTruc(){}
    faireUnTruc.prototype.toto = "truc"; // on ajoute une propriété au prototype
    var uneInstance = new faireUnTruc();
    uneInstance.prop = "une valeur"; // on ajoute une propriété sur l'objet
    console.log(uneInstance);
    // {
    //   prop: "une valeur",
    //   __proto__: {
    //       toto: "truc",
    //       constructor: ƒ faireUnTruc(),
    //       __proto__: {
    //           constructor: ƒ Object(),
    //           hasOwnProperty: ƒ hasOwnProperty(),
    //           isPrototypeOf: ƒ isPrototypeOf(),
    //           propertyIsEnumerable: ƒ propertyIsEnumerable(),
    //           toLocaleString: ƒ toLocaleString(),
    //           toString: ƒ toString(),
    //           valueOf: ƒ valueOf()
    //       }
    //   }
    // }
    
    Ex2:
    function faireUnTruc(){}
    faireUnTruc.prototype.toto = "truc";
    var uneInstance = new faireUnTruc();
    uneInstance.prop = "une valeur";
    console.log("uneInstance.prop: " + uneInstance.prop);
    console.log("uneInstance.toto: " + uneInstance.toto);
    console.log("faireUnTruc.prop: " + faireUnTruc.prop);
    console.log("faireUnTruc.toto: " + faireUnTruc.toto);
    console.log("faireUnTruc.prototype.prop: " + faireUnTruc.prototype.prop);
    console.log("faireUnTruc.prototype.toto:  " + faireUnTruc.prototype.toto);
    // uneInstance.prop: une valeur
    // uneInstance.toto: truc
    // faireUnTruc.prop: undefined
    // faireUnTruc.toto: undefined
    // faireUnTruc.prototype.prop: undefined
    // faireUnTruc.prototype.toto: truc

    Ex3:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    bobby.bark(); // using the prototype declaration - prints "wouf wouf" to the console
    var felix = new Dog();
    (bobby.bark == felix.bark); // instances share same reference - returns true;
    bobby.bark = Dog.prototype.bark // which is the prototype property - returns true;

11. Performance. Le temps de recherche des propriétés sera plus élevé si ces propriétés sont situées plus loin dans la chaîne de prototype. 
Tenter d'accéder à ces propriétés éloignées pourra avoir un impact négatif sur les performances. 
De plus, tenter d'accéder à des propriétés inexistantes entraîntera toujours le parcours de l'ensemble de la chaîne de prototype.
Lorsqu'on parcourt les propriétés d'un objet, toutes les propriétés énumérables situées sur la chaîne de prototype seront parcourues. 
Pour vérifier si un objet possède une propriété en propre plus que via sa chaîne de prototype, on devra utiliser la méthode hasOwnProperty() 
qui est héritée grâce à Object.prototype.

    Ex1:
    function Graphe() {
      this.sommets = [];
      this.aretes = [];
    }
    Graphe.prototype = {
      ajoutSommet: function(v) {
        this.sommets.push(v);
      }
    };
    var g = new Graphe();
    // g est un objet qui possède les propriétés 'sommets' and 'aretes' en propre.
    // g.[[Prototype]] est la valeur de Graphe.prototype lorsque "new Graphe()" est exécuté.
    console.log(g.hasOwnProperty('aretes'));
    // true
    console.log(g.hasOwnProperty('nononon'));
    // false
    console.log(g.hasOwnProperty('ajoutSommet'));
    // false
    console.log(g.__proto__.hasOwnProperty('ajoutSommet'));
    // true

12. Tester si une propriété vaut undefined ne suffit pas à vérifier la présence de la propriété sur un objet : 
une propriété peut très bien exister sur un objet mais valoir undefined.

14. Mauvaise pratique : étendre les prototypes natifs. On peut parfois voir du code qui étend Object.prototype ou l'un des prototypes natifs.
Cette technique est intitulée monkey patching et brise l'encapsulation. Bien qu'elle soit utilisée par certains frameworks, il n'existe pas de 
raison suffisante pour étendre les objets natifs avec des fonctionnalités non-standard.
La seule raison qui peut prévaloir pour l'extension de prototypes natifs est l'ajout de fonctionnalités JavaScript apparues 
avec les nouvelles versions des spécifications et moteurs afin d'en disposer dans de plus anciens environnements.

15. On peut surcharger sur une instance une propriété définie sur son prototype. 
Cependant cela ne surcharge que sa propre référence, et ne touche donc pas à la déclaration du prototype.

    Ex1:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    var felix = new Dog();
    bobby.bark = function() { console.log("beeeee !") }; // setting the bark property on dogA
    bobby.bark(); // using the instance function, prints "beeee !" to the console
    felix.bark(); // still using the prototype function, prints "wouf wouf" to the console.

16. Une modification du prototype est immédiate sur les instances déjà existantes et les futures. 
En effet le prototype est une référence des instances, et le « fallback » se fait au moment de l'accès à la propriété.

    Ex1:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    bobby.bark(); // prints "wouf wouf" to the console
    Dog.prototype.bark = function() { console.log("meow meow"); } // overrides the prototype bark method
    bobby.bark(); // now prints "meow meow" to the console.

17. Une méthode modifiée sur le prototype est immédiatement active, un rajout l'est aussi.

    Ex1:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    bobby.sleep(); // Raise a TypeError : has no method sleep
    Dog.prototype.sleep = function() { console.log("Zzz Zzz"); }
    bobby.sleep(); // now prints "Zzz Zzz" to the console.

18. La classe d'une instance (enfin, techniquement, le constructeur) est accessible via la propriété constructor. 
Cela permet également d'accéder à son prototype (même s'il est très rare d'y voir une utilité).

    Ex1:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    bobby.constructor === Dog; // bobby constructor is Dog, returns true
    bobby.constructor.prototype.bark // direct access to the prototype

    // Le mot clef instanceof de javascript fonctionne bien avec les constructeurs
    bobby instanceof Dog; // bobby is an instance of Dog, returns true


Les différentes façons de créer des objets et les impacts sur la chaîne de prototype
-------------------------------
    Ex1:
    // Objets créés avec les raccourcis syntaxiques (littéraux)
    var o = {a: 1};
    // Le nouvel objet possède Object.prototype comme [[Prototype]]
    // o ne possède pas de propriété 'hasOwnProperty' en propre
    // hasOwnProperty est une propriété en propre de Object.prototype. 
    // o hérite de hasOwnProperty via Object.prototype
    // Object.prototype possède null comme prototype.
    // o ---> Object.prototype ---> null
    var myObject = {
      a : 1,
      b : 2,
      sum : function() {
        return this.a + this.b;
      }
    };
    // myObject ---> Object.prototype ---> null

    var b = ['coucou', 'ça va', '?'];
    // Les tableaux (Array) héritent de Array.prototype 
    // (qui possède les méthodes indexOf, forEach, etc.)
    // La chaîne de prototype est donc :
    // b ---> Array.prototype ---> Object.prototype ---> null

    function f() {
      return 2;
    }
    // Les fonctions héritent de Function.prototype 
    // (qui possède les méthodes call, bind, etc.)
    // La chaîne de prototype est donc
    // f ---> Function.prototype ---> Object.prototype ---> null
    
    Ex2:
    // Objets créés avec un constructeur
    // En JavaScript, un constructeur est juste une fonction que l'on invoque avec l'opérateur new.
    function Graphe() {
      this.sommets = [];
      this.arêtes = [];
    }
    Graphe.prototype = {
      ajoutSommet: function(v) {
        this.sommets.push(v);
      }
    };
    var g = new Graphe();
    // g est un objet qui possède les propriétés 'sommets' and 'arêtes' en propre.
    // g.[[Prototype]] est la valeur de Graphe.prototype lorsque "new Graphe()" est exécuté.

    // Toute fonction peut servir de constructeur : il suffit simplement de l'appeler avec l'opérateur new.
    var Dog = function() {   // defining Dog constructor
      this.hasTail = true; // defining a property
      this.bark = function() { // defining a method property
        console.log("wouf wouf");
      }
    }
    var bobby = new Dog(); // instanciating the constructor
    bobby.hasTail; // returns true
    bobby.bark();  // print "wouf wouf" to the console

    // Pour définir une propriété des futures instances, il faut utiliser le mot clef this. En effet var ne suffit pas. 
    // C'est d'ailleurs une particularité intéressante dont on peut se servir pour déclarer des variables privées de l'instance
    var Dog = function() {
      var shout = "wouf wouf"; // defining a local var.
      this.bark = function() {
        console.log(shout); // local scope access the 'shout' variable
      }
    }
    var bobby = new Dog();
    bobby.bark();  // print "wouf wouf" to the console
    bobby.shout;   // undefined , not attached to the instance

    // Il est également possible de passer des paramètres à un constructeur 
    var Dog = function(breed) {
      this.breed = breed;
    }
    var bobby = new Dog("terrier");
    bobby.breed;  // returns "terrier"

    // Problème : comme la déclaration des méthodes se fait lors de l'instanciation, les instances ne partageant pas leurs méthodes.
    var Dog = function() {
      this.bark = function() {
        console.log(shout);
      }
    }
    var bobby = new Dog();
    var felix = new Dog();
    (boddy.bark == felix.bark); // returns false. They both declared their own method. 
    
    Ex3:
    // Objets créés avec Object.create()
    // Appeler cette méthode crée un nouvel objet et le prototype de cet objet est le premier argument de cette fonction
    var a = {a: 1}; 
    // a ---> Object.prototype ---> null

    var b = Object.create(a);
    // b ---> a ---> Object.prototype ---> null
    console.log(b.a); // 1 (héritée)

    var c = Object.create(b);
    // c ---> b ---> a ---> Object.prototype ---> null

    var d = Object.create(null);
    // d ---> null
    console.log(d.hasOwnProperty); 
    // undefined, car d n'hérite pas de Object.prototype  
    
    Ex4:
    // Objets créés avec le mot-clé class
    // ECMAScript 2015 introduit plusieurs mots-clés destinés à créer du sucre syntaxique pour manipuler des classes. 
    // Ces mots-clés sont class, constructor, static, extends et super
    'use strict';
    class Polygone {
      constructor(hauteur, largeur) {
        this.hauteur = hauteur;
        this.largeur = largeur;
      }
    }
    class Carre extends Polygone {
      constructor(longueurCote) {
        super(longueurCote, longueurCote);
      }
      get aire() {
        return this.hauteur * this.largeur;
      }
      set longueurCote(nouvelleLongueur) {
        this.hauteur = nouvelleLongueur;
        this.largeur = nouvelleLongueur;
      }
    }
    var carre = new Carre(2);


Le mot clé static dans une classe javascript
-------------------------------
1. C'est une méthode de classe et non une méthode d'instance. L'instance ne peut pas l'appeler.

2. On a pas besoin d'instancier la classe pour appeler cette méthode

	///////////////////////////////////////EX:
	class ClassWithStaticMethod {
	  static staticMethod() {
	    return 'static method has been called.';
	  }
	}

	console.log(ClassWithStaticMethod.staticMethod());
	// expected output: "static method has been called."


Comparer des objets
-------------------------------
1. En JavaScript, les objets fonctionnent par référence. Deux objets distincts ne sont jamais égaux, même s'ils ont les mêmes valeurs 
pour les mêmes propriétés. On aura une équivalence uniquement si on compare un objet avec lui-même.

    Ex1:
    // Deux variables avec deux objets distincts qui ont les mêmes propriétés
    var fruit = {nom: "pomme"};
    var fruit2 = {nom: "pomme"};
    fruit == fruit2  // return false
    fruit === fruit2 // return false
    // Deux variables avec un même objet
    var fruit = {nom: "pomme"};
    var fruit2 = fruit;  // On affecte la même référence
    // dans ce cas fruit et fruit2 pointent vers le même objet
    fruit == fruit2  // return true
    fruit === fruit2 // return true
    fruit.nom = "raisin";
    console.log(fruit2); // affiche {nom: "raisin"} et non {nom: "pomme"}


Utiliser this
-------------------------------
1. JavaScript possède un mot-clé spécial this, qui peut être utiliser à l'intérieur d'une méthode pour faire référence à l'objet courant.

    Ex1:
    // Si on a une fonction valider qui permet de valider la propriété 
    // valeur d'un objet en fonction d'un seuil minimum et d'un seuil maximum
    function valider(obj, seuilMin, seuilMax) {
      if ((obj.value < seuilMin) || (obj.valeur > seuilMax))
        console.log("Valeur invalide !");
    }

    // Cette fonction pourrait ensuite être appelée via le gestionnaire d'événement onchange 
    // pour les éléments d'un formulaire et la valeur pour l'élément du formulaire serait passée en argument
    <input type="text" name="age" size="3" onChange="valider(this, 18, 99)">

2. En général, this fait référence à l'objet appelant de la méthode.


Promise, Async et Await
-------------------------------
 1. La nature asynchrone du JavaScript pose souvent des problèmes en terme d'organisation. Si on vient d'un langage plus classique 
 il est parfois difficile de concevoir des fonctions avec une résolution asynchrone. 
 Comment renvoyer les résultats quand le code n'est pas exécuté de manière synchrone ?

 2. Les callbacks
 Nous souhaitons donc créer une fonction pour faire un appel Ajax. 
 La résolution de la requête Ajax se fait de manière asynchrone et il n'est donc pas possible d'utiliser un simple return.
 Il faut donc être capable de détecter la résolution de la requête afin d'effectuer la suite de nos traitements. La solution pour remédier cette problématique est d'utiliser 
 des fonctions anonymes que l'on va éxécuter lors de la résolution de notre code. Ces fonctions sont appellées callbacks.

    Ex1:
    var ajax = function (url) {
      var req = new XMLHttpRequest()
      req.open('GET', url, true)
      req.onreadystatechange = function (aEvt) {
        if (req.readyState == 4) {
          if(req.status == 200)
            // return req.responseText n'est pas possible
            // On ne peut pas utiliser de "return" ici car on est dans la fonction 
            // onReadyStateChange
          else
            // ...
        }
      };
      req.send(null)
    }
    ajax('https://jsonplaceholder.typicode.com/users') 
    // Comment détecter la fin de la requête ajax ?

    Ex2:
    var ajax = function (url, success, error) {
      var req = new XMLHttpRequest()
      req.open('GET', url, true)
      req.onreadystatechange = function (aEvt) {
        if (req.readyState == 4) {
          if(req.status == 200)
            success(req.responseText)
          else
            error(req)
        }
      };
      req.send(null)
    }
    ajax('https://jsonplaceholder.typicode.com/users', function (response) {
      // response contient la réponse de la requête, on peut faire le reste du traitement
    }, function (req) {
      // Le serveur n'a pas répondu comme attendu, on traite l'erreur
    })

    Ex3:
    // Cette méthode fonctionne mais si vous souhaitez effectuer des opérations asynchrones en cascade votre code va vite ressembler à ça...
    ajax('https://jsonplaceholder.typicode.com/users', function (response) {
      ajax('https://jsonplaceholder.typicode.com/posts', function (response) {
        ajax('https://jsonplaceholder.typicode.com/tutoriels', function (response) {
          // Là j'ai tout !
        }, function (req) { })
      }, function (req) { })
    }, function (req) { })

3. Les promesses
Comme son nom l'indique vous pouvez voir ça comme la promesse que vous allez recevoir une valeur. 
Comme toute promesse, elle peut être tenue, la valeur est arrivée et on peut s'en servir, ou ne pas l'être, 
dans ce cas une erreur arrive et on peut réagir en conséquence.
    EX:
    // Utilisation des promesses
    const functionWithPromise1 = () => Promise.resolve("test");
    const functionWithPromise2 = arg => Promise.resolve(arg);
    const functionWithPromise3 = arg => Promise.resolve(arg);
    const functionWithPromise4 = arg => Promise.resolve(arg);
    const functionWithPromise5 = arg => Promise.resolve(arg);
    const functionWithPromise6 = arg => Promise.resolve(arg);

    functionWithPromise1()
      .then(functionWithPromise2)
      .then(functionWithPromise3)
      .then(functionWithPromise4)
      .then(functionWithPromise5)
      .then(functionWithPromise6)
      .then(result => console.log(`Exemple avec les promesses : ${result}`))
      .catch(err => {
        throw err;
      });

Les promesses permettent une approche différente du problème et sont apparues avec l'ES2015.
A vu de nez cette méthode semble proche de la méthode précédente. Cependant, les promesses peuvent 
être enchainées ce qui simplifie grandement la gestion en cascades et en parallèle.

    Ex1:
    let ajax = function (url) {
      // On renvoie une promesse qui prend en paramètre une fonction 
      // avec 2 paramètres qui sont eux même deux fonctions, le callback de succès (resolve) et d'erreur (reject)
      return new Promise(function (resolve, reject) {
        // Le reste du code ressemble à la méthode précédente
        let req = new XMLHttpRequest()
        req.open('GET', url, true)
        req.onreadystatechange = function (aEvt) {
          if (req.readyState == 4) {
            if(req.status == 200)
              resolve(req.responseText)
            else
              reject(req)
          }
        };
        req.send(null)
      })
    }
    // L'appel à la fonction peut se faire de cette manière là
    ajax('https://jsonplaceholder.typicode.com/users')
    .then(function (response) {
      // Le serveur a correctement répondu
    }).catch(function (req) {
      // Le serveur n'a pas répondu comme attendu
    })

    Ex2:
    let ajax = function (url) {
      // On renvoie une promesse qui prend en paramètre une fonction 
      // avec 2 paramètres, le callback de succès et d'erreur
      return new Promise(function (resolve, reject) {
        // Le reste du code ressemble à la méthode précédente
        let req = new XMLHttpRequest()
        req.open('GET', url, true)
        req.onreadystatechange = function (aEvt) {
          if (req.readyState == 4) {
            if(req.status == 200)
              resolve(req.responseText)
            else
              reject(req)
          }
        };
        req.send(null)
      })
    }
    // Cascade
    ajax('https://jsonplaceholder.typicode.com/users')
    .then(function (response) {
      // Si le then retourne une promesse on peut enchainer
      return ajax('https://jsonplaceholder.typicode.com/posts')
    })
    .then(function (response) {
      // Si le then retourne une promesse on peut enchainer
      return ajax('https://jsonplaceholder.typicode.com/comments')
    })
    .then(function (response) {
      // La série d'opération est finie
    })
    .catch(function (req) {
      // Une des requête a échouée
    })

    Ex3:
    // En parallèle
    Promise.all([
      ajax('https://jsonplaceholder.typicode.com/users'),
      ajax('https://jsonplaceholder.typicode.com/posts'),
      ajax('https://jsonplaceholder.typicode.com/comments')
    ]).then(function (responses) {
      responses // [response1, response2, response3]
    }).catch(function (errors) { })


The function passed to new Promise is called the executor. 
When new Promise is created, it runs automatically. It contains the producing code, that should eventually produce a result.

Its arguments resolve and reject are callbacks provided by JavaScript itself. Our code is only inside the executor.

When the executor obtains the result, be it soon or late – doesn’t matter, it should call one of these callbacks:
resolve(value) — if the job finished successfully, with result value.
reject(error) — if an error occurred, error is the error object.

C'est le développeur qui place ces deux callback dans le code de l'executor pour dire
à quel moment la promesse est résolue avec succès et le résultat à retourner en argument de resolve
ou avec une erreur et l'erreur à retourné en argument de reject

So to summarize: the executor runs automatically, it should do a job and then call either resolve or reject.

The promise object returned by new Promise constructor has internal properties:
state — initially "pending", then changes to either "fulfilled" when resolve is called or "rejected" when reject is called.
result — initially undefined, then changes to value when resolve(value) called or error when reject(error) is called.

A promise that is either resolved or rejected is called “settled”, as opposed to a initially “pending” promise.

Rejecting or resolving won't stop the execution of the rest of the function. 
Pour éviter d'éventuels problèmes il est conseillé de stopper l'éxécution
après un resolve ou un reject soit en les retournant dans un return
soit en utilisant un if/else 

The executor should call only one resolve or one reject. Any state change is final.
All further calls of resolve and reject are ignored:

In case something goes wrong, the executor should call reject. That can be done with any type of argument (just like resolve). 
But it is recommended to use Error objects (or objects that inherit from Error). The reasoning for that will soon become apparent.

The properties state and result of the Promise object are internal. We can’t directly access them. 
We can use the methods .then/.catch/.finally for that. They are described below.

La fonction statique Promise.resolve renvoie un objet Promise qui est résolu.

    EX:
    var p = Promise.resolve([1,2,3]);
    p.then(function(v) {
      console.log(v[0]); // 1
    });

    EX:
    // Résoudre une autre Promise
    var original = Promise.resolve(33);
    var cast = Promise.resolve(original);
    cast.then(function(value) {
      console.log("value: " + value);
    });
    console.log("original === cast ? " + (original === cast));

    // affiche ceci dans la console (dans cet ordre) :
    // original === cast ? true
    // value: 33

    // L'ordre des traces dans la console est dû au fait que...
    // ...les gestionnaires then() sont appelés de façon asynchrone

La fonction statique Promise.reject renvoie une Promise qui est rejetée. Pour faciliter le débogage (comprendre plus rapidement le problème et sélectionner une erreur précise), il peut être utile que l'argument raison soit une instance d'Error.

    EX:
    Promise.reject(new Error("échec")).then(function() {
      // n'est pas appelée
    }, function(erreur) {
      console.log(erreur); // Analyse de la pile d'appels
    });


3.1 then

promise.then(
  function(result) { /* handle a successful result */ },
  function(error) { /* handle an error */ }
);

The first argument of .then is a function that runs when the promise is resolved, and receives the result.
The second argument of .then is a function that runs when the promise is rejected, and receives the error.
En fait then() attend simplement que la fonction resolve ou reject soit appelé dans le code de la Promesse pour s'éxécuter.

    EX:
    let promise = new Promise(function(resolve, reject) {
      setTimeout(() => resolve("done!"), 1000);
    });

    // resolve runs the first function in .then
    promise.then(
      result => alert(result), // shows "done!" after 1 second
      error => alert(error) // doesn't run
    );

    EX:
    let promise = new Promise(function(resolve, reject) {
      setTimeout(() => reject(new Error("Whoops!")), 1000);
    });

    // reject runs the second function in .then
    promise.then(
      result => alert(result), // doesn't run
      error => alert(error) // shows "Error: Whoops!" after 1 second
    );

    EX:
    // If we’re interested only in successful completions, then we can provide only one function argument to .then
    let promise = new Promise(resolve => {
      setTimeout(() => resolve("done!"), 1000);
    });

    promise.then(alert); // shows "done!" after 1 second

Chaînage des promesses avec then()
La méthode then() renvoie un objet Promise, ce qui permet d'enchaîner les opération.

    EX:
    Promise.resolve("toto")
      // 1. Première étape, on reçoit "toto" et on le concatène avec
      //    "truc", ce qui résoud la première étape puis on passe au
      //    deuxième then
      .then(function(string) {
        return new Promise(function(resolve, reject) {
          setTimeout(function() {
            string += 'truc';
            resolve(string);
          }, 1);
        });
      })
      // 2. Deuxième étape, on reçoit "tototruc" et on enregistre une
      //    fonction de rappel pour manipuler cette chaîne puis l'imprimer
      //    dans la console. Avant cela, on passe la chaîne intacte au
      //    prochain then
      .then(function(string) {
        setTimeout(function() {
          string += 'baz';
          console.log(string);
        }, 1)
        return string;
      })
      // 3. On affiche un message sur le code, celui-ci sera affiché
      //    avant que la chaîne soit traitée dans le bloc précédent
      //    qui agit comme un bloc asynchrone.
      .then(function(string) {
        console.log("Et voilà la dernière, qui risque d'arriver avant la 2e");

        // Ici, la chaîne n'aura pas le morceau 'baz' car la fonction
        // setTimeout retarde l'exécution du code.
        console.log(string);
    });

Lorsqu'une valeur est simplement renvoyée depuis une fonction lambda then, celle-ci renverra Promise.resolve(<la valeur renvoyée par le gestionnaire appelé>).

    EX:
    var p2 = new Promise(function(resolve, reject) {
      resolve(1);
    });

    p2.then(function(valeur) {
      console.log(valeur); // 1
      return valeur + 1;
      }).then(function(valeur) {
      console.log(valeur + "- cette utilisation synchrone est un peu inutile");
      // 2- cette utilisation synchrone est un peu inutile
    });

    p2.then(function(valeur) {
      console.log(valeur); // 1
    });

Appeler then() renverra une promesse rompue si la fonction lève une exception ou si elle renvoie une promesse rompue.

    EX:
    Promise.resolve()
      .then( () => {
        // Ici .then() lève une exception
        throw 'Oh zut :( !';
      })
      .then( () => { 
        console.log( "Ceci n'est pas appelé." );
      }, raison => {
        console.error( 'la fonction siRompue est appelée : ' + raison  );
    });

Dans tous les autres cas, un promesse de résolution est renvoyée. Dans l'exemple qui suit, le premier then() renvoie 42 même si la promesse précédente a été rompue

    EX:
    Promise.reject()
      .then( () => 99, () => 42 ) // la valeur 42 est renvoyée dans une promesse
      .then( solution => console.log( 'Résolue avec ' + solution ) ); // Résolue avec 42

En pratique, il est souvent préférable d'attraper les promesses rompues plutôt que d'utiliser la syntaxe de then() avec deux fonctions

    EX:
    Promise.resolve()
      .then( () => {
        // .then() renvoie une promesse rompue
        throw 'Oh zut !';
      })
      .catch( raison => {
        console.error( 'fonction siRompue appelée : ' + raison );
      })
      .then( () => {
        console.log("Je suis toujours appelée, même si il y a un souci avant");
      });

Le chaînage peut également être utilisé pour implémenter une fonction utilisant une API basée sur les promesses et encapsuler une autre fonction

    EX:
    function fetch_current_data() {
      // L'API fetch renvoie une promesse. Cette fonction
      // expose une API similaire mais lorsque la promesse
      // est tenue, on effectue plus de tâches
      return fetch("current-data.json").then((response) => {
        if (response.headers.get("content-type") != "application/json") {
          throw new TypeError();
        }
        var j = response.json();
        // on peut ici manipuler j si besoin
        return j; // la valeur fournie à l'utilisateur de
                  // fetch_current_data().then()
      });
    }

Si le gestionnaire siTenue renvoie une promesse, la valeur de retour de then() sera alors résolue/rompue par cette promesse.

    EX:
    function resoudrePlusTard(resolve, reject) {
      setTimeout(function () {
        resolve(10);
      }, 1000);
    }
    function romprePlusTard(resolve, reject) {
      setTimeout(function () {
        reject(20);
      }, 1000);
    }

    var p1 = Promise.resolve("toto");
    var p2 = p1.then(function() {
      // On renvoie une nouvelle promesse
      // qui sera résolue avec la valeur 10
      // au bout d'une seconde
      return new Promise(resoudrePlusTard);
    });
    p2.then(function(v) {
      console.log("tenue", v);  
      // "tenue", 10
    }, function(e) {
      // ceci n'est pas appelé
      console.log("rompue", e);
    });

    var p3 = p1.then(function() {
      // Ici, on renvoie une promesse
      // qui sera rompue avec la valeur
      // 20 au bout d'une seconde
      return new Promise(romprePlusTard);
    });
    p3.then(function(v) {
      // ceci n'est pas appelé
      console.log("tenue", v);
    }, function(e) {
      console.log("rompue", e);
      // "rompue", 20
    });

Une fonction loadscript avec des promesses

    EX:
    function loadScript(src) {
      return new Promise(function(resolve, reject) {
        let script = document.createElement('script');
        script.src = src;

        script.onload = () => resolve(script);
        script.onerror = () => reject(new Error(`Script load error for ${src}`));

        document.head.append(script);
      });
    }

    // Usage
    let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");
    promise.then(
      script => alert(`${script.src} is loaded!`),
      error => alert(`Error: ${error.message}`)
    );
    promise.then(script => alert('Another handler...'));

    // Chaînage
    loadScript("/article/promise-chaining/one.js")
      .then(script => loadScript("/article/promise-chaining/two.js"))
      .then(script => loadScript("/article/promise-chaining/three.js"))
      .then(script => {
        // scripts are loaded, we can use functions declared in scripts
        one();
        two();
        three();
      });

Thenables objects
To be precise, a handler may return not exactly a promise, but a so-called “thenable” object.
an arbitrary object that has method .then, and it will be treated the same way as a promise.
The idea is that 3rd-party libraries may implement “promise-compatible” objects of their own. 
They can have extended set of methods, but also be compatible with native promises, because they implement .then.

    EX:
    class Thenable {
      constructor(num) {
        this.num = num;
      }
      then(resolve, reject) {
        alert(resolve); // function() { native code }
        // resolve with this.num*2 after the 1 second
        setTimeout(() => resolve(this.num * 2), 1000); // (**)
      }
    }

    new Promise(resolve => resolve(1))
      .then(result => {
        return new Thenable(result); // (*)
      })
      .then(alert); // shows 2 after 1000ms

    // JavaScript checks the object returned by .then handler in the line (*): if it has a callable method named then, 
    // then it calls that method providing native functions resolve, reject as arguments (similar to executor) and waits until one of them is called. 
    // In the example above resolve(2) is called after 1 second (**). Then the result is passed further down the chain.

This feature allows to integrate custom objects with promise chains without having to inherit from Promise.

3.2 catch

If we’re interested only in errors, then we can use null as the first argument: .then(null, errorHandlingFunction). 
Or we can use .catch(errorHandlingFunction), which is exactly the same

    EX:
    let promise = new Promise((resolve, reject) => {
      setTimeout(() => reject(new Error("Whoops!")), 1000);
    });
    
    promise.catch((error) => alert(error.message)); // shows "Error: Whoops!" after 1 second
    // .catch(f) is the same as promise.then(null, f)

3.3 finally

La méthode finally peut être utile si on souhaite effectuer un traitement ou du nettoyage (fermetures de flux, libération de ressources, etc.) 
une fois qu'une promesse est résolue, quel que soit l'état de la résolution (tenue ou rejetée).
finally ne recevra pas d'argument car on ne peut pas savoir si la promesse a été tenue ou rompue. 
Cette fonction est précisément appelée lorsqu'on ne s'intéresse pas à la raison du rejet ou à la réussite de la promesse. Une telle valeur est donc superflue.

    EX:
    let isLoading = true;

    fetch(myRequest).then(function(response) {
        var contentType = response.headers.get("content-type");
        if(contentType && contentType.includes("application/json")) {
          return response.json();
        }
        throw new TypeError("Oups, ceci n'est pas du JSON !");
    })
    .then(function(json) { /* traiter le JSON */ })
    .catch(function(error) { console.log(error); 
       /* La ligne précédent peut aussi déclencher une 
          erreur (si console vaut {} par exemple) */
    })
    .finally(function() { isLoading = false; });





4. Async & Await
L'ES2017 propose en draft une amélioration du système de promesses avec la création de fonction asynchrones.

    Ex1:
    let ajax = function (url) {
      // On renvoie une promesse qui prend en paramettre une fonction 
      // avec 2 paramètres, le callback de succès et d'erreur
      return new Promise(function (resolve, reject) {
        // Le reste du code ressemble à la méthode précédente
        let req = new XMLHttpRequest()
        req.open('GET', url, true)
        req.onreadystatechange = function (aEvt) {
          if (req.readyState == 4) {
            if(req.status == 200)
              resolve(req.responseText)
            else
              reject(req)
          }
        };
        req.send(null)
      })
    }
    // Une fonction qui renvoie une promesse peut être marqué comme "async"
    // Elle peut alors attendre la résolution d'une autre promesse avec "await"
    let getPost = async function () {
      // Plutot que d'utiliser le then on peut attendre la résolution
      let response = await ajax('https://jsonplaceholder.typicode.com/posts')
      // Return permettra le resolve de la promesse
      return JSON.parse(response) 
      // Un throw permettra de reject la promesse
    }
    // Cette fonction s'utilise comme précédemment
    getPost().then(posts => {
      console.log(posts)
    }).catch(error => { })

    Ex2:
    let ajax = function (url) {
      // On renvoie une promesse qui prend en paramettre une fonction 
      // avec 2 paramètres, le callback de succès et d'erreur
      return new Promise(function (resolve, reject) {
        // Le reste du code ressemble à la méthode précédente
        let req = new XMLHttpRequest()
        req.open('GET', url, true)
        req.onreadystatechange = function (aEvt) {
          if (req.readyState == 4) {
            if(req.status == 200)
              resolve(req.responseText)
            else
              reject(req)
          }
        };
        req.send(null)
      })
    }
    let getPosts = async function () {
      let response = await ajax('https://jsonplaceholder.typicode.com/users')
      let users = JSON.parse(response)
      response = await ajax(`https://jsonplaceholder.typicode.com/comments?usersId=${user[0].id}`)
      let posts = JSON.parse(response)
      return posts
    }
    let getFirtPost = async function () {
       let posts = await getPosts()
       return posts[0]
    }
    getFirtPost().then(function(post) {
      console.log(post)
    }).catch(function(error) {
      console.log(error)
    }).then(function() {
      console.log('Fin des requêtes AJAX')
    })


Fetch API
-------------------------------
1. Fetch est une nouvelle API qui vient remplacer XMLHttpRequest avec un support natif des Promesses.

    Ex1:
    const getUsers = async function() {
      try {
        let response = await fetch(https://jsonplaceholder.typicode.com/users)
        if (response.ok) {
          let data = await response.json()
            console.log(data)          
        } else {
          console.error(`Retour du serveur : `${response.status})
        }
      } catch(e) {
        console.log(e)
      }
    }
    const insertPost = async function(data) {
      let response = await fetch(https://jsonplaceholder.typicode.com/posts), {
        method: 'POST',
        headers: {
        'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
      let responseData = await response.json()
    }
    insertPost({
      name:Jean,
      age:29
    })

    Ex2:
    // Validation AJAX d'un formulaire avec fetch
    let form = document.querySelector('#contact')
    let button = form.querySelector('button[type=submit]')
    let buttonText = button.textContent
    form.addEventListener('submit', async function (e) {
      button.disabled = true
      button.textContent = 'Chargement...'
      let errorElements = form.querySelectorAll('.has-error')
      for (let i = 0; i < errorElements.length; i++) {
        errorElements[i].classList.remove('has-error')
        let span = errorElements[i].querySelector('.help-block')
        if (span) {
          span.parentNode.removeChild(span)
        }
      }
      e.preventDefault()
      let data = new FormData(form)
      try {
        let response = await fetch(form.getAttribute('action'), {
          method: 'POST',
          headers: {
            'X-Requested-With': 'xmlhttprequest'
          },
          body: data
        })
        let responseData = await response.json()
        // La réponse n'est pas bonne (pas 200), on affiche les erreurs
        if (!response.ok) {
          let errors = responseData
          let errorsKey = Object.keys(errors)
          for (let i = 0; i < errorsKey.length; i++) {
            let key = errorsKey[i]
            let error = errors[key]
            let input = document.querySelector('[name=' + key + ']')
            let span = document.createElement('span')
            span.className = 'help-block'
            span.innerHTML = error
            input.parentNode.classList.add('has-error')
            input.parentNode.appendChild(span)
          }
        // La réponse est ok, on vide le formulaire
        } else {
          let inputs = form.querySelectorAll('input, textarea')
          for (let i = 0; i < inputs.length; i++) {
            inputs[i].value = ''
          }
          alert('Merci pour votre message')
        }
      } catch (e) {
        alert(e)
      }
      // Dans tous les cas on permet la soumission du formulaire à nouveau
      button.disabled = false
      button.textContent = buttonText
    })

2. Fetch retourne une promesse qui résoud un objet Response, représentant la réponse de votre requête.
Voir https://developer.mozilla.org/fr/docs/Web/API/WindowOrWorkerGlobalScope/fetch
Voir https://developer.mozilla.org/en-US/docs/Web/API/Response
Voir https://javascript.info/fetch

3. Response implémente Body, la méthode json() de Body lit un Stream Response jusqu'au bout. 
It returns a promise that resolves with the result of parsing the body text as JSON.

    EX:
    response.json().then(function(data) {
      // faire quelque chose avec les données
    });

    EX:
    var myList = document.querySelector('ul');

    var myRequest = new Request('products.json');

    fetch(myRequest)
      .then(function(response) { return response.json(); })
      .then(function(data) {
        for (var i = 0; i < data.products.length; i++) {
          var listItem = document.createElement('li');
          listItem.innerHTML = '<strong>' + data.products[i].Name + '</strong> can be found in ' +
                               data.products[i].Location +
                               '. Cost: <strong>£' + data.products[i].Price + '</strong>';
          myList.appendChild(listItem);
        }
      });

    EX:
    const getUsers = async function() {
      try {
        let response = await fetch(https://jsonplaceholder.typicode.com/users)
        if (response.ok) {
          let data = await response.json()
            console.log(data)          
        } else {
          console.error(`Retour du serveur : `${response.status})
        }
      } catch(e) {
        console.log(e)
      }
    }
    

AJAX
-------------------------------
1. L'Ajax permet d'appeller une page en JavaScript et de récupérer les informations 
afin d'effectuer un traitement particulier.
Le point d'entré de l'Ajax est l'utilisation d'un objet spécifique : XMLHttpRequest. 
Malheureusement cet objet n'est pas disponible dans tous les navigateur et il est donc conseillé d'utiliser une fonction pour générer l'objet dont on va avoir besoin.

    Ex1:
    var getHttpRequest = function () {
      var httpRequest = false;
      if (window.XMLHttpRequest) { // Mozilla, Safari,...
        httpRequest = new XMLHttpRequest();
        if (httpRequest.overrideMimeType) {
          httpRequest.overrideMimeType('text/xml');
        }
      }
      else if (window.ActiveXObject) { // IE
        try {
          httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
        }
        catch (e) {
          try {
            httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
          }
          catch (e) {}
        }
      }
      if (!httpRequest) {
        alert('Abandon :( Impossible de créer une instance XMLHTTP');
        return false;
      }
      return httpRequest
    }
    var xhr = getHttpRequest()
    xhr.open('GET', 'https://jsonplaceholder.typicode.com/users', true)
    // On envoit un header pour indiquer au serveur que la page est appellée en Ajax
    xhr.setRequestHeader('X-Requested-With', 'xmlhttprequest')
    // On lance la requête
    xhr.send()
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
            console.log(xhr.responseText) // xhr.responseText contient le résultat de la page
        } else {
            alert('Impossible de contacter le serveur')// Le serveur a renvoyé un status d'erreur
        }
      }
    }

2. Si vous souhaitez soumettre des informations vous pouvez utiliser l'objet FormData

    Ex1:
    var data = new FormData() 
    data.append('name', 'John Doe')
    data.append('email, 'contact@local.dev')

    var xhr = getHttpRequest()
    xhr.open('POST', 'http://localhost/demo.php', true)
    xhr.setRequestHeader('X-Requested-With', 'xmlhttprequest')
    xhr.send(data)

    Ex2:
    // si l'on veut poster un formulaire
    var form = document.querySelector('#form')
    var data = new FormData(form) 

    var xhr = getHttpRequest()
    xhr.open('POST', 'http://localhost/demo.php', true)
    xhr.setRequestHeader('X-Requested-With', 'xmlhttprequest')
    xhr.send(data)

3. Ajax + JSON 
Le problème lorsque l'on appelle la page est que l'on récupère les informations sous forme 
de chaine de caractères. Le problème est que parfois on souhaite transmettre des informations plus complexes. Dans ce cas là on utilisera la format JSON. 
Ce format à l'avantage d'être facilement compréhensible en JavaScript.

    Ex1:
    var test = 'UN TRUC EN JSON'
    var items = JSON.parse(test)

4. Limitation et CORS
Attention, on ne peut pas appeler une page provenant d'un domaine différent. 
Si on souhaite appeller une page différente de la page en cours, il faudra que le serveur dispose du CORS.


Les modules JavaScript import / export
-------------------------------
Voir https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules
Voir https://medium.com/@etherealm/named-export-vs-default-export-in-es6-affb483a0910


Memoization
-------------------------------
1. Une fonction mémoïsée stocke les valeurs retournées par ses appels précédents dans une structure de données adaptée et, lorsqu'elle est appelée à nouveau avec les mêmes paramètres, renvoie la valeur stockée au lieu de la recalculer. Une fonction peut être mémoïsée seulement si elle est pure, c'est-à-dire si sa valeur de retour ne dépend que de la valeur de ses arguments.

    Ex1:
    // A simple function to add something
    const add = (n) => (n + 10);
    add(9);

    // A simple memoized function to add something
    let cache = {};
    const memoizedAdd = (n) => {
        
        if (n in cache) {
            console.log('Fetching from cache');
            return cache[n];
        }
        else {
            console.log('Calculating result');
            let result = n + 10;
            cache[n] = result;
            return result;        
        }
    }
   
    console.log(cache);
    console.log(memoizedAdd(9)); // Calculating result   
    console.log(memoizedAdd(9)); // Fetching from cache
    console.log(memoizedAdd(20)); // Calculating result    
    console.log(memoizedAdd(20)); // Fetching from cache
    console.log(cache);


Les valeurs évaluées à false
-------------------------------
1. C'est 6 valeurs sont évaluées à false dans une condition.
    
    Ex1:
    0 ? "Vrai" : "Faux" // "Faux"
    undefined ? "Vrai" : "Faux" // "Faux"
    null ? "Vrai" : "Faux" // "Faux"
    NaN ? "Vrai" : "Faux" // "Faux"
    '' ? "Vrai" : "Faux" // "Faux"
    false ? "Vrai" : "Faux" // "Faux"

2. In JavaScript, the values false, null, undefined, 0, -0, NaN, and '' (empty string) are "falsy" values. 
All other values are "truthy." 

3. L'opérateur !! (Double bang)
! is the logical negation or "not" operator. !! is ! twice. It's a way of casting a "truthy" or "falsy" value to true or false, respectively. 
Given a boolean, ! will negate the value, i.e. !true yields false and vice versa. Given something other than a boolean, the value will 
first be converted to a boolean and then negated. For example, !undefined will first convert undefined to false and then negate it, yielding true. 
Applying a second ! operator (!!undefined) yields false, so in effect !!undefined converts undefined to false.

    Ex1:
    // Here's a truth table of ! and !! applied to various values
    value     | !value | !!value
    -----------+--------+-------
     false     | true   | false
     true      | false  | true
     null      | true   | false
     undefined | true   | false
     0         | true   | false
     -0        | true   | false
     1         | false  | true
     -5        | false  | true
     NaN       | true   | false
     ''        | true   | false
     'hello'   | false  | true


Hashtable / Hashmap  vs Array (Data Normalization)
-------------------------------
1. La table de hachage (HashMap) est une structure indispensable de données classiques dans la programmation d'applications.
(voir https://fr.wikipedia.org/wiki/Table_de_hachage)
C'est tellement omniprésent que pratiquement tous les langages modernes la supportent grâce à leur bibliothèque, 
ou en intégrant les fonctionnalités dans la syntaxe elle-même. Les tables de hachage sont souvent implémentées sous forme de tableau associatif.
Une HashMap fournit l'accès permanent à une valeur via une clé unique. 
La méthode la plus commune en JavaScript est d'utiliser un objet littéral comme une HashMap.
Notez que le traitement d'un objet littéral comme une HashMap est la même syntaxe que l'accès normal à la propriété et à sa manipulation. 
Nous pouvons tirer parti du langage lui-même comme d'une structure de données.

    Ex1:
    var map = {};
    // notation par point
    map.foo = "bar";
    console.log(map.foo); // "bar"

    // notation par crochets
    map["foo"] = "bar";
    console.log(map["foo"]); // "bar"

    // un mélange des deux
    map.foo = "bar";
    console.log(map["foo"]); // "bar"

    Ex2:
    // Avec une Hashmap
    // On crée l'objet littéral
    var myData = new Object();     
    // On stocke les clés/valeurs dans l'objet 
    myData["The Beatles"] ="248.3";
    myData["Elvis Presley"] ="201.2";
    myData["Michael Jackson"] ="155.8";
    myData["Madonna"] ="157.8";
    myData["Elton John"] ="153";
    myData["Led Zeppelin"] ="133.4";
    myData["Queen"] ="88.2";
    myData["ABBA"] ="54.4";
    myData["Mariah Carey"] ="118.2";
    myData["Celine Dion"] ="111.4";
    myData["Pink Floyd"] ="110.1";
    myData["AC/DC"] ="99.3";
    myData["The Rolling Stones"] ="89.5";
    myData["Bee Gees"] ="63.2";
    // On récupère une donnée
    alert(myData["ABBA"]);

    // Avec un tableau
    var myData = []; 
    myData.push(["The Beatles", "248.3"]);
    myData.push(["Elvis Presley", "201.2"]);
    myData.push(["Michael Jackson", "155.8"]);
    myData.push(["Madonna", "157.8"]);
    myData.push(["Elton John", "153"]);
    myData.push(["Led Zeppelin", "133.4"]);
    myData.push(["Queen", "88.2"]);
    myData.push(["ABBA", "54.4"]);
    myData.push(["Mariah Carey", "118.2"]);
    myData.push(["Celine Dion", "111.4"]);
    myData.push(["Pink Floyd", "110.1"]);
    myData.push(["AC/DC", "99.3"]);
    myData.push(["The Rolling Stones", "89.5"]);
    myData.push(["Bee Gees", "63.2"]);
     
    var artist = "The Rolling Stones";     
    for (var i = 0; i < myData.length; i++) {
        if (myData[i][0] == artist) {
        alert("Sales for " + artist + " is " + myData[i][1]);
    }

2. L'ordre des clés n'est pas garanti avec une HashMap basique.

    Ex1:
    var map = {
        key1 : "one",
        key2 : "two",
        key3 : "three",
    };

    // récupérer toutes les valeurs
    var values = [];
    for (var key in map) {
     if (map.hasOwnProperty(key)) {
       values.push(map[key]);
    }

    // l'ordre des clés n'est pas garanti avec une HashMap basique
    // et chaque navigateur a son implémentation
    console.log(values.join(',')); // "two,three,one"

3. Pour conserver l'ordre d'insertion en sortie il faut utiliser une classe LinkedHashMap qui est synchronisée avec une liste doublement chaînée
(voir https://fr.wikipedia.org/wiki/Liste_cha%C3%AEn%C3%A9e)

    Ex1:
    var map = new LinkedHashMap();

    map.put("key1", "one");
    map.put("key2", "two");
    map.put("key3", "three");

    // l'ordre retournée est maintenant prévisible
    console.log(map.keys().join(',')); // "key1,key2,key3"
    console.log(map.values().join(',')); // "one,two,three"

4. En Data Normalization, si l'on doit récupérer un élément individuel contenu dans une liste selon une clé,
il vaut mieux stocker les données dans une hashmap plutôt qu'un tableau car dans un tableau il faut 
parcourir tout le tableau à partir de l'index 0 jusqu'à trouver la bonne clé et plus le tableau est long plus ça prend du temps alors que dans une hashmap
c'est quasi instantané quelquesoit la taille de la liste


Pattern Observable / Observer
-------------------------------
1. On utilise le pattern Observable / Observer quand on doit gérer des évenements.

2. Les Promise ne permettent pas de traiter de la donnée au fur et à mesure de son arrivée : elle est remplie une seule fois,
alors que les observables peuvent le gérer.

3. Un Observable fonctionne à la fois pour du code synchrone et asynchrone, et il s'agit d'un pattern qui peut s'appliquer 
à des cas où Promise manque de granularité, puisqu'il permet de traiter la donnée au fur et à mesure de son arrivée.

3. Un Observable est un objet implémentant une méthode .subscribe qui prend comme paramètre un Observer. Ce dernier a cette forme :
    const observer = {
      next: val => console.log(val), // une fonction à exécuter à chaque nouvel évenement
      error: err => console.error(err), // une fonction à exécuter en cas d'erreur
      complete: () => console.info("Complete!") // une fonction à exécuter lorsque l'observable a fini
    };

    EX:
    // Observable qui va réagir lorsqu'un user va taper sur son clavier et se considérer terminé une fois Enter pressé

    const KeyboardObservable = {
      subscribe: observer => {
        const handleKeyUp = event => {
          if (typeof event.keyCode === "number") {
            if (event.keyCode === 13 /* Enter */) {
              document.removeEventListener("keyup", handleKeyUp);
              observer.complete();
            } else {
              observer.next(event.keyCode);
            }
          } else {
            observer.error(new Error("No keyCode found"));
          }
        };
        document.addEventListener("keyup", handleKeyUp);
        // subscribe retourne la "soucription", contenant une fonction pour la stopper
        return {
          unsubscribe: () => document.removeEventListener("keyup", handleKeyUp)
        };
      }
    };

    let keys = [];
    KeyboardObservable.subscribe({
      next: keyCode => keys.push(String.fromCharCode(keyCode)),
      error: error => console.error(error),
      complete: () => alert(keys.join(""))
    });


Regression d'une application
-------------------------------
1. Une régression est un défaut introduit dans un logiciel à l'occasion de corrections de bogues ou n'importe quel changement établi dans un logiciel : 
ajout de nouvelles fonctionnalités, modification de fonctionnalités existantes ou modification d'un composant externe au logiciel lui-même : 
nouvelle version du système, de l'interface graphique, d'un compilateur ou d'une bibliothèque tierce qui interviennent dans son fonctionnement. 
La régression fonctionnelle est donc un bug informatique qui entraîne un retour en arrière non désiré et préjudiciable sur une fonctionnalité qui marchait avant. 
Elle menace le bon fonctionnement du logiciel, ce qu'il est important d'éviter ; on effectue à cette fin des tests de régression. 
Il est également courant de parler de tests de non-régression, ou TNR

2. Voir https://fr.wikipedia.org/wiki/Test_de_r%C3%A9gression


Les différents types de tests
-------------------------------
1. Unit tests (tests unitaires)
Permettent de tester des fonctions individuellement ou des classes et de voir
si elles font bien ce qu'on leur demande. Les fonctions testées doivent être pures.


2. Integrations tests
Permettent de tester si des morceaux de codes fonctionnent bien ensembles.
Comme une application express avec les appels à la bdd par exemple ou
un fonction avec une autre fonction.

3. Automation tests ou UI test
Permettent de tester l'interaction utilisateur de l'application dans le navigateur par exemple
et de voir si l'application réagit comme attendue. Ces test peuvent être fait par un être humain
ou des robots qui simule les interactions utilisateur programmatiquement.


Les tests avec JEST
-------------------------------
1. L'installation se fait simplement à l'aide de votre paquets. Vous pouvez aussi installer les fichiers de déclarations pour aider votre éditeur.
    EX:
    npm install -D jest @types/jest

2. Vous pouvez aussi en profiter pour créer un fichier de configuration automatiquement avec la commande.
    EX:
    npx jest --init

3. Pour lancer les tests il vous suffit ensuite d'utiliser la commande jest ou d'utiliser le script test (si vous avez choisi de l'ajouter à votre package.json).
Cette commande cherchera les fichiers se terminant par .test.js ou se trouvant dans le dossier __tests__ et essaiera de les éxécuter.
    EX:
    npx jest

4. Jest intègre l'ensemble des fonctions nécessaires aux test.

5. Les fonctions basiques.
describe() pour définir un scénario (un ensemble de tests dans un même domaine)
it() ou test() pour décrire un test
expect() pour gérer les assertions (les résultats attendus)

6. Les matchers d'égalité
    EX:
    // toBe est à utiliser seulement pour les types primitifs, il équivaut à tester ===
    it('two plus two is four', () => {
      expect(2 + 2).toBe(4); // toBe(4) est un matcher 
    });

    // toEqual teste l'égalité des propriétés et valeurs d'un objet ou d'un tableau et pas simplement l'égalité des références.
    it('object assignment', () => {
      const data = {one: 1};
      data['two'] = 2;
      expect(data).toEqual({one: 1, two: 2}); // toEqual({one: 1, two: 2}) est un matcher
    });

    // not devant un matcher permet de tester l'opposé d'un matche
    it('adding positive numbers is not zero', () => {
      for (let a = 1; a < 10; a++) {
        for (let b = 1; b < 10; b++) {
          expect(a + b).not.toBe(0); // .not.toBe(0) est l'opposé du matcher toBe(0)
        }
      }
    });

7. Les matchers pour null, undefined, false, true.
toBeNull matches only null
toBeUndefined matches only undefined
toBeDefined is the opposite of toBeUndefined
toBeTruthy matches anything that an if statement treats as true
toBeFalsy matches anything that an if statement treats as false
    EX:
    it('null', () => {
      const n = null;
      expect(n).toBeNull();
      expect(n).toBeDefined();
      expect(n).not.toBeUndefined();
      expect(n).not.toBeTruthy();
      expect(n).toBeFalsy();
    });

    it('zero', () => {
      const z = 0;
      expect(z).not.toBeNull();
      expect(z).toBeDefined();
      expect(z).not.toBeUndefined();
      expect(z).not.toBeTruthy();
      expect(z).toBeFalsy();
    });

8. Les matchers pour les nombres.
    EX:
    it('two plus two', () => {
      const value = 2 + 2;
      expect(value).toBeGreaterThan(3);
      expect(value).toBeGreaterThanOrEqual(3.5);
      expect(value).toBeLessThan(5);
      expect(value).toBeLessThanOrEqual(4.5);

      // toBe and toEqual are equivalent for numbers
      expect(value).toBe(4);
      expect(value).toEqual(4);
    });

    // Pour les égalités de nombres à virgule il faut utiliser toBeCloseTo à la place de toEqual
    it('adding floating point numbers', () => {
      const value = 0.1 + 0.2;
      //expect(value).toBe(0.3); // This won't work because of rounding error
      expect(value).toBeCloseTo(0.3); // This works.
    });

9. Les matchers pour les chaînes de caractères
    EX:
    // Avec une expression régulière.
    it('there is no I in team', () => {
      expect('team').not.toMatch(/I/);
    });

    it('but there is a "stop" in Christoph', () => {
      expect('Christoph').toMatch(/stop/);
    });

10. Les matchers pour les tableaux et itérables
    EX:
    // Vérifie si un tableau ou un itérabble contient un item particulier
    const shoppingList = [
      'diapers',
      'kleenex',
      'trash bags',
      'paper towels',
      'beer',
    ];

    it('the shopping list has beer on it', () => {
      expect(shoppingList).toContain('beer'); 
      expect(new Set(shoppingList)).toContain('beer');
    });

11. Les matchers pour les exceptions
    EX:
    // Vérifie si une exception est lancée par une fonction quand elle est appelée
    function compileAndroidCode() {
      throw new Error('you are using the wrong JDK');
    }

    it('compiling android goes as expected', () => {
      expect(compileAndroidCode).toThrow();
      expect(compileAndroidCode).toThrow(Error);

      // You can also use the exact error message or a regexp
      expect(compileAndroidCode).toThrow('you are using the wrong JDK');
      expect(compileAndroidCode).toThrow(/JDK/);
    });

    EX:
    function drinkFlavor(flavor) {
      if (flavor == 'octopus') {
        throw new DisgustingFlavorError('yuck, octopus flavor');
      }
      // Do some other stuff
    }

    it('throws on octopus', () => {
      function drinkOctopus() {
        drinkFlavor('octopus');
      }

      // Test that the error message says "yuck" somewhere: these are equivalent
      expect(drinkOctopus).toThrowError(/yuck/); // toThrowError est un alias de toThrow
      expect(drinkOctopus).toThrowError('yuck');

      // Test the exact error message
      expect(drinkOctopus).toThrowError(/^yuck, octopus flavor$/);
      expect(drinkOctopus).toThrowError(new Error('yuck, octopus flavor'));

      // Test that we get a DisgustingFlavorError
      expect(drinkOctopus).toThrowError(DisgustingFlavorError);
    });

12. Voir https://jestjs.io/docs/en/expect pour voir l'ensemble des matchers.

14. Tester des fonctions asynchrones
    EX:
    describe('Timer', function () {
      // Mettre async à la fonction callback de it et utiliser await dans la fonction    
      it.concurrent('should wait 3 seconds', async function () { // .concurrent permet de lancer des tests en parallèles.
        const t = Date.now()
        await sleep(3)
        expect(Date.now() - t).toBeGreaterThanOrEqual(3000)
      })

      it.concurrent('should wait 2 seconds', async function () {
        const t = Date.now()
        await sleep(2)
        expect(Date.now() - t).toBeGreaterThanOrEqual(2000)
      })
    })

15. Utiliser des mock.
Vous pouvez aussi créer des mock pour tester vos fonctions sans dépendre des composants tiers. 
Par exemple, si vous voulez tester une fonction de votre bot Discord il faut être capable de simuler les opérations.
Pour créer un mock il suffit d'utiliser la fonction Jest.fn(), cette fonction renvoie un mock qui est 
une fonction qui renvoie undefined si appellée. Il est possible ensuite d'inspecter les appels et de modifier les valeurs de retour si nécessaire.
    EX:
    // La fonction à tester
    export async function ping(message) {
        message.delete().catch(console.error)
        return message.author.createDM()
            .then(ch => ch.send('pong'))
            .catch(() => message.reply('pong'))
    }

    // On importe le fonction ping à tester
    import {ping} from '../src/discord.js'

    // On crée un groupe de tests
    describe('Discord', function () {

      it('should dm the user', async function () {
        // On crée un faux objet channelMock
        const channelMock = {
          send: jest.fn()
        }

        // On crée une fausse fonction createDMMock qui renvoie une promesse
        // résolue avec un objet channelMock
        const createDMMock = jest.fn().mockResolvedValue(channelMock)

        // On crée un faux objet message avec des fonction mock
        const message = {
          delete: jest.fn().mockResolvedValue({}),
          reply: jest.fn(),
          author: {
            createDM: createDMMock
          }
        }
        On passe le mock message à la vrai fonction ping à tester
        await ping(message)

        // Le matcher .toHaveBeenCalled() permet de savoir si la méthode message.delete 
        // a bien été appelée.
        expect(message.delete).toHaveBeenCalled() 
      })

      it('should reply to the user if dm are deactivated', async function () {
        const createDMMock = jest.fn().mockRejectedValue({})
        const message = {
          delete: jest.fn().mockResolvedValue({}),
          reply: jest.fn(),
          author: {
            createDM: createDMMock
          }
        }
        await ping(message)

        // Le matcher .toHaveBeenCalled() permet de savoir si la méthode message.delete 
        // a bien été appelée.
        expect(message.delete).toHaveBeenCalled()

        // Le matcher .toHaveBeenCalledWith() permet de savoir si la méthode message.reply 
        // a bien été appelée avec l'argument 'pong'
        expect(message.reply).toHaveBeenCalledWith('pong')
      })
    })

    EX:
    import axios from 'axios'

    export default {
        async getLastUsername() {
            let users = await axios.get('https://jsonplaceholder.typicode.com/users')
            return users.data[0].name
        },
        async getLastUsernameFetch() {
            let users = await fetch('https://jsonplaceholder.typicode.com/users')
                .then(r => r.json())
            return users.data[0].name
        }
    }

    import Users from '../src/users.js'
    import axios from 'axios'

    // On mock axios c'est-à-dire que toute les méthodes d'axios renverront undefined
    jest.mock('axios')

    describe('Users', function () {
      // beforeEach, permet de lancer ces traitement avant chaque test.
      beforeEach(() => {
        // On reset le mock d'axios avant chaque test
        axios.mockClear()
      })

      const fakeResponse = [{name: 'John Doe'}]

      it ('should return last user', async () => {
        // On mock la méthode get d'axios pour qu'elle renvoie une promesse résolue
        // avec un objet ayant une propriété data égale à fakeResponse
        axios.get.mockResolvedValue({data: fakeResponse})

        // On attend de la fonction getLastUserName() qu'elle nous renvoie 'John Doe'
        expect(await Users.getLastUserName()).toBe('John Doe')
      })

      // Pour mocker fetch il faut installer jest-fetch-mock (https://www.npmjs.com/package/jest-fetch-mock)
      it ('should return last user with fetch', async () => {
        // On souhaite que le mock de fetch nous renvoie une chaîne au format JSON
        // à partir de l'objet fakeResponse
        fetch.mockResponseOnce(JSON.stringify(fakeResponse))

        // On attend de la fonction getLastUserNameFetch() qu'elle nous renvoie 'John Doe'
        expect(await Users.getLastUserNameFetch()).toBe('John Doe')
      })
    })

16. Les drapeaux utiles
afterAll(fn, timeout)
afterEach(fn, timeout)
// Runs a function before any of the tests in this file run. 
// If the function returns a promise or is a generator, 
// Jest waits for that promise to resolve before running tests.
beforeAll(fn, timeout) 
beforeEach(fn, timeout) // Permet de faire un traitement avant chaque test du fichier
describe(name, fn)
describe.each(table)(name, fn, timeout)
describe.only(name, fn)
describe.only.each(table)(name, fn)
describe.skip(name, fn)
describe.skip.each(table)(name, fn)
it(name, fn, timeout)
it.each(table)(name, fn, timeout)
it.only(name, fn, timeout) // Permet d'exécuter seulement ce test
it.only.each(table)(name, fn)
it.skip(name, fn) // Permet d'ignorer un test
it.skip.each(table)(name, fn)
it.todo(name)


17. Tester le DOM sans navigateur via JSDOM
Si votre librairie manipule le DOM il est possible de la tester sans forcément utiliser un navigateur. 
Pour cela Jest intègre jsdom qui implémente plusieurs standard web directement sur NodeJS.
Installer jest-dom pour ajouter des matchers liés au DOM (https://github.com/testing-library/jest-dom)
    EX:
    test('displays content after click', function () {

      document.body.innerHTML = `<div>Voici mon <span class="spoiler">contenu caché</span></div>`
      require('../src/spoiler.js')
      const spoilerButton = document.querySelector('.spoiler button')
      const spoilerText = document.querySelector('.spoiler span')

      expect(spoilerButton).not.toBeNull() // On vérifie qu'il y a bien un bouton qui a été créé dans le span .spoiler
      expect(spoilerText).not.toBeNull() // On vérifie qu'il y a bien un span qui a été créé dans le span .spoiler
      expect(spoilerText).not.toHaveClass('visible') // On vérifie que spoilerText n'a pas la class visible et donc qu'il n'est pas affiché
      spoilerButton.click() // On click sur le bouton créé
      expect(spoilerText).toHaveClass('visible') // On vérifie que spoilerText cette fois a bien la class visible et donc qu'il est bien affiché

    })

Fonctions pures
-------------------------------
1. Une fonction pure ne dépend pas et ne modifie pas l’état de variables hors de sa portée et ne pas change pas son environnement.
    EX:
    // Fonction pure
    let somme = (x, y) => {
      return x + y;
    }

    // Fonction impure car le résultat dépend de la variable b qui est hors de sa portée et n'est pas passée en paramètre.
    let b = 3
    let somme2 = (x, y) => {
      return x + y + b;
    }

    // Fonction impure car en utilisant console.log(“la somme est”) la fonction altère l’environnement.
    let somme3 = (x, y) => {
      console.log("la somme est ");
      return x + y;
    }

    // Fonction impure car en utilisant la fonction modifie une variable hors de sa portée qui n'est pas passée en paramètre.
    let b = 3
    let somme4 = (x, y) => {
      b = 4
      return x + y;
    }

2. En pratique, cela signifie qu’une fonction pure retourne toujours le même résultat avec des paramètres identiques.

3. L’avantage d’une fonction pure, c’est qu’elle n’a pas d’effets de bord. 
Elles ne modifient pas l’état du système en dehors de leur portée. 
Ainsi, elles simplifient et clarifient le code : quand on appelle une fonction pure, 
on peut se concentrer sur la valeur qu’elle retourne puisqu’on sait qu’elle ne va pas impacter le système en passant.

4. De même, il est très simple de tester une fonction pure puisqu’il n’y a pas de contexte considérer. 
Il suffit de se concentrer sur les entrées / sorties.

5. Une fonction pure est également robuste. Son ordre d’exécution n’a pas d’impact sur le système.

6. Enfin, maximiser le nombre de fonctions pures rend le code plus simple, plus flexible.

7. Simplifier le code en limitant le nombre de fonctions qui ont un impact sur l’état du système.
En s’efforçant à écrire un maximum de fonctions pures, en limitant le nombre de fonctions qui ne le sont pas, on se simplifie la vie !
En tout cas, c’est l’idée. Et souvent, en pratique, c’est surtout une question de design, de choix entre un get (pure) et un set (impure) par exemple.


Fonction à effet de bord (side effects)
-------------------------------
1. Une fonction est dite à effet de bord si elle modifie un état en dehors de son environnement local, 
c'est-à-dire a une interaction observable avec le monde extérieur autre que retourner une valeur ou
si elle appelle d'autres fonctions à effet de bord.

2. Les effets de bord peuvent être des appels sur un réseau ou à une bdd ou une api.


Debugger
-------------------------------
1. L'instruction debugger permet de faire appel à un outil de débogage (qui peut par exemple permettre de placer un point d'arrêt). 
Si cette fonctionnalité de débogage n'est pas disponible, l'instruction n'aura aucun effet.

2. Lors que le débogueur est lancé, l'exécution est interrompue au niveau de l'instruction debugger. 
Cela agit comme un point d'arrêt dans le code du script.*
    EX:
    function codeProbablementBogue() {
        debugger;
        // exécuter des instructions qu'on veut 
        // examiner, exécuter pas à pas etc.
    }


Assignation par défaut avec les opérateurs || et &&
-------------------------------
1. This is made to assign a default value.

2. The boolean operators in JavaScript can return an operand, 
and not always a boolean result as in other languages.

3. The Logical OR operator (||) returns the value of its second operand, if the first one is falsy, 
otherwise the value of the first operand is returned.
    EX:
    "foo" || "bar"; // returns "foo"
    false || "bar"; // returns "bar"

    EX:
    // props.className n'existe pas donc est falsy, l'opérateur || retourne ''
    // pour l'assigner à la variable className
    const className = props.className || '';


4. The Logical AND operator (&&)  Renvoie la première valeur si cette expression peut être convertie en false, sinon renvoie la seconde valeur.
    EX:
    "foo" && "bar"; // returns "bar"
    false && "bar"; // returns false


5. Si une valeur peut être convertie en true, on dit en anglais qu'elle est truthy. 
Pour false on dit qu'elle est falsy.
Parmi les expressions qui peuvent être converties en false, citons celles qui seront évaluées à :
null,
NaN,
0,
la chaîne vide ("" ou '' ou ``),
undefined


JSDoc
-------------------------------
voir https://gomakethings.com/whats-the-best-way-to-document-javascript/
voir https://jsdoc.app/
voir https://devdocs.io/jsdoc/

1. JSDoc est un langage de balisage utilisé pour documenter les codes sources Javascript. 
En utilisant des commentaires qui contiennent des informations pour JSDoc, les développeurs 
peuvent créer leur documentation de leurs interface de programmation (ou désigné par API en anglais) 
du code qu'ils créent. Ensuite, ces commentaires seront traités par différents outils (tel que JSDoc pour Node.js), 
pour produire leur documentation accessible par différents formats, tel que l'HTML ou 
le Rich Text Format (RTF, ou littéralement « format de texte enrichi »).

2. En tant que développeur vous écrivez du code qui doit être utilisé par d’autres et avoir une documentation limpide, 
qui se lit facilement. L’outil standart en Javascript pour générer de la documentation est JSDoc.
JSDoc permet de produire une documentation HTML avec la syntaxe de commentaire /** */


    ////////////////////////////////////// EX:
    /**
     * Crée une instance de Cercle
     * 
     * @constructor
     * @this {Cercle}
     * @param {number} r Le rayon désiré du cercle.
     */
     
    function Cercle(r) {
        /** @private */ this.rayon = r;
        /** @private */ this.circonference = 2 * Math.PI * r;
    };

    /**
     * Crée un nouveau cercle à partir du diamètre
     * 
     * @param {number} d Le diamètre désiré du cercle
     * @return {Cercle} Le nouvel objet Cercle
     */

    Cercle.aPartirDeDiametre = function (d) {
        return new Cercle(d / 2);
    };

    /**
     * Calcule la circonférence du Cercle.
     * 
     * @deprecated
     * @this {Cercle}
     * @return {number} La circonférence du cercle
     */

    Cercle.prototype.calculerCirconference = function() {
        return 2 * Math.PI * this.rayon;
    };

    /**
     * Retourne la circonférence du Cercle.
     * 
     * @this {Cercle}
     * @return {number} La circonférence du Cercle.
     */
    Cercle.prototype.getCirconference = function() {
        return this.circonference;
    }

    /**
     * Crée un texte représentant le Cercle.
     * 
     * @override
     * @this {Cercle}
     * @return {string} Une représentation lisible du Cercle.
     */
    Cercle.prototype.toString = function() {
        return "Un objet Cercle avec un rayon de " + this.rayon + ".";
    };

    ////////////////////////////////////// EX:
    /**
     * Toggle visibility of a content tab
     * @param  {String} selector Selector for the element
     * @param  {Node}   toggle   The element that triggered the tab
     */
    var toggleVisibility = function (selector, toggle) {

        // If there's no selector, bail
        if (!selector) return;

        // Get the tab to show
        var elem = document.querySelector(selector);
        if (!elem) return;

        // Show the element
        elem.classList.add('active');

        // If a toggle element was provided, add an .active class for styling
        if (toggle) {
            toggle.classList.add('active');
        }

        // Bring the newly visible element into focus
        elem.focus()

        // If elem.focus() didn't work, add tabindex="-1" and try again
        // (elements that aren't focusable by default need a tabindex)
        if (document.activeElement.matches(selector)) return;
        elem.setAttribute('tabindex', '-1');
        elem.focus();
    };


HTMLElement.dataset et les attributs data-*
-------------------------------
1. HTML5 permet d'associer des données directement dans un élément HTML à l'aide des attributs data-*.
HTML5 permet d'écrire librement tout attribut débutant par data- 
La page sera valide aux yeux du navigateur, en ayant pris la précaution d'utiliser le doctype HTML5 : <!DOCTYPE html>

2. On peut ainsi personnaliser la famille d'attributs débutant par data- en y concaténant une chaine de texte, 
à notre convenance (ici kiwi). Seules consignes : au moins un caractère et aucune majuscule. 
Il est bien sûr autorisé de cumuler plusieurs attributs data- sur un même élément.$*

    ////////////////////////////////////// EX:
    <element data-kiwi="info_associée"> ... </element>

3. L'intérêt principal est de simplifier le stockage des données dans le document directement dans un élément. 
Par exemple, dans une galerie d'images on peut stocker : le nom de l'auteur, le lieu... dans l'image elle-même, 
puis afficher ces informations au survol.

4. Les APIs destinées à manipuler les attributs data en JavaScript font partie de la spécification HTML5. 
La propriété dataset doit permettre d'interagir avec les données. Chaque attribut data devient lui-même 
membre de dataset (en omettant le préfixe data-).

    ////////////////////////////////////// EX:
    <img src="mamoto.jpg" alt="Une moto rouge" id="moto"
      data-auteur="Simon" data-lieu="Strasbourg"
      data-materiel="EOS" data-gps="48.582967,7.74828">

    <script>
    var monelement = document.getElementById('moto');

    // Lecture d'une valeur
    var auteur = monelement.dataset.auteur;

    // Modification d'une valeur
    monelement.dataset.gps = '49.04777,7.440491';

    // Suppression
    monelement.dataset.gps = null;
    </script>

5. L'API dataset n'est pas implémentée de façon universelle mais il est aisé de concevoir 
des alternatives en JavaScript. L'accès aux attributs, quels qu'ils soient, est déjà prévu, 
donc il suffit de s'adresser spécifiquement à ceux débutant par data- avec les fonctions natives 
getAttribute et setAttribute qui fonctionnent sur la majorité des navigateurs.

    ////////////////////////////////////// EX:
    <img src="mamoto.jpg" alt="Une moto rouge" id="moto"
      data-auteur="Simon" data-lieu="Strasbourg"
      data-materiel="EOS" data-gps="48.582967,7.74828">

    <script>
    var monelement = document.getElementById('moto');

    // Lecture d'une valeur
    var lieu = monelement.getAttribute('data-lieu');

    // Modification d'une valeur
    monelement.setAttribute('data-materiel') = 'iOS';

    // Suppression
    monelement.removeAttribute('data-materiel');
    </script>


Paradigme de programmation définition
-------------------------------
1. Paradigme de programmation
C'est une manière de concevoir la programmtion et de résoudre les différents problèmes, une philosophie de programmation.

    ////////////////////////////////////// EX:
    Programmation impérative
    Programmation fonctionnelle
    Programmation orientée objet


Les closures
-------------------------------
Voir https://openclassrooms.com/fr/courses/1916641-dynamisez-vos-sites-web-avec-javascript/2633501-les-closures



Debounce et Trottle
-------------------------------
1. La fonction debounce permet de déclencher l'appel à une fonction 
après un certain délai (un peu comme la fonction setTimeout()) 
mais permet en plus de réinitialiser le timer si on demande 
une nouvelle exécution dans un intervalle de temps plus 
court que le délai. Par exemple, on peut écouter la frappe 
d'un utilisateur dans un champ texte, mais ne pas vouloir 
appeler notre callback seulement si l'utilisateur marque 
une pause suffisamment longue.

    ////////////////////////////////////// EX:
    search.addEventListener('keyup', function(e){
        // le code ici sera appelé à chaque pression de touche
    })

    search.addEventListener('keyup', debounce(function(e){
        // Le code ici sera exécuté au bout de 350 ms 
        // mais si l'utilisateur tape une nouvelle fois dans cet intervalle de temps, le timer sera réinitialisé
    }, 350))

    // On appelle le callback en utilisant la méthode apply pour 
    // "transférer" le contexte et les paramètres à notre callback,
    // ici le paramètre e.
    function debounce(callback, delay){
        var timer;
        return function(){
            var args = arguments;
            var context = this;
            clearTimeout(timer);
            timer = setTimeout(function(){
                callback.apply(context, args);
            }, delay)
        }
    }

2. La fonction throttle permet d'éviter des appels consécutifs en
 introduisant un délai. Elle servira surtout lorsque l'on écoutera 
 des évènements pouvant se produire un très grand nombre de fois 
 dans un intervalle de temps très court (scroll, resize, mouseMove...).

window.addEventListener('scroll', function(e){
    // le code ici sera appelé à chaque fois que l'utilisateur 
    // bouge la scrollbar
})

Le problème de cet évènement c'est qu'il peut se lancer plusieurs 
centaines de fois pendant un simple mouvement de scrollbar. 
Si notre code est un peu lourd, cela peut entrainer des lags 
et rendre le scroll peu fluide.

    ////////////////////////////////////// EX:
    window.addEventListener('scroll', throttle(function(e){
        // Le code ici ne pourra être exécuté que toutes les 50 ms (20 appels max par secondes)
    }, 50))

    // Ici on utilise en partie le code de notre fonction debounce(), 
    // mais on introduit en plus un appel tous les XXX ms en 
    // comparant le temps actuel (en ms) avec le temps du dernier appel. 
    // La partie prise du debounce nous permet de gérer 
    // le dernier appel à notre callback.
    function throttle(callback, delay) {
        var last;
        var timer;
        return function () {
            var context = this;
            var now = +new Date();
            var args = arguments;
            if (last && now < last + delay) {
                // le délai n'est pas écoulé on reset le timer
                clearTimeout(timer);
                timer = setTimeout(function () {
                    last = now;
                    callback.apply(context, args);
                }, delay);
            } else {
                last = now;
                callback.apply(context, args);
            }
        };
    }

3. Il est important de noter que l'on retrouve des implémentations de throttle et debounce dans de nombreuses librairies Javascripts comme Underscorejs et Lodash.

    ////////////////////////////////////// EX:
    window.addEventListener('scroll', _.throttle(function(e){

    }, 40));

    search.addEventListener('keyup', _.debounce(function(e){

    }, 400));


Map vs Object
-------------------------------
Voir (Mode navigation privée) https://medium.com/front-end-weekly/es6-map-vs-object-what-and-when-b80621932373
Voir https://medium.com/javascript-in-plain-english/es6-object-vs-map-for-storing-key-value-pairs-9b06a7efece9
Voir https://dmitripavlutin.com/maps-vs-plain-objects-javascript/

1. Map devrait être utiliser pour stocker des paires clé-valeur si il
n'y a pas de besoin de sérialisation des données dans l'envoi d'un 
objet JSON dans une requête http par exemple avec JSON.stringify(). 
Avec Map on peut utiliser des clés qui ne sont pas obligatoirement 
des chaînes de caractères, une Map est itérable avec un ForEach par
exemple et possède des méthodes comme has() et size() 
qui facilitent la vie.

2. Un objet devrait être utilisé pour representer quelquechose et quand
on souhaite utiliser des propriétés avec des logiques différentes,
comme des attributs et des méthodes.


Set vs Array
-------------------------------
Voir (Mode navigation privée) https://medium.com/front-end-weekly/es6-set-vs-array-what-and-when-efc055655e1a

1. Set devrait être utiliser pour garantir qu'il n'y pas de doublons 
dans les données stockées.


Convertir un Objet en Map et inversement et sérialiser
-------------------------------
1. Convertir Map en object et sérialiser en JSON
    ////////////////////////////////////// EX:
    // Pour traiter les Map imbriquées, on définit une fonction récursive.
    function mapToObjectRec(m) {
        let lo = {}
        for(let[k,v] of m) {
            if(v instanceof Map) {
                lo[k] = mapToObjectRec(v)
            }
            else {
                lo[k] = v
            }
        }
        return lo
    }

    var o2 = mapToObjectRec(m)
    console.log(JSON.stringify(mapToObject(o2, m), null, ' '))
    // { "a": "one", "b": "two", "c": "three", "d": { "e": "four" } }

2. Convertir un objet sérialisé en JSON en Map
    ////////////////////////////////////// EX:
    var data = fs.readFileSync(fname,'UTF-8')
    let o3 = JSON.parse(data)

    // On aura l'objet suivant:

    {
      "a": "one",
      "b": "two",
      "c": "three",
      "d": { "e": "four"}
    }   

    function objectToMap(o) {
        let m = new Map()
        for(let k of Object.keys(o)) {
            if(o[k] instanceof Object) {
                m.set(k, objectToMap(o[k]))   
            }
            else {
                m.set(k, o[k])
            }    
        }
        return m
    }

    var m2 = objectToMap(o3)
    console.log(m2.get("d").get("e")) // four


    Primitive vs Reference
    -------------------------------
    Voir https://www.youtube.com/watch?v=9ooYYRLdg_g
    
    1. Primitives
    - String
    - Number
    - Boolean
    - Undefined
    - Null
    - Symbol (ES6)

    Les primitives se placent dans l'emplacement mémoire nommé la STACK.
    Les unes au-dessus des autres.


    2. Références
    - Object
    - Array (qui est aussi un Object)

    Les références sont des adresses correspondant à un emplacement mémoire
    dans le HEAP où sont stockés les objets et tableaux. Les references
    sont contenus dans des variables pointeurs contenus dans la STACK.
    Plusieurs pointeurs différents peuvent contenir la même référence
    comme lorsque l'on copie un tableau dans une autre variable, les
    deux variables contiennent la même réference et pointent vers le 
    même tableau en mémoire.
