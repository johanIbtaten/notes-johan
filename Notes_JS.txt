    var, let, const
    Types de données
    Différence entre undefined et null
    Double ou simple quotes ou accent grave (backquote ou backtick en anglais)
    Opérateur void
    La « remontée » des déclarations de fonction
    Définition d'un littéral
    Les expressions de fonctions
    Les fonctions flechées (arrow function en anglais)
    Objet Map
    Object Property Value Shorthand
    Boucles
    Fonctions sur les tableaux
    Rest parameters
    Spread operator (opérateur de décomposition)
    Le protocole « itérable » (Objets itérables)
    Le protocole « itérateur »
    Les générateurs function*


var, let, const
-------------------------------
Déclaration (var a;) initialisation : var a=2;
Déclaration (let a;) initialisation : let a=2;
Déclaration, initialisation : const a=2;
Scope (ou Portée en français)

var   : Scope dans les fonctions 
        Pas de scope dans les blocs (blocs types if, for, while, etc.)
        Si var est déclaré sans valeur initiale (ex: var a;) elle aura la valeur undefined

let   : Scope dans les fonctions 
        Scope dans les blocs (blocs types if, for, while, etc.)
        Si let est déclaré sans valeur initiale (ex: let a;) elle aura la valeur undefined

const : Scope dans les fonctions 
        Scope dans les blocs (blocs types if, for, while, etc.)
        const a besoin d'être déclaré avec une valeur initiale (ex: const a=2;)
	      On ne peut pas réassigner la valeur d'une constante (ex: a=4;)
        On ne peut pas re-déclarer dans la même portée une autre constante avec le même nom (ex: const a=4;)
        On peut ajouter ou supprimer les éléments d'un tableau dans une const
        On ne peut pas changer la structure d'un objet littéral dans une const
        On peut changer les valeurs d'un objet littéral dans un const


Types de données
-------------------------------
Numbers — var age = 23
Variables — var x
Text (strings) — var a = "init"
Operations — var b = 1 + 2 + 3
True or false statements (boolean) — var c = true
Constant numbers — const PI = 3.14
Objects — var name = {firstName:"John", lastName:"Doe"}
Undefined — var a; console.log(a); retourne undefined
Null  — var a = null


Différence entre undefined et null
-------------------------------
/// undefined : ///
1. Une variable possède la valeur undefined si elle n'est pas déclarée ou si elle est déclarée mais n'a pas encore eu de valeur d'assignée.

    Ex1: 
    var maVariable;
    alert(maVariable); // Le texte undefined s'affichera à l'écran, car la variable est non définie.
   
    Ex2: 
    function direBonjour(message) {
      console.log(message)
    }
    direBonjour(); // Le texte undefined s'affichera à l'écran, car la variable message déclarée en paramètre est non définie.

2. Il y a une faille dans JavaScript à connaître : le mot undefined n'est pas un mot-clé du langage. Il est donc possible de nommer une variable undefined, puis de lui attribuer une valeur.

    Ex1: 
    var undefined = toto; //Cette déclaration n'est pas fausse, contrairement à ce que l'on pourrait croire.
    if(maVariable === undefined) {
      alert(Vous avez été trompés!);
    }

3. Pour tester si une variable n'a pas été déclaré ou assignée, il faut utiliser typeof. 
typeof renvoie une chaîne qui indique le type de l'opérande (Quantité, donnée qui entre dans une opération arithmétique, une instruction informatique).

    Ex1:
    if (typeof maVariable === "undefined") {
      alert("La variable maVariable n'est pas définie");
    }

    Ex2:
    var x;
    if (typeof x === 'undefined') {
       // ces instructions seront exécutées
    }
    if (typeof x !== 'undefined') {
       // ces instructions ne seront pas exécutées
    }

4. Pour tester si une propriété d'objet est indéfinie on peut aussi utiliser typeof

    Ex1:
    const list = []
    const count = 2
    typeof list // "object"
    typeof count // "number"
    typeof "test" // "string"
    typeof color // "undefined"
    const car = {
      model: 'Fiesta'
    }
    if (typeof car.color === "undefined") {
      // color is undefined
    }

5. Une fonction qui n'a pas de valeur de return affiche undefined

    Ex1:
    function add() {
      const a = 3;
    }
    add(); // affiche undefined

/// null : ///
1. null sert à définir l'absence de valeur, on s'en sert par exemple pour assigner une valeur par défaut à des variables ou des paramètres de fonction, c'est une méthode beaucoup plus propre que d'assigner une valeur arbitraire comme 0 pour un entier, ou une chaine de caractère vide pour une chaine de caractère.

    Ex1:
    // toto n'existe pas, n'a pas été défini (déclaré) et n'a jamais été initialisé (assigné)
    toto;
    "ReferenceError: toto is not defined"
    // toto existe mais n'a ni type ni valeur
    var toto = null;
    console.log(toto); // null

    Ex2:
    function direBonjour(message = null) { // Valeur par défaut de message égale à null
      console.log(message); // null
    }

    Ex3:
    typeof null;           // "object" (pas null pour des raisons historiques)
    typeof undefined;      // "undefined"
    null === undefined;    // false
    null  == undefined;    // true
    null === null;         // true
    null  == null;         // true
    !null;                 // true
    isNaN(1 + null);       // false
    isNaN(1 + undefined);  // true


Double ou simple quotes ou accent grave (backquote ou backtick en anglais)
-------------------------------
1. C'est selon les préférences. L'avantage des doubles quotes est qu'il permet d'échapper les apostrophes et se conforme à JSON

    Ex1:
    alert('Say "Hello"');
    alert("Say 'Hello'");
    alert("It's \"game\" time.");
    alert('It\'s "game" time.');

2. En ES6 on peut aussi utiliser les template literals

    Ex1:
    alert(`Use "double" and 'single' quotes in the same string`);
    alert(`Escape the \` back-tick character and the \${ dollar-brace sequence in a string`);


Opérateur void
-------------------------------
1. L'opérateur void évalue (exécute) l'expression donnée void(0) équivaut à void 0 et retourne ensuite undefined.
    Ex1:
    void 2 == '2';    // renvoie false, attention à la précédence et donc mieux vaut utiliser des parenthèses
    void (2 === '2'); // renvoie undefined

2. On peut utiliser void pour ajouter un comportement preventDefault () pour un lien
    Ex1:
    <a href="javascript: void(0)"> À propos de </a>

3. On peut utiliser void pour qu'une function retourne undefined même si elle possède une valeur de retour.
    Ex1:
    function add() {
      const a = 3; return a
    };
    console.log(add()); // affiche 3
    console.log(void add()); // affiche undefined


La « remontée » des déclarations de fonction
-------------------------------
1. Lorsqu'on utilise une déclaration de fonction pour créer une fonction, la définition de la fonction est « remontée » (hoisting). Il devient donc possible d'utiliser la fonction avant de l'avoir déclarée
    Ex1:
    remontée(); // affiche "toto" dans la console
    function remontée() {
      console.log("toto");
    }


Définition d'un littéral
-------------------------------
En programmation informatique, une valeur littérale est une valeur donnée explicitement dans le code source d'un programme


Les expressions de fonctions
-------------------------------
1. Une expression de fonction est très similaire et a presque la même syntaxe qu'une déclaration de fonction. La différence principale entre une expression de fonction et une instruction est le nom de la fonction. En effet, pour les expressions, celui peut être omis (on parle alors d'une fonction anonyme). 
    Ex1:
    var getRectArea = function(width, height) {
    return width * height;
    }
    console.log(getRectArea(3,4));
    // expected output: 12    

2. En JavaScript, les expressions de fonction ne sont pas remontées (à la différence des déclarations de fonction). Il est donc impossible d'utiliser les expressions de fonction avant leur définition.
    Ex1:
    nonRemontée(); // TypeError: nonRemontée is not a function
    var nonRemontée = function() {
      console.log("truc");
    }

3. On peut utiliser une expression de fonction pour créer une « IIFE » (Immediately Invoked Function Expression), c'est-à-dire une expression de fonction qu'on appelle dès sa définition.
    Ex1:
    var a = "coucou";
    var b = "monde";
    // IIFE
    (function(x, y) {
      console.log(x + " " + y);
    })(a, b);
    // coucou monde


Les fonctions flechées (arrow function en anglais)
-------------------------------
    // Avant ES6
    const add = function(x, y) {
        return x + y
    }
    console.log(add(5, 4)) // 9
1. Une expression de fonction fléchée permet d’avoir une syntaxe plus courte que les expressions de fonction. Les fonctions fléchées sont souvent anonymes et ne sont pas destinées à être utilisées pour déclarer des méthodes.    
    Ex1:    
    // ES6
    const addES6 = (x, y) => { return x + y }
    console.log(addES6(5, 6)) // 11

2. Les accolades ne sont même pas obligatoire ici et le mot clé return aussi, parce que l'on renvoie une seule instruction.
    Ex1:
    // ES6
    const addES6 = (x, y) => x + y
    console.log(addES6(5, 6)) // 11

3. Quand on a un seul paramètre, nous n'avons donc pas besoin des parenthèses, on renseigne juste le nom du paramètre.
    Ex1:
    // ES6
    const hello = name => `Hello ${name}`
    console.log(hello('Niang')) // Hello Niang

    Ex2:
    var simple = a => a > 15 ? 15 : a; 
    simple(16); // 15
    simple(10); // 10


4. Pour définir une fonction sans paramètre, on met juste des parenthèses vides.
    Ex1:
    // ES6
    const helloWorld = () => 'Hello World!'
    console.log(helloWorld()) // Hello World!

5. Pour retourner un objet, il y a une petite différence, parce que l'objet doit être dans des accolades, il faut donc mettre le return entre parenthèses cette fois-ci pour faire la différence.
    Ex1:
    const setContent = (title, content) => ({title: title, content: content})
    console.log(setContent('Hello', 'ES6')) // {title: "Hello", content: "ES6"}

6. Il ne peut pas y avoir de saut de ligne entre les paramètres et la flèche d’une fonction fléchée.
    Ex1:
    var func = ()
            => 1; // SyntaxError: expected expression,
                  //              got '=>'

7. La flèche utilisée pour une fonction fléchée n’est pas un opérateur. Les fonctions fléchées ont des règles spécifiques quant à leur place dans la syntaxe et interagissent différemment de la précédence des opérateurs par rapport à une fonction classique.
    Ex1:
    let fonctionRappel;
    fonctionRappel = fonctionRappel || function () {};
    // OK
    fonctionRappel = fonctionRappel || () => {};
    // SyntaxError: invalid arrow-function arguments
    fonctionRappel = fonctionRappel || (() => {});
    // OK

8. Les fonctions fléchées sont mieux indiquées pour les fonctions qui ne sont pas des méthodes (fonctions dans un objet).
    Ex1:
    'use strict';
    var objet = {
      i: 10,
      b: () => console.log(this.i, this),
      c: function() {
        console.log(this.i, this);
      }
    }
    objet.b(); 
    // affiche undefined, Window (ou l'objet global de l'environnement)
    objet.c();
    // affiche 10, Object {...}

9. Les fonctions fléchées ne créent pas de nouveau contexte, elles utilisent la valeur this de leur contexte. Aussi, si le mot-clé this est utilisé dans le corps de la fonction, le moteur recherchera la référence à cette valeur dans une portée parente.
    Ex1:
    // Avant ES6
    function Personne () {
      var that = this; 
      that.age = 0;
      setInterval(function grandir () {
        // La fonction callback se réfère à la variable `that`
        // qui est le contexte souhaité
        that.age++;
      }, 1000);
    }
    // ES6
    function Personne () {
      this.age = 0;
      setInterval(() => {
        this.age++; 
          // |this| fait bien référence à l'objet personne
      }, 1000);
    }
    var p = new Personne();


10. Exemples d'utilisation
    Ex1:
    (() => "tototruc")() 
    // exemple d'une fonction immédiatement 
    // invoquée (IIFE en anglais) qui renvoie 
    // "tototruc" 

    var complexe = (a, b) => {
      if (a > b) {
          return a;
      } else {
          return b;
      }
    }

    var arr = [5, 6, 13, 0, 1, 18, 23];
    var sum = arr.reduce((a, b) => a + b);
    // 66
    var even = arr.filter(v => v % 2 == 0);
    // [6, 0, 18]
    var double = arr.map(v => v * 2);       
    // [10, 12, 26, 0, 2, 36, 46]


Objet Map
-------------------------------
1. L'objet Map représente un dictionnaire, autrement dit une carte de clés/valeurs. 
N'importe quelle valeur valable en JavaScript (que ce soit les objets ou les valeurs de types primitifs) 
peut être utilisée comme clé ou comme valeur. Un objet Map permet de retrouver ses éléments dans leur ordre d'insertion. 
Par exemple, une boucle for...of renverra un tableau de [clé, valeur] pour chaque itération.

//new Map([itérable])
    [itérable]
        Un tableau (Array) ou tout autre objet itérable dont les éléments sont des paires clé/valeur (par exemple un tableau de la forme [[1 , "toto"],[2, "truc"]]). Chaque paire clé/valeur sera ajoutée au nouvel objet Map. null est traité comme undefined.
    
    Ex1:
    // Utiliser un objet Map
    var maMap = new Map();
    var objetCle = {},
        fonctionCle = function () {},
        chaineCle = "une chaîne";
    // définir les valeurs
    maMap.set(chaineCle, "valeur associée à 'une chaîne'");
    maMap.set(objetCle, "valeur associée à objetCle");
    maMap.set(fonctionCle, "valeur associée à fonctionCle");
    maMap.size; // 3
    // récupérer les valeurs
    maMap.get(chaineCle);     // "valeur associée à 'une chaîne'"
    maMap.get(objetCle);      // "valeur associée à objetCle"
    maMap.get(fonctionCle);   // "valeur associée à fonctionCle"
    maMap.get("une chaîne");  // "valeur associée à 'une chaîne'"
                              // car chaineCle === 'une chaîne'

    Ex2:
    // Parcourir des objets Maps avec for..of
    var maMap = new Map();
    maMap.set(0, "zéro");
    maMap.set(1, "un");
    for (var [cle, valeur] of maMap) {
      console.log(cle + " = " + valeur);
    }
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"
    for (var cle of maMap.keys()) {
      console.log(cle);
    }
    // On aura 2 lignes : la première avec "0"
    // et la seconde avec "1"
    for (var valeur of maMap.values()) {
      console.log(valeur);
    }
    // On aura 2 lignes : la première avec "zéro"
    // et la seconde avec "un"
    for (var [cle, valeur] of maMap.entries()) {
      console.log(cle + " = " + valeur);
    }
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"
    maMap.forEach(function(valeur, cle) {
      console.log(cle + " = " + valeur);
    });
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"

    Ex3:
    // Relation avec les objets Array
    var tableauCleValeur = [["cle1", "valeur1"], ["cle2", "valeur2"]];
    // On utilise le constructeur Map
    // pour transformer un tableau de cles/valeurs
    // en un objet map
    var maMap = new Map(tableauCleValeur);
    maMap.get("cle1"); // renvoie "valeur1"
    // On utilise la fonction Array.from pour transformer
    // une map en un tableau de cles/valeurs
    console.log(Array.from(maMap)); // affichera la même chose que tableauCleValeur
    // On peut aussi l'utiliser pour n'extraire que les cles
    // ou les valeurs et créer le tableau associé
    console.log(Array.from(maMap.keys())); // affichera ["cle1", "cle2"]

    Ex4:
    // Fusionner des objets Map
    var premier = new Map([
      [1, 'un'],
      [2, 'deux'],
      [3, 'trois'],
    ]);
    var second = new Map([
      [1, 'uno'],
      [2, 'dos']
    ]);
    // On fusionne les deux maps. C'est la "dernière" version
    // de la clé qui l'emporte.
    // L'opérateur de décomposition nous permet principalement ici
    // de convertir une map en un tableau
    var fusion = new Map([...premier, ...second]);
    console.log(fusion.get(1)); // uno
    console.log(fusion.get(2)); // dos
    console.log(fusion.get(3)); // trois

    // Fusionner des objets Map avec des objets Array
    var premier = new Map([
      [1, 'un'],
      [2, 'deux'],
      [3, 'trois'],
    ]);
    var second = new Map([
      [1, 'uno'],
      [2, 'dos']
    ]);
    // On peut fusionner des Maps avec un tableau 
    // Là encore c'est le dernier exemplaire de la clé qui l'emporte
    var fusion = new Map([...premier, ...second, [1, 'eins']]);
    console.log(fusion.get(1)); // eins
    console.log(fusion.get(2)); // dos
    console.log(fusion.get(3)); // trois


Object Property Value Shorthand
-------------------------------
1. If you want to define or set an object who's keys have the same name as the variables passed-in as properties, you can use the shorthand and simply pass the key name.
    Ex1:
    // Avant ES6
    var cat = 'Miaow';
    var dog = 'Woof';
    var bird = 'Peet peet';
    var someObject = {
      cat: cat,
      dog: dog,
      bird: bird
    }
    // ES6
    let cat = 'Miaow';
    let dog = 'Woof';
    let bird = 'Peet peet';
    let someObject = {
      cat,
      dog,
      bird
    }
    console.log(someObject);
    //{
    //  cat: "Miaow",
    //  dog: "Woof",
    //  bird: "Peet peet"
    //}

    Ex2:
    state = {
      text: sampleText
    };

    editText = (event) => {
      const text = event.target.value;
      this.setState({ text }); // au lieu de this.setState({ text: text});
    };


Boucles
-------------------------------
FOR...OF (ES6)
for (variable of iterable)
  instruction

    [variable]
      À chaque itération, la valeur d'une propriété différente est affectée à variable (cette variable peut être déclarée avec const, let ou var).
    [iterable]
      L'objet dont on parcourt les propriétés énumérables.
    [instruction]
      Une instruction à exécuter pour chaque propriété, cette instruction peut être composée de plusieurs instructions en utilisant un bloc d'instructions.

1. L'instruction for...of permet de créer une boucle Array qui parcourt un objet itérable 
(ce qui inclut les objets Array, Map, Set, String, TypedArray, l'objet arguments, etc.) et 
qui permet d'exécuter une ou plusieurs instructions pour la valeur de chaque propriété.

    Ex1:
    // Sur un tableau
    let tableauIterable = [1, 2, 3];
    for (let valeur of tableauIterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3

    Ex2:
    // Parcourir une chaîne de caractères
    let iterable = 'pixel';
    for (let valeur of iterable) {
      console.log(valeur);
    }
    // p
    // i
    // x
    // e
    // l

    Ex3:
    // Parcourir une Map
    let iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);
    for (let element of iterable) {
      console.log(element);
    }
    // ['a', 1]
    // ['b', 2]
    // ['c', 3]
    for (let [clef, valeur] of iterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3


FOR...IN
for (variable in objet) {...
}

    [variable]
      Un nom de propriété différent est assigné à la variable à chaque itération de la boucle.
    [objet]
      L'objet dont les propriétés énumérables et qui ne sont pas des symboles sont parcourues par la boucle.

1. L'instruction for...in permet d'itérer sur les propriétés énumérables d'un objet qui ne sont pas des symboles. 
Pour chaque propriété obtenue, on exécute une instruction (ou plusieurs grâce à un bloc d'instructions).
for...in ne doit pas être utilisée pour parcourir un Array lorsque l'ordre des éléments est important.

    Ex1:
    // Sur un objet
    var obj = {a:1, b:2, c:3};    
    for (var prop in obj) {
      console.log(`obj.${prop} = ${obj[prop]}`);
    }
    // Affiche dans la console :
    // "obj.a = 1"
    // "obj.b = 2"
    // "obj.c = 3"

    Ex2:
    // Parcourir une chaîne de caractères
    let iterable = 'pixel';
    for (let valeur of iterable) {
      console.log(valeur);
    }
    // p
    // i
    // x
    // e
    // l

    Ex3:
    // Parcourir une Map
    let iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);
    for (let element of iterable) {
      console.log(element);
    }
    // ['a', 1]
    // ['b', 2]
    // ['c', 3]
    for (let [clef, valeur] of iterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3


LES DIFFÉRENCES ENTRE FOR...OF ET FOR...IN
1. Chaque objet héritera de la propriété objCustom et chaque objet qui est un tableau (Array) héritera de la propriété arrCustom car 
on les ajoute aux prototypes Object.prototype et Array.prototype. L'objet iterable hérite donc des propriétés objCustom et 
arrCustom grâce à l'héritage et à la chaîne de prototypes.
Cette boucle ne parcourt que les propriétés énumérables de l'objet iterable dans un ordre arbitraire. 
Les éléments du tableau 3, 5, 7 ou "coucou" ne sont pas affichés car ce ne sont pas des propriétés 
(et encore moins des propriétés énumérables). En revanche, on retrouve bien les indices du tableau et 
les propriétés arrCustom et objCustom. Pour décrire plus précisément ce comportement, vous pouvez consulter for...in.

    Ex1:
    Object.prototype.objCustom = function() {}; 
    Array.prototype.arrCustom = function() {};
    let iterable = [3, 5, 7];
    iterable.toto = 'coucou';
    for (let i in iterable) {
      console.log(i); // affiche 0, 1, 2, "toto",
                      // "arrCustom", "objCustom"
    }
    for (let i in iterable) {
      if (iterable.hasOwnProperty(i)) {
        console.log(i); // affiche 0, 1, 2, "toto"
      }
    }
    // Cette boucle parcourt les valeurs définies comme itérables par l'objet itérable et 
    // dans ce cas ce sont les éléments du tableau 3, 5, 7 et pas les propriétés de l'objet (ici toto et sa valeur "coucou")
    for (let i of iterable) {
      console.log(i); // affiche 3, 5, 7
    }

Fonctions sur les tableaux
-------------------------------
FOREACH()
// arr.forEach(callback);
// arr.forEach(callback, thisArg);
1. Permet d'exécuter une fonction donnée sur chaque élément du tableau.
    
    [callback] est appelé avec trois arguments :
      - la valeur de l'élément
      - l'index de l'élément
      - le tableau utilisé

    Ex1:
    var array1 = ['a', 'b', 'c'];
    array1.forEach(function(element) {
      console.log(element);
    });

    Ex2:
    let arr = [3, 5, 7];
    arr.toto = "coucou";
    arr.forEach(function (element, index) {
      console.log(element); // affiche "3", "5", "7"
      console.log(index);  // affiche "0", "1", "2"
    });


CONSOLE.TABLE()
// console.table(data [, columns]);
    [data]
      La donnée à afficher. Doit être un tableau ou un objet.
    [columns]
      Un tableau contenant les noms des colonnes à inclure dans la sortie.

    Ex1:
    // data peut contenir un tableau ou un objet.
    // un tableau de chaînes de caractères
    console.table(["apples", "oranges", "bananas"]);

    Ex2:
    // un objet dont les propriétés sont des chaînes de caractères
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var me = new Person("John", "Smith");
    console.table(me);

    Ex3:
    // un tableau de tableaux
    var people = [["John", "Smith"], ["Jane", "Doe"], ["Emily", "Jones"]]
    console.table(people);

    Ex4:
    // un tableau d'objets
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var john = new Person("John", "Smith");
    var jane = new Person("Jane", "Doe");
    var emily = new Person("Emily", "Jones");
    console.table([john, jane, emily]);

    Ex5:
    // un objet contenant des propriétés qui sont des objets
    var family = {};
    family.mother = new Person("Jane", "Smith");
    family.father = new Person("John", "Smith");
    family.daughter = new Person("Emily", "Smith");
    console.table(family);

    Ex6:
    // un tableau d'objets, affichant seulement firstName
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var john = new Person("John", "Smith");
    var jane = new Person("Jane", "Doe");
    var emily = new Person("Emily", "Jones");
    console.table([john, jane, emily], ["firstName"]);


REDUCE()
// arr.reduce(callback) 
// arr.reduce(callback, valeurInitiale)
1. reduce() exécute la fonction callback une fois pour chaque élément présent dans le tableau et ignore les éléments vides du tableau. La fonction callback utilise quatre arguments. 
La première fois que la fonction callback est appelée, valeurInitiale et valeurCourante peuvent correspondre à un ou deux éléments. Si valeurInitiale est fournie dans l'appel de reduce(), 
alors accumulateur sera égale à valeurInitiale et valeurCourante sera égale à la première valeur de la liste. Si valeurInitiale n'est pas fournie, alors accumulateur sera égale à la première valeur de la liste, et valeurCourante sera alors égale à la seconde.
Autrement dit, si valeurInitiale n'est pas fournie, reduce exécutera la fonction de rappel à partir de l'indice 1 et la première valeur du tableau (d'indice 0) sera utilisée pour valeurInitiale.

    [callback]
      La fonction à exécuter sur chaque valeur de la liste (sauf le premier si aucune valeurInitiale n'est fournie), elle prend quatre arguments en entrée :
        [accumulateur]
          La valeur précédemment retournée par le dernier appel du callback, ou valeurInitiale, si elle est fournie (voir ci-après) (c'est la valeur « accumulée » au fur et à mesure des appels
        [valeurCourante]
          La valeur de l'élément courant actuellement manipulé dans le tableau.
        [index] (Facultatif)
          L'index de l'élément courant actuellement manipulé dans le tableau.
        [array] (Facultatif)
          Le tableau sur lequel on a appelé la méthode reduce().
    [valeurInitiale] (Facultatif)
      Une valeur utilisée comme premier argument lors du premier appel de la fonction callback. Si aucune valeur initiale n'est fournie, le premier élément du tableau est utilisé. Si on appelle reduce() sur un tableau vide sans fournir de valeur initiale, on aura une erreur.
    
    Ex1:
    // Sans fonction fléchée
    [0, 1, 2, 3, 4].reduce(function(accumulateur, valeurCourante, index, array){
      return accumulateur + valeurCourante;
    });
    // 10

    // Avec fonction fléchée
    [0, 1, 2, 3, 4].reduce((accumulateur, valeurCourante) => accumulateur + valeurCourante);
    // 10

    Ex2:
    // Avec valeurInitiale
    [0, 1, 2, 3, 4].reduce((accumulateur, valeurCourante) => accumulateur + valeurCourante, 10);
    // 20

MAP()
// let nouveauTableau = arr.map(callback [, thisArg])
1. La fonction callback fournie en argument est exécutée une fois pour chacun des éléments du tableau, dans l'ordre du tableau. 
Chaque résultat de l'opération sur un élément sera un élément du nouveau tableau. La fonction callback est appelée uniquement pour les indices du tableau 
pour lesquels il y a des valeurs affectées (y compris si cette valeur est undefined). Si les valeurs ont été supprimées ou qu'elles n'ont jamais été initialisées, la fonction ne sera pas appelée.
Si on utilise cette méthode sans utiliser le résultat, mieux vaudra utiliser forEach ou for...of. 

    [callback]
      La fonction qui est utilisée pour créer un élément du nouveau tableau. Elle utilise trois arguments
        [valeurCourante]
          La valeur de l'élément du tableau à traiter.
        [index]
          L'index de l'élément qui est traité par la fonction.
        [tableau] (Facultatif)
          Le tableau sur lequel on a appelé la méthode map.
    [thisArg] (Facultatif)
      La valeur à utiliser pour this lors de l'exécution de callback. La valeur par défaut est l'objet global de l'environnement (Window pour un navigateur).
    
    Ex1:
    // On crée un tableau composé des racines carrées des éléments d'un premier tableau
    var nombres = [1, 4, 9];
    var racines = nombres.map(Math.sqrt);
    // racines vaut désormais [1, 2, 3]
    // nombres vaut toujours [1, 4, 9]

    Ex2:
    // Créer un tableau de nombres avec une fonction à un argument. 
    // Cet argument sera automatiquement remplacé par chaque élément du tableau au fur et à mesure que map parcourt le tableau
    var nombres = [1, 4, 9];
    var doubles = nombres.map(function(num) {
      return num * 2;
    });
    // doubles vaut désormais [2, 8, 18].
    // nombres vaut toujours [1, 4, 9]

    Ex3:
    // On utilise un tableau d'objets pour créer un autre tableau contenant de nouveaux objets dans un autre format 
    var tableauOrig = [{cle:1, valeur:10}, {cle:2, valeur:20}, {cle:3, valeur: 30}];
    var tableauFormaté = tableauOrig.map(obj => { 
      var rObj = {};
      rObj[obj.cle] = obj.valeur; 
      return rObj;
    });
    // tableauFormaté vaut maintenant [{1:10}, {2:20}, {3:30}], 
    // tableauOrig vaut toujours 
    // [{cle:1, valeur:10},
    //  {cle:2, valeur:20},
    //  {cle:3, valeur: 30}
    // ]

    Ex4:
    // Utiliser map de façon générique sur autre chose qu'un tableau
    // Sur une chaine de caractère
    var map = Array.prototype.map;
    var a = map.call('Hello World', function(x) { return x.charCodeAt(0); });
    // a vaut désormais [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
    // Ici sur un tableau d'objets collectés grâce à querySelectorAll
    var elems = document.querySelectorAll('select option:checked');
    var values = Array.prototype.map.call(elems, function(obj) {
      return obj.value;
    });

    Ex5:
    // Utiliser map de façon générique sur autre chose qu'un tableau
    // Sur un tableau d'objets collectés grâce à querySelectorAll
    var elems = document.querySelectorAll('select option:checked');
    var values = Array.prototype.map.call(elems, function(obj) {
      return obj.value;
    });

ENTRIES()
// arr.entries()
1. La méthode entries() renvoie un nouvel objet de type Array Iterator qui contient le couple clef/valeur pour chaque éléments du tableau.

    Ex1:
    var array1 = ['a', 'b', 'c'];
    var iterator1 = array1.entries();
    console.log(iterator1.next().value);
    // expected output: Array [0, "a"]
    console.log(iterator1.next().value);
    // expected output: Array [1, "b"]

FROM()
// Array.from(arrayLike [, fonctionMap[, thisArg]])
1. La méthode Array.from() permet de créer une nouvelle instance d'Array (une copie superficielle) 
à partir d'un objet itérable ou semblable à un tableau.

    [arrayLike]
        Un objet semblable à un tableau ou bien un objet itérable dont on souhaite créer un tableau, instance d'Array.
    [fonctionMap] (Facultatif)
        Argument optionnel, une fonction à appliquer à chacun des éléments du tableau.
    [thisArg] (Facultatif)
        Argument optionnel. La valeur à utiliser pour this lors de l'exécution de la fonction fonctionMap.

    Valeur de retour :
        Une nouvelle instance de Array.

    Ex1:
    // créer une instance d'Array à partir de l'objet arguments qui est semblable à un tableau
    function f() {
      return Array.from(arguments);
    }
    f(1, 2, 3); 
    // [1, 2, 3]

    Ex2:
    // Ça fonctionne avec tous les objets itérables...
    // Set
    const s = new Set(["toto", "truc", "truc", "bidule"]);
    Array.from(s);   
    // ["toto", "truc", "bidule"]
    // Map
    const m = new Map([[1, 2], [2, 4], [4, 8]]);
    Array.from(m);                          
    // [[1, 2], [2, 4], [4, 8]]  
    const mapper = new Map([["1", "a"], ["2", "b"]]);
    Array.from(mapper.values());
    // ["a", "b"] 
    Array.from(mapper.keys());
    // ["1", "2"]
    // String
    Array.from("toto");                      
    // ["t", "o", "t", "o"]

    
Rest parameters
-------------------------------
1. Cette syntaxe permet de représenter un nombre indéfini d'arguments sous forme d'un tableau.
    Ex1:
    // ES6
    function sum(...theArgs) {
      return theArgs.reduce((previous, current) => {
        return previous + current;
      });
    }
    console.log(sum(1, 2, 3));
    // expected output: 6
    console.log(sum(1, 2, 3, 4));
    // expected output: 10

    Ex2:
    // S'il n'y a qu'un seul argument qui est décomposé par la syntaxe, la valeur sera toujours un tableau
    function maFonction(a, b, ...autres);
      console.log(a);
      console.log(b);
      console.log(autres);
    }
    maFonction("un", "deux", "trois");
    // affichera ceci dans la console
    // "un"
    // "deux"
    // ["trois"]
    maFonction("un", "deux", "trois", "quatre", "cinq");
    // affichera ceci dans la console :
    // "un"
    // "deux"
    // ["trois", "quatre", "cinq"]

    Ex3:
    // S'il n'y a pas suffisamment d'arguments, ce sera un tableau vide
    function maFonction(a, b, ...autres);
      console.log(a);
      console.log(b);
      console.log(autres);
    }
    maFonction("un", "deux");
    // affichera ceci dans la console
    // "un"
    // "deux"
    // []

    Ex4:
    // lesArguments est un tableau et dispose donc d'une propriété length permettant de compter ses éléments
    function fun1(...lesArguments) {
      console.log(lesArguments.length);
    }
    fun1();  // 0
    fun1(5); // 1
    fun1(5, 6, 7); // 3

  
Spread operator (opérateur de décomposition)
-------------------------------
1. Il permet de développer un objet itérable (comme un Array) en plusieurs arguments (pour les appels de fonctions) 
ou en plusieurs éléments (pour les littéraux de tableaux) ou en paires clés-valeurs (pour les littéraux d'objets)

    Ex1:
    // Dans les appels de fonction
    f(...objetIterable);
    // Pour les littéraux de tableaux
    [...objetIterable, 4, 5, 6]
    // Pour les littéraux objets
    let objClone = { ...obj };

    Ex2:
    // Utiliser la décomposition dans les appels de fonction
    const myArray = [1991, 8, 1]
    new Date(...myArray) // object Date - équivaut à: new Date(1991, 8, 1)
    // spread peut être mélangé aux autres arguments d'une fonction
    const myArray = [8, 1];
    new Date(1991, ...myArray, 12); 
    // object Date - équivaut à: new Date(1991, 8, 1, 12)
    
    Ex3:
    // Les objets String étant itérables
    const myString = "foo bar"    
    [...myString] // ["f", "o", "o", " ", "b", "a", "r"]

    Ex4:
    // Éviter l'utilisation de .apply()
    // ES5
    console.log.apply(console, ["foo", "bar"]);
    // ES6
    console.log(...["foo", "bar"]); // même résultat

    Ex5:
    // Concaténer plusieurs itérables
    const stronglyTyped = ["scala", "haskell"]
    // ES5
    ["go", "rust"].concat(stronglyTyped) 
    // ["go", "rust", "scala", "haskell"]
    // ES6 / ES2015
    ["go", "rust", ...stronglyTyped] 
    // ["go", "rust", "scala", "haskell"]
    var articulations = ['épaules', 'genoux'];
    var corps = ['têtes', ...articulations, 'bras', 'pieds'];
    // ["têtes", "épaules", "genoux", "bras", "pieds"]
    var arr1 = [4, 5, 6];
    var arr2 = [1, 2, 3];
    arr1 = [...arr2, ...arr1];
    // arr1 vaut désormais [1, 2, 3, 4, 5, 6]

    Ex6:
    // Copier un tableau (seulement au premier niveau de profondeur)
    var arr = [1, 2, 3];
    var arr2 = [...arr];
    arr2.push(4);
    console.log(arr2); // [1, 2, 3, 4]
    console.log(arr);  // [1, 2, 3] (inchangé)

    Ex7:
    // Clonage superficiel d'objet   
    const cat = { age: 4 };
    const kitten = { ...cat }; // Nouvel objet créé
    kitten.age = 1;
    console.log(kitten.age); // 1
    console.log(cat.age); // 4
    // Superficiel car les valeurs des propriétés de l'objet cloné pointent vers les mêmes références que l'objet copié et ne sont pas de nouvelles instances) 
    const cat = { age: 4, toys: ["mouse", "catnip"] };
    const kitten = { ...cat };
    kitten.toys[1] = "yarn";
    console.log(kitten.toys); // ["mouse", "yarn"]
    console.log(cat.toys); // ["mouse", "yarn"] <-- problem!


Le protocole « itérable » (Objets itérables)
-------------------------------
1. Le protocole « itérable » permet aux objets JavaScript de définir ou de personnaliser leur comportement lors d'une itération, 
par exemple la façon dont les valeurs seront parcourues avec une boucle for..of. 
Certains types natifs tels que Array ou Map possèdent un comportement itératif par défaut, d'autres types, 
comme Object n'ont pas ce type de comportement.

    Ex1:
    // Certains types natifs possèdent un comportement par défaut pour l'itération, d'autres types (tels qu'Object) n'ont pas de tel comportement. Les types natifs qui disposent d'une méthode @@iterator sont :
    Array.prototype[@@iterator]()
    TypedArray.prototype[@@iterator]()
    String.prototype[@@iterator]()
    Map.prototype[@@iterator]()
    Set.prototype[@@iterator]()

    Ex2:
    // Les API natives utilisant des itérables
    Map([itérable])
    WeakMap([itérable])
    Set([itérable])
    WeakSet([itérable])
    Promise.all(itérable)
    Promise.race(itérable)
    Array.from()

    var monObjet = {};
    new Map([[1,"a"],[2,"b"],[3,"c"]]).get(2); // "b"
    new WeakMap([[{},"a"],[monObjet,"b"],[{},"c"]]).get(monObjet); // "b"
    new Set([1, 2, 3]).has(3); // true
    new Set("123").has("2"); // true
    new WeakSet(function*() {
        yield {};
        yield monObjet;
        yield {};
    }()).has(monObjet);  // true

    Ex3:
    // Les éléments de syntaxe utilisant des itérables
    for..of
    la syntaxe de décomposition (opérateur spread)
    yield*
    l'affectation par décomposition

    for(let value of ["a", "b", "c"]){
      console.log(value);
    }
    // "a"
    // "b"
    // "c"
    [..."abc"]; // ["a", "b", "c"]
    function* gen(){
      yield* ["a", "b", "c"];
    }
    gen().next(); // { value:"a", done:false }
    [a, b, c] = new Set(["a", "b", "c"]);
    a; // "a"

2. Afin d'être itérable, un objet doit implémenter la méthode @@iterator, cela signifie que l'objet (ou un des objets de sa chaîne de prototypes) 
doit avoir une propriété avec une clé @@iterator qui est accessible via Symbol.iterator. 
Lorsqu'on doit itérer sur un objet (ex. : au début d'une boucle for..of), sa méthode @@iterator est appelée sans argument et l'itérateur 
qui est renvoyé est utilisé afin d'obtenir les valeurs sur lesquelles itérer.

    Ex1:
    // Itérables définis par l'utilisateur
    const iterable1 = new Object();
    iterable1[Symbol.iterator] = function* () {
      yield 1;
      yield 2;
      yield 3;
    };
    console.log([...iterable1]);
    // expected output: Array [1, 2, 3]

    // Dans des déclarations de classe ou dans des littéraux objets
    class Toto {
      *[Symbol.iterator] () {
        yield 1;
        yield 2;
        yield 3;
      }
    }
    const monObj = {
      *[Symbol.iterator] () {
        yield "a";
        yield "b";
      }
    }
    [... new Toto] // [1, 2, 3]
    [... monObj]   // ["a", "b"]

3. Si une méthode @@iterator d'un objet itérable ne renvoie pas d'objet itérateur,
on dira que cet objet est un itérable mal-formé. Utiliser de tels itérables peut provoquer 
des exceptions lors de l'exécution ou un comportement erratique
    Ex1:
    // Itérables mal-formés
    var itérableMalForme = {}
    iterableMalForme[Symbol.iterator] = () => 1
    [...iterableMalForme] // TypeError: [] is not a function


Le protocole « itérateur »
-------------------------------
1.Le protocole « itérateur » définit une façon standard pour produire une suite de valeurs (finie ou infinie) 
ainsi qu'une valeur de retour lorsque toutes les valeurs ont été générées.
Un objet est considéré comme un itérateur lorsqu'il implémente une méthode next() avec la sémantique suivante:
Une fonction sans argument qui doit toujours renvoyer un objet contenant les propriétés done et value. 
Si c'est une valeur primitive qui est renvoyée (ex. false ou undefined), une exception TypeError sera levée ("iterator.next() returned a non-object value").
  [done] (un booléen)
      Qui vaut true lorsque l'itérateur a fini la suite. Dans ce cas, la propriété value sera facultative et permettra de spécifier la valeur de retour de l'itérateur. Les valeurs de retour sont détaillées ici.
      Qui vaut false lorsque l'itérateur a pu produire la prochaine valeur de la suite. Si on ne définit pas la propriété done, on aura ce comportement par défaut.
  [value]
      N'importe quelle valeur JavaScript, renvoyée par l'itérateur. Cette propriété peut être absente lorsque done vaut true.

    Ex1:
    // L'itérateur par défaut d'un objet String renverra les caractères de la chaîne les uns à la suite des autres
    var uneChaine = "coucou";
    typeof uneChaine[Symbol.iterator]; // "function"
    var iterateur = uneChaine[Symbol.iterator](); // On récupère l'objet itérateur de l'objet String
    iterateur + "";     // "[object String Iterator]"
    iterateur.next();  // { value: "c", done: false }
    iterateur.next();  // { value: "o", done: false }
    iterateur.next();  // { value: "u", done: false }
    iterateur.next();  // { value: "c", done: false }
    iterateur.next();  // { value: "o", done: false }
    iterateur.next();  // { value: "u", done: false }
    iterateur.next();  // { value: undefined, done: true }

    Ex2:
    // Redéfinir le comportement par défaut de l'itérateur en définissant soi-même le symbole @@iterator
    var uneChaine = new String("yo"); // on construit un objet String explicitement afin d'éviter la conversion automatique
    uneChaine[Symbol.iterator] = function() {
      return { // l'objet itérateur qui renvoie un seul élément, la chaîne "bop"
        next: function() {
          if (this._first) {
            this._first = false;
            return { value: "bop", done: false };
          } else {
            return { done: true };
          }
        },
        _first: true
      };
    };
    [...uneChaîne];  // ["bop"]
    uneChaîne + "";  // "yo"

    Ex3:
    // Un itérateur simple
    function creerIterateur(tableau){
        var nextIndex = 0;
        
        return {
          next: function(){
              return nextIndex < tableau.length ?
                  {value: tableau[nextIndex++], done: false} :
                  {done: true};
          }
        }
    }
    var it = creerIterateur(['yo', 'ya']);
    console.log(it.next().value); // 'yo'
    console.log(it.next().value); // 'ya'
    console.log(it.next().done);  // true

    Ex4:
    // Un itérateur infini
    function créateurID(){
        var index = 0;
        
        return {
          next: function(){
              return {value: index++, done: false};
          }
        };
    }
    var it = créateurID();
    console.log(it.next().value); // '0'
    console.log(it.next().value); // '1'
    console.log(it.next().value); // '2'
    // ...

    Ex5:
    // Avec un générateur
    function* creerUnGenerateurSimple(tableau){
        var nextIndex = 0;
        
        while(nextIndex < tableau.length){
            yield tableau[nextIndex++];
        }
    }
    var gen = creerUnGenerateurSimple(['yo', 'ya']);
    console.log(gen.next().value); // 'yo'
    console.log(gen.next().value); // 'ya'
    console.log(gen.next().done);  // true

    Ex6:
    // Avec une classe (ES6)
    class ClasseSimple {
      constructor(data) {
        this.index = 0;
        this.data = data;
      }
      [Symbol.iterator]() {
        return {
          next: () => {
            if (this.index < this.data.length) {
              return {value: this.data[this.index++], done: false};
            } else {
              this.index = 0; 
              // En réinitialisant l'index, on peut 
              // "reprendre" l'itérateure sans avoir
              // à gérer de mise à jour manuelle
              return {done: true};
            }
          }
        };
      }
    }
    const simple = new ClasseSimple([1,2,3,4,5]);
    for (const val of simple) {
      console.log(val);  // '1' '2' '3' '4' '5' 
    }


Les générateurs function*
-------------------------------
1. La déclaration function* (le mot-clé function suivi par un astérisque) permet de définir un générateur
(aussi appelé une fonction génératrice) (un générateur est un objet Generator).
Les générateurs sont des fonctions qu'il est possible de quitter puis de reprendre. 
Le contexte d'un générateur (les liaisons avec ses variables) est sauvegardé entre les reprises successives.

2. Les générateurs, combinés avec les promesses, sont des outils de programmation asynchrones puissants qui permettent de réduire 
les inconvénients causés par les callbacks (fonctions de rappel) et l'inversion de contrôle.
Lorsqu'on appelle une fonction génératrice, son corps n'est pas exécuté immédiatement, c'est un itérateur 
qui est renvoyé pour la fonction. Lorsque la méthode next() de l'itérateur est appelée, le corps de la fonction génératrice 
est utilisé jusqu'à ce que la première expression yield soit trouvée. Cette expression définira la valeur à renvoyer pour l'itérateur.
Si on utilise yield*, on pourra déléguer la génération des valeurs à une autre fonction génératrice. La méthode next() renvoie 
un objet dont la propriété value contient la valeur générée et une propriété done qui indique si le générateur a produit sa dernière 
valeur ou non. Lorsqu'on appelle la méthode next() avec un argument, cela reprendra l'exécution de la fonction génératrice et remplacera 
la valeur de l'expression yield (là où l'exécution avait été interrompue) avec la valeur de l'argument passé à next().

3. On peut utiliser une instruction return dans un générateur. Lorsque cette instruction sera exécutée, 
le générateur sera terminé (done vaudra true). La valeur renvoyée par l'instruction return sera la valeur de terminaison du générateur. 
Une fois qu'un générateur est terminé, il ne peut plus produire d'autres valeurs.

4. À l'instar d'une instruction return, une exception levée à l'intérieur du générateur entraînera la terminaison du 
générateur sauf si cette exception est interceptée. Lorsqu'un générateur est terminé, les appels suivants à next() n'exécuteront 
aucun code provenant du générateur, ils renverront simplement un objet de la forme {value: undefined, done: true}.

    Ex1:
    // Exemple simple
    function* creerID(){
      var index = 0;
      while(index < 3){
        yield index++;
      }
    }
    var gen = creerID();
    console.log(gen.next().value); // 0
    console.log(gen.next().value); // 1
    console.log(gen.next().value); // 2
    console.log(gen.next().value); // undefined

    Ex2:
    // Avec des arguments
    function* logGenerator() {
      console.log(yield);
      console.log(yield);
      console.log(yield);
    }
    var gen = logGenerator();
    // le premier appel à next exécute la fonction depuis son 
    // début jusqu'au premier yield rencontré
    gen.next(); 
    gen.next('bretzel');    // bretzel
    gen.next('california'); // california
    gen.next('mayonnaise'); // mayonnaise

    Ex3:
    // Exemple utilisant yield* (Pour déléguer la génération des valeurs à un autre générateur)
    function* autreGenerateur(i) {
      yield i + 1;
      yield i + 2;
      yield i + 3;
    }
    function* generateur(i){
      yield i;
      yield* autreGenerateur(i);
      yield i + 10;
    }
    var gen = generateur(10);
    console.log(gen.next().value); // 10
    console.log(gen.next().value); // 11
    console.log(gen.next().value); // 12
    console.log(gen.next().value); // 13
    console.log(gen.next().value); // 20

    Ex4:
    // Utilisation de return
    function* yieldAndReturn() {
      yield "Y";
      return "R";
      yield "inaccessible";
    }
    var gen = yieldAndReturn();
    console.log(gen.next()); // { value: "Y", done: false }
    console.log(gen.next()); // { value: "R", done: true }
    console.log(gen.next()); // { value: undefined, done: true }

    Ex5:
    // Utiliser un générateur comme propriété
    const monObj = {
      *generator () {
        yield "a";
        yield "b";
      }
    }
    const gen = monObj.generator();
    console.log(gen.next()); // { value: "a", done: false }
    console.log(gen.next()); // { value: "b", done: false }
    console.log(gen.next()); // { value: undefined, done: true }

    Ex6:
    // Utiliser un générateur comme propriété calculée
    class Toto {
      *[Symbol.iterator] () {
        yield 1;
        yield 2;
      }
    }
    const monObj = {
      *[Symbol.iterator] () {
        yield "a";
        yield "b";
      }
    }
    console.log(Array.from(new Toto)); // [1, 2]
    console.log(Array.from(monObj));   // [ "a", "b"]

    Ex7:
    // Générateur défini avec une expression
    const toto = function* () {
      yield 10;
      yield 20;
    };
    const truc = toto();
    console.log(truc.next()); // {value: 10, done: false}
