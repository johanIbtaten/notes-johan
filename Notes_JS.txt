    Variables
    Le hoisting ou remontée des variables
    Évaluation de variables
    Les bouléens
    var, let, const
    Affectation par décomposition (Destructuring en anglais)
    Types de données
    Les opérateurs d'égalité
    Différence entre undefined et null
    Double ou simple quotes ou accent grave (backquote ou backtick en anglais)
    Opérateur void
    L'opérateur this
    La « remontée » des déclarations de fonction
    Définition d'un littéral
    Littéraux de gabarits (template strings en anglais)
    Les différents types de fonctions
    Les expressions de fonctions
    Les fonctions flechées (arrow function en anglais)
    IIFE (Expression de fonction invoquée immédiatement)
    Objet Map
    Object Property Value Shorthand
    Boucles
    Fonctions sur les tableaux
        FOREACH()
        CONSOLE.TABLE()
        REDUCE()
        MAP()
        ENTRIES()
        FROM()
        SLICE()
        FILTER()
        INCLUDES()
    Méthodes sur les objets
        KEYS()
        ASSIGN()
    Méthodes sur les fonctions
        CALL()
        APPLY()
        BIND()
    Méthodes sur les chaînes de caratères
        INCLUDES()
    Rest parameters
    Spread operator (opérateur de décomposition)
    Le protocole « itérable » (Objets itérables)
    Le protocole « itérateur »
    Les générateurs function*
    Héritage et chaîne de prototype
    Les différentes façons de créer des objets et les impacts sur la chaîne de prototype
    Comparer des objets
    Utiliser this
    Promise, Async et Await
    Fetch
    AJAX
    Les modules JavaScript import / export



Variables
-------------------------------
1. Les noms des variables sont appelés identifiants.

2. Un identifiant JavaScript doit commencer par une lettre, un tiret bas (_) ou un symbole dollar ($).

3. Javascript est sensible à la casse (aux majuscules et minuscules).

4. On peut aussi utiliser la plupart lettres Unicode ou ISO 8859-1 (comme å et ü, pour plus de détails, au sein des identifiants).


Le hoisting ou remontée des variables
-------------------------------
1. Avant d'être exécuté, l'interpréteur va remonter toutes les déclarations de variables et de fonctions 
tout en haut de leur contexte d'exécution.

2. Il existe deux types de contexte :
La fonction dans laquelle la déclaration a été faite
Le contexte d'exécution globale si la déclaration a été faite en dehors de toute fonction

    Ex1:
    console.log(a);
    var a = 2;
    // Affiche undefined
    // L'interpréteur va remonter la déclaration de la variable avant le reste
    // Le code ci-dessus revient à écrire
    var a;
    console.log(a);
    a = 2;

    Ex2:
    a = 2;
    console.log(a);
    var a;
    // Affiche 2
    // Le code ci-dessus revient à écrire
    var a;
    a = 1;
    console.log(a);

    Ex3:
    var f = 'foo';
    foo();
    function foo() {
      console.log(f);
      var f = 'bar';
    }
    // f affiche undefined
    // Le code ci-dessus revient à écrire
    function foo() {
      var f;
      console.log(f);
      f = 'bar';
    }
    var f;
    f = 'foo';
    foo();
    // L'une est dans le contexte global, tandis que l'autre se trouve dans celui de la fonction. 
    // Elles sont remontées, mais pas au même niveau. Voilà pourquoi on obtient undefined à l'exécution de foo.

3. Faire attention à bien déclarer vos variables au tout début de votre code.




Évaluation de variables
-------------------------------
1. Une variable déclarée (déclaration) grâce à l'instruction var ou let sans valeur initiale définie (affectation ou initialisation ou  assignation) vaudra undefined.

    Ex1:
    var a;
    console.log("La valeur de a est " + a); // La valeur de a est undefined

    console.log("La valeur de b est " + b); // La valeur de b est undefined 
    var b; // La déclaration de la variable est "remontée"

    let y;
    console.log("La valeur de y est " + y); // La valeur de y est undefined

2. Toute variable non déclarée devient une variable globale. 
Elle est accessible depuis n'importe quelle ligne de code, qu'elle soit dans une fonction ou non.

    Ex1:
    uneVariableGlobale = 'Hello world';
    
    Ex2:
    function foo() {
      try {
        console.log(f);
      }
      catch (ex) {
        console.log("f n'existe pas");
      }
      f = 'bar'; // Variable globale
    }
    foo();
    foo();
    // affiche "f n'existe pas"
    // affiche bar


3. Tenter d'accéder à une variable qui n'a pas été déclarée ou tenter d'accéder à un identifiant déclaré 
avec let avant sa déclaration provoquera l'envoi d'une exception ReferenceError

    Ex1:
    console.log("La valeur de m est " + m); // signale une exception ReferenceError

    console.log("La valeur de x est " + x); // signale une exception ReferenceError
    let x;

4. Il est possible d'utiliser undefined pour déterminer si une variable possède une valeur. 

    Ex1:
    // La condition de l'instruction if sera validée car la variable n'a pas été initialisée (affectée) (elle a simplement été déclarée)
    var input;
    if (typeof input === undefined){
      faireCeci();
    } else {
      faireCela();
    }

5. La valeur undefined se comporte comme le booléen false lorsqu'elle est utilisée dans un contexte booléen.

    Ex1:
    // Le code qui suit exécutera la fonction maFonction puisque le premier élément de monTableau n'est pas défini
    var monTableau = new Array();
    if (!monTableau[0]){
      maFunction(); 
    }

6. La valeur undefined est convertie en NaN (pour Not a Number : « n'est pas un nombre ») lorsqu'elle est utilisée dans un contexte numérique.

    Ex1:
    var a;
    a + 2; // NaN

7. Une variable valant null sera toujours considérée comme 0 dans un contexte numérique et comme false dans un contexte booléen.

    Ex1:
    var n = null;
    console.log(n * 32); // Le log affichera 0


Les booléens
-------------------------------
1. Dans un contexte booléen, si la valeur d'une variable 
est omise ou est 0, -0, null, false, NaN, undefined ou une chaine de caractères vide (""), 
son évaluation est à false (faux).
Toutes les autres valeurs d'une variable, y compris n'importe quel objet, 
un tableau vide ([]), ou une chaine de caractères "false", 
est évaluer avec une valeur initiale à true (vrai).

    Ex1:
    // En javascript, l'opérateur || retourne la première valeur évaluée à true.
    // Tester si une variable est définie en javascript
    var language;
    var info = language || "en"; // langage vaut false car la variable renvoie undefined
    console.log(info) // "en"


var, let, const
-------------------------------
Déclaration (var a;) initialisation : var a=2;
Déclaration (let a;) initialisation : let a=2;
Déclaration, initialisation : const a=2;
Scope (ou Portée en français)

var   : Scope dans les fonctions 
        Pas de scope dans les blocs (blocs types if, for, while, etc.)
        Si var est déclaré sans valeur initiale (ex: var a;) elle aura la valeur undefined
        
        Lorsqu'une variable est déclarée avec var en dehors des fonctions, elle est appelée variable globale 
        car elle est disponible pour tout le code contenu dans le document. 
        Lorsqu'une variable est déclarée dans une fonction, elle est appelée variable locale 
        car elle n'est disponible qu'au sein de cette fonction.

let   : Scope dans les fonctions 
        Scope dans les blocs (blocs types if, for, while, etc.)
        Si let est déclaré sans valeur initiale (ex: let a;) elle aura la valeur undefined
        On déclare une variable dont la portée est celle du bloc courant, éventuellement en initialisant sa valeur

const : Scope dans les fonctions 
        Scope dans les blocs (blocs types if, for, while, etc.)
        const a besoin d'être déclaré avec une valeur initiale (ex: const a=2;)
        const est accessible en lecture seule
	      On ne peut pas réassigner la valeur d'une constante (ex: a=4;)
        On ne peut pas re-déclarer dans la même portée une autre constante avec le même nom (ex: const a=4;)
        Il est impossible de déclarer une constante avec le même nom qu'une autre variable ou fonction dans la même portée.

        Ex1:
        // Renverra une erreur
        function f() {};
        const f = 5;

        // Renverra également une erreur
        function f() {
          const g = 5;
          var g;
          //instructions
        }

        On peut ajouter ou supprimer les éléments d'un tableau dans une const
        On ne peut pas changer la structure d'un objet littéral dans une const
        On peut changer les valeurs d'un objet littéral dans un const


Affectation par décomposition (Destructuring en anglais)
-------------------------------
1. L'affectation par décomposition (destructuring en anglais) est une expression JavaScript qui permet d'extraire (unpack en anglais) 
des données d'un tableau ou d'un objet grâce à une syntaxe dont la forme ressemble à la structure du tableau ou de l'objet.

    Ex1:
    var a, b, rest;

    // Pour un array
    [a, b] = [10, 20];
    console.log(a); // 10
    console.log(b); // 20
    [a, b, ...rest] = [10, 20, 30, 40, 50];
    console.log(rest); // [30,40,50]
    // expected output: 

    // Pour un objet
    ({a, b} = {a: 10, b: 20}); // Ne pas oublier les parenthèses
    console.log(a); // 10
    console.log(b); // 20
    // Proposition de syntaxe (niveau 4)
    ({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
    console.log(a); // 10
    console.log(b); // 20
    console.log(rest); // {c: 30, d: 40}

    Ex2:
    var x = [1, 2, 3, 4, 5]; // On crée un "paquet" de donnée
    var [y, z] = x; // On utilise l'affectation par décomposition
    console.log(y); // 1
    console.log(z); // 2

    Ex3:
//Décomposition d'un tableau    
    var toto = ["un", "deux", "trois"];
    // sans utiliser la décomposition
    var un    = toto[0];
    var deux  = toto[1];
    var trois = toto[2];
    // en utilisant la décomposition
    var [un, deux, trois] = toto;

// Affectation sans déclaration
    var a, b;
    [a, b] = [1, 2];
    console.log(a);  // 1
    console.log(b);  // 2

// Valeurs par défaut 
    // On peut définir une valeur par défaut au cas où 
    // la valeur extraite du tableau soit undefined.
    var a, b;
    [a = 5, b = 7] = [1];
    console.log(a); // 1
    console.log(b); // 7

// Échange de variables
    var a = 1;
    var b = 3;
    [a, b] = [b, a];
    console.log(a); // 3
    console.log(b); // 1

// Renvoyer plusieurs valeurs
    function f() {
      return [1, 2];
    }
    var a, b;
    [a, b] = f();
    console.log("A vaut " + a + " B vaut " + b); // a vaut 1 et b vaut 2

// Ignorer certaines valeurs
    function f() {
      return [1, 2, 3];
    }
    var [a, , b] = f();
    console.log("A vaut " + a + " B vaut " + b); 
    // a égal à 1 et b égal à 3
    // La valeur 2 est ignorée
    [,,] = f(); // ignore toutes les valeurs

// Affecter le reste d'un tableau à une variable
    var [a, ...b] = [1, 2, 3];
    console.log(a); // 1
    console.log(b); // [2, 3]
    var [a, ...b,] = [1, 2, 3] 
    // SyntaxError : un élément du reste ne peut pas avoir
    //               de virgule à la fin

    Ex4:
// Décomposer un objet
    var o = {
      p: 42, 
      q: true
    };
    var {p, q} = o;
    console.log(p); // 42
    console.log(q); // true 

// Assign new variable names
    var {p: toto, q: truc} = o;
    console.log(toto); // 42
    console.log(truc); // true

// Affectation sans déclaration
    var a, b;
    ({a, b} = {a:1, b:2});
    // Les parenthèses ( ... ) utilisées autour de l'instruction sont nécessaires 
    // pour que la partie gauche soit bien interprétée comme un objet littéral 
    // et non comme un bloc. Il est également nécessaire d'avoir 
    // un point-virgule avant les parenthèses de l'instruction car sinon, 
    // ces parenthèses peuvent être interprétées comme un appel de fonction.

// Affecter avec un nom différent
    var o = {
      p: 42, 
      q: true
    };
    var {p: toto, q: truc} = o;
    console.log(toto); // 42
    console.log(truc); // true

// Valeurs par défaut
    // Une variable peut recevoir une valeur par défaut lors de la décomposition 
    // si la propriété correspondante de l'objet vaut undefined.
    var {a = 10; b = 5} = {a: 3};
    console.log(a); // 3
    console.log(b); // 5

// Affecter de nouveaux noms aux variables et fournir des valeurs par défaut
    var {a: aa = 10, b: bb = 5} = {a: 3};
    console.log(aa); // 3
    console.log(bb); // 5

    Ex5:
// Arguments par défaut d'une fonction
    // Avant ES6
    function dessinGrapheES5(options) {
      options = options === undefined ? {} : options;
      var size = options.size === undefined ? 'big' : options.size;
      var coords = options.coords === undefined ? { x: 0, y: 0 } : options.coords;
      var radius = options.radius === undefined ? 25 : options.radius;
      console.log(size, coords, radius);
      // seulement ensuite on dessine le graphe
    }
    dessinGrapheES5({
      coords: { x: 18, y: 30 },
      radius: 30
    });

    // Avec ES6
    function dessinGrapheES2015({size = 'big', coords = { x: 0, y: 0 }, radius = 25} = {})
    {
      console.log(size, coords, radius);
      // on dessine le graphe
    }
    dessinGrapheES2015({
      coords: { x: 18, y: 30 },
      radius: 30
    });
    // On aurait également pu écrire la fonction sans cet objet vide (= {}) mais, dans ce cas, 
    // il aurait fallu au moins un argument pour utiliser la fonction. Avec cette « forme », 
    //dessinGrapheES2015() pourra être appelée sans paramètre.

// Décomposition imbriquée avec objets et tableaux
    const metadata = {
        title: "Scratchpad",
        translations: [
          {
            locale: "de",
            localization_tags: [ ],
            last_edit: "2014-04-14T08:43:37",
            url: "/de/docs/Tools/Scratchpad",
            title: "JavaScript-Umgebung"
          }
        ],
        url: "/en-US/docs/Tools/Scratchpad"
    };
    let { title: englishTitle, translations: [{ title: localeTitle }] } = metadata;
    console.log(englishTitle); // "Scratchpad"
    console.log(localeTitle);  // "JavaScript-Umgebung"

    var objetCompliqué = {
      propTableau: [
        "Zapp",
        { second: "Brannigan" }
      ]
    };
    var { propTableau: [premier, { second }] } = objetCompliqué;
    console.log(premier);
    // "Zapp"
    console.log(second);
    // "Brannigan"

// Décomposition et utilisation de for of
    var personnes = [
      {
        nom: "Alain Dupont",
        famille: {
          mère: "Isabelle Dupont",
          père: "Jean Dupont",
          sœur: "Laure Dupont"
        },
        âge: 35
      },
      {
        nom: "Luc Marchetoile",
        famille: {
          mère: "Patricia Marchetoile",
          père: "Antonin Marchetoile",
          frère: "Yann Marchetoile"
        },
        âge: 25
      }
    ];
    for (var {nom: n, famille: { père: f } } of personnes) {
      console.log("Nom : " + n + ", Père : " + f);
    }
    // "Nom : Alain Dupont, Père : Jean Dupont"
    // "Nom : Luc Marchetoile, Père : Antonin Marchetoile"

// Décomposer les propriétés d'objets passés en arguments
    function userId({id}) {
      return id;
    }
    function whois({displayName: displayName, fullName: {firstName: name}}){
      console.log(displayName + " est " + name);
    }
    var user = { 
      id: 42, 
      displayName: "jbiche",
      fullName: { 
          firstName: "Jean",
          lastName: "Biche"
      }
    };
    console.log("userId: " + userId(user)); // "userId: 42"
    whois(user); // "jbiche est Jean"
    // Cela permet d'accéder directement à id, displayName et firstName depuis l'objet user.

// Noms de propriétés calculés et la décomposition
    let clé = "z";
    let { [clé]: toto } = { z: "truc" };
    console.log(toto); // "truc"

// Combiner la décomposition de tableaux et d'objets
    const props = [
      { id: 1, nom: "Toto"},
      { id: 2, nom: "Truc"},
      { id: 3, nom: "Bidule"}
    ];
    const [,, {nom}] = props;
    console.log(nom); // Bidule
    

Types de données
-------------------------------
Numbers — var age = 23
Variables — var x
Text (strings) — var a = "init"
Operations — var b = 1 + 2 + 3
True or false statements (boolean) — var c = true
Constant numbers — const PI = 3.14
Objects — var name = {firstName:"John", lastName:"Doe"}
Undefined — var a; console.log(a); retourne undefined
Null  — var a = null

1. Excepté dans les cas de null ou undefined, pour chaque valeur primitive il existe un objet équivalent 
qui la contient:
String pour la primitive string ;
Number pour la primitive number ;
Boolean pour la primitive boolean ;
Symbol pour la primitive symbol


Les opérateurs d'égalité
-------------------------------
/// Égalité simple (==) ///
1. L'opérateur d'égalité simple convertit les deux opérandes s'ils ne sont pas du même type, 
ensuite la comparaison stricte est appliquée. Si les deux opérandes sont des objets, le moteur JavaScript 
comparera les références internes pour voir si elles réfèrent au même objet en mémoire.

    Ex1:
    1  ==  1;        // true
    "1"  ==  1;        // true
    1  == '1';       // true
    0  == false;     // true
    0  == null;      // false
    0  == undefined  // false
    null == undefined  // true
    var obj1 = { "clé": "valeur"};
    var obj2 = { "clé": "valeur"};
    obj1 == obj2       // false

2. Lorsqu'une comparaison est opérée entre une chaîne de caractères et un nombre, 
Javascript tente de convertir la chaine en une valeur numérique. Une valeur mathématique est 
obtenue à partir de la chaîne littérale numérique, puis celle-ci est arrondie à une valeur de type Nombre.

3. Si l'un des opérandes est de type booléen, true sera converti en 1 et false en +0.

4. Si on compare un objet avec un nombre ou une chaîne, le moteur JavaScript tentera de renvoyer la valeur par défaut de l'objet. 
Les opérateurs opèrent une conversion grâce aux méthodes valueOf (pour obtenir un nombre) et toString (pour obtenir une chaîne de caractères). 
Si cela ne fonctionne pas, une exception sera levée. Un objet sera converti en un type primitif autre uniquement si l'autre 
opérande est un type primitif (autre qu'objet). Si les deux opérandes sont des objets, 
ils seront comparés comme deux objets (voir ci-avant) et l'égalité ne sera vérifiée que si les opérandes font référence au même objet en mémoire

    Ex1:
    // true car les deux opérandes sont du type primitif chaîne de caractères
    'toto' === 'toto'
    var a = new String('toto');
    var b = new String('toto');
    // false car a et b sont du type objet mais font référence à deux objets distincts
    a == b 
    // false car a et b sont du type objet mais font référence à deux objets distincts
    a === b 
    // true car a et 'toto' sont de type différents et lorsque a est
    // converti, la fonction de conversion renvoie bien la chaîne 'toto'
    a == 'toto'

/// Égalité stricte (===) ///
1. L'opérateur d'égalité stricte renvoie true si les opérandes sont strictement égaux (voir ci-avant), aucune conversion de type n'est effectuée.

    Ex1:
    3 === 3   // true
    3 === '3' // false
    var objet1 = {'clé': 'valeur'}, objet2 = {'clé', 'valeur'};
    objet1 === objet2; // false


Différence entre undefined et null
-------------------------------
/// undefined : ///
1. Une variable possède la valeur undefined si elle n'est pas déclarée ou si elle est déclarée mais n'a pas encore eu de valeur d'assignée.

    Ex1: 
    var maVariable;
    alert(maVariable); // Le texte undefined s'affichera à l'écran, car la variable est non définie.
   
    Ex2: 
    function direBonjour(message) {
      console.log(message)
    }
    direBonjour(); // Le texte undefined s'affichera à l'écran, car la variable message déclarée en paramètre est non définie.

2. Il y a une faille dans JavaScript à connaître : le mot undefined n'est pas un mot-clé du langage. Il est donc possible de nommer une variable undefined, puis de lui attribuer une valeur.

    Ex1: 
    var undefined = toto; //Cette déclaration n'est pas fausse, contrairement à ce que l'on pourrait croire.
    if(maVariable === undefined) {
      alert(Vous avez été trompés!);
    }

3. Pour tester si une variable n'a pas été déclaré ou assignée, il faut utiliser typeof. 
typeof renvoie une chaîne qui indique le type de l'opérande (Quantité, donnée qui entre dans une opération arithmétique, une instruction informatique).

    Ex1:
    if (typeof maVariable === "undefined") {
      alert("La variable maVariable n'est pas définie");
    }

    Ex2:
    var x;
    if (typeof x === 'undefined') {
       // ces instructions seront exécutées
    }
    if (typeof x !== 'undefined') {
       // ces instructions ne seront pas exécutées
    }

4. Pour tester si une propriété d'objet est indéfinie on peut aussi utiliser typeof

    Ex1:
    const list = []
    const count = 2
    typeof list // "object"
    typeof count // "number"
    typeof "test" // "string"
    typeof color // "undefined"
    const car = {
      model: 'Fiesta'
    }
    if (typeof car.color === "undefined") {
      // color is undefined
    }

5. Une fonction qui n'a pas de valeur de return affiche undefined

    Ex1:
    function add() {
      const a = 3;
    }
    add(); // affiche undefined

/// null : ///
1. null sert à définir l'absence de valeur, on s'en sert par exemple pour assigner une valeur par défaut à des variables ou des paramètres de fonction, c'est une méthode beaucoup plus propre que d'assigner une valeur arbitraire comme 0 pour un entier, ou une chaine de caractère vide pour une chaine de caractère.

    Ex1:
    // toto n'existe pas, n'a pas été défini (déclaré) et n'a jamais été initialisé (assigné)
    toto;
    "ReferenceError: toto is not defined"
    // toto existe mais n'a ni type ni valeur
    var toto = null;
    console.log(toto); // null

    Ex2:
    function direBonjour(message = null) { // Valeur par défaut de message égale à null
      console.log(message); // null
    }

    Ex3:
    typeof null;           // "object" (pas null pour des raisons historiques)
    typeof undefined;      // "undefined"
    null === undefined;    // false
    null == undefined;    // true
    null === null;         // true
    null == null;         // true
    !null;                 // true
    isNaN(1 + null);       // false
    isNaN(1 + undefined);  // true


Double ou simple quotes ou accent grave (backquote ou backtick en anglais)
-------------------------------
1. C'est selon les préférences. L'avantage des doubles quotes est qu'il permet d'échapper les apostrophes et se conforme à JSON

    Ex1:
    alert('Say "Hello"');
    alert("Say 'Hello'");
    alert("It's \"game\" time.");
    alert('It\'s "game" time.');

2. En ES6 on peut aussi utiliser les template literals

    Ex1:
    alert(`Use "double" and 'single' quotes in the same string`);
    alert(`Escape the \` back-tick character and the \${ dollar-brace sequence in a string`);


Opérateur void
-------------------------------
1. L'opérateur void évalue (exécute) l'expression donnée void(0) équivaut à void 0 et retourne ensuite undefined.
    
    Ex1:
    void 2 == '2';    // renvoie false, attention à la précédence et donc mieux vaut utiliser des parenthèses
    void (2 === '2'); // renvoie undefined

2. On peut utiliser void pour ajouter un comportement preventDefault () pour un lien
    
    Ex1:
    <a href="javascript: void(0)"> À propos de </a>

3. On peut utiliser void pour qu'une function retourne undefined même si elle possède une valeur de retour.
    
    Ex1:
    function add() {
      const a = 3; return a
    };
    console.log(add()); // affiche 3
    console.log(void add()); // affiche undefined


L'opérateur this
-------------------------------
1. this est un opérateur qui permet de retourner une valeur en fonction de son contexte. Deux éléments peuvent influer dessus :
- Le contexte dans lequel this est appelé : global, fonction, fonction fléchée, méthode d'un objet…
- Le mode utilisé : strict ou non-strict.
Attention par contre, quand this est utilisé sans qu'il soit défini à son appel.
Grâce à apply() et call(), il est en effet possible de définir une valeur de this au sein de la fonction, 
ce qui change forcément l'utilisation que l'on peut en faire.

    Ex1:
    // Un objet peut être passé en premier argument
    // de call ou de apply
    var obj = { a: "Toto" };

    // Ici, on définit une propriété sur l'objet
    // global
    var a = "Global";

    function whatsThis(arg) {
      // La valeur de this ici dépend de la façon
      // dont la fonction est appelée
      return this.a;
    }

    whatsThis();          // "Global"
    whatsThis.call(obj);  // "Toto"
    whatsThis.apply(obj); // "Toto"

2. this dans un contexte global
Le contexte global, c'est lorsque l'on exécute du code en dehors de toute fonction, de tout bloc. 
Si on utilise this dans ce contexte, il retourne l'objet global.

    Ex1:
    console.log(this); // Dans un navigateur, cela retourne l'objet DOM window    
    this.alert('Message'); // Ouvre une boite de dialogue avec comme contenu : "Message".    
    window.alert('Message'); // C'est donc le même résultat que window.alert()    

    Ex2:
    // En mode strict, this retourne exactement la même chose qu'en mode non-strict
    "use strict";
    console.log(this);
    // Retourne l'objet DOM window dans le navigateur

3. this dans une fonction classique
Lorsque l'on utilise this dans une fonction classique, il retourne un objet, 
l'objet global (comme si on l'utilise hors de toute fonction).

    Ex1:
    function maFonction() {
      return this;
    }
    maFonction();
    // Dans un navigateur, cela retourne l'objet global window
    
    Ex2:
    // En mode strict, c'est un peu différent, this retourne undefined
    "use strict";

4. this dans une fonction fléchée (arrow function)
Le cas des fonctions fléchées est un peu particulier car elles ne créent pas de nouveau contexte. 
Du coup, la valeur de this reprend celle du contexte dans laquelle la fonction est définie.

    Ex1:
    const maFonction = () => { return this };
    maFonction();
    // Retourne window dans mon navigateur, this ayant la valeur de l'objet global.

    Ex2:
    // Si on utilise this dans une fonction fléchée définie dans une méthode d'un objet, 
    // this retourne bien l'objet
    const commentaire = {
      getAuthor: function() {
        const value = (() => this);
        return value;
      },
    };
    const test = commentaire.getAuthor();
    console.log(test());
    // Retourne bien l'objet complet

    Ex3:
    // En mode strict, le comportement est exactement le même
    const maFonction = () => { "use strict"; return this };
    maFonction();
    // Retourne window dans mon navigateur, this ayant la valeur de l'objet global.

5. this dans une méthode d'un objet
En POO, il est souvent nécessaire d'accéder aux propriétés et méthodes de l'objet courant pour 
les utiliser ailleurs. this est parfait pour y faire référence. Dans ce contexte, 
this retourne l'objet dans lequel la méthode est définie. 

    Ex1:
    const commentaire = {
      id: 7,
      author: 'Jean',
      content: 'Juste un simple commentaire',
      getAuthor: function(){
        return this.author
      },
    };
    commentaire.getAuthor();
    // Retourne 'Jean', this faisant référence à notre objet commentaire, this.author correspond à l'auteur de commentaire.

    Ex2:
    // En mode strict, le comportement est exactement le même
    "use strict";
    const article = {
      title: 'Un article',
      content: 'Contenu de mon article',
    };
    article.getTitle = function(){
      return this.title;
    };
    article.getTitle();
    // Retourne bien "Un article"

6. this dans une méthode de type constructeur
this fait référence à l’objet nouvellement créé.

    Ex1:
    function Jeu(){
      this.points = 120;
    }
    var j = new Jeu();
    console.log(Jeu.points);
    // Retourne 120
    // En mode strict, la valeur de this est similaire au mode non-strict

7. Voir https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_this

La « remontée » des déclarations de fonction
-------------------------------
1. Lorsqu'on utilise une déclaration de fonction pour créer une fonction, la définition de la fonction 
est « remontée » (hoisting). Il devient donc possible d'utiliser la fonction avant de l'avoir déclarée.
    
    Ex1:
    remontee(); // affiche "toto" dans la console
    function remontee() {
      console.log("toto");
    }

2. En tant qu'expression de fonction, l'interpréteur JavaScript ne va ni plus ni moins que remonter 
la déclaration de la variable et laisser l'affectation à son emplacement initial. Cela revient donc à écrire le code suivant.
    
    Ex1:
    foo();
    var foo = function() {
      console.log('foo');
    }
    // Affiche "Uncaught TypeError : foo is not a function"
    // Le code ci-dessus revient à écrire
    var foo;
    foo();
    foo = function() {
    console.log('foo');
    }

3. Il faut donc bien faire la distinction entre expression et déclaration de fonction, 
car l'interpréteur va les traiter de manière différente l'une de l'autre.

Définition d'un littéral
-------------------------------
En programmation informatique, une valeur littérale est une valeur donnée explicitement dans le code source d'un programme


Littéraux de gabarits (template strings en anglais)
-------------------------------
1. Les littéraux de gabarits sont des littéraux de chaînes de caractères permettant d'intégrer des expressions. 
Avec eux, on peut utiliser des chaînes de caractères multi-lignes et des fonctionnalités d'interpolation.
Pour utiliser des accents graves dans un gabarit, on les échappera avec une barre oblique inverse (\)

    Ex1:
    `texte`

    `ligne de texte 1
    ligne de texte 2`

    `texte ${expression} texte`

    etiquette `texte ${expression} texte`

    Ex2:
    // Les chaînes de caractères multi-lignes
    // Sans template strings
    console.log(
    'ligne de texte 1\n'+
    'ligne de texte 2'
    );
    // "ligne de texte 1
    // ligne de texte 2"

    // Avec template strings
    console.log(
    `ligne de texte 1
    ligne de texte 2`
    );
    // "ligne de texte 1
    //  ligne de texte 2"

    Ex3:
    // Interpolation d'expressions
    var a = 5;
    var b = 10;
    console.log(`Quinze vaut ${a + b}
    et non ${2 * a + b}.`);
    // "Quinze vaut 15 et
    // non 20."

    Ex4:
    // Imbrication de gabarits
    // Avant ES6
    var classes = 'header'
    classes += (isLargeScreen() ? '' : item.isCollapsed ? ' icon-expander' : ' icon-collapser');

    // Avec ES6 avec des gabarits et sans imbrication
    const classes = `header ${ isLargeScreen() ? '' : (item.isCollapsed ? 'icon-expander' : 'icon-collapser') }`;

    // Avec ES6 avec des gabarits imbriqués
    const classes = `header ${ isLargeScreen() ? '' : `icon-${item.isCollapsed ? 'expander' : 'collapser'}` }`;

2. Les gabarits étiquetés (tagged templates) sont une forme plus avancée de gabarits. On peut ici utiliser une fonction pour analyser les différents fragments du gabarit. 
Le premier argument passé à la fonction est l'ensemble de valeurs issues de chaînes de caractères sous la forme d'un tableau. 
Les arguments ensuite passés à la fonction seront les expressions contenues dans le gabarit. 
La fonction pourra ainsi créer une chaîne avec une autre forme de concaténation et utiliser une logique spécifique. 
La fonction utilisée pour le formatage du gabarit peut être nommée comme n'importe quelle autre fonction.

    Ex1:
    var personne = 'Michou';
    var age = 28;

    function monEtiquette(chaines, expPersonne, expAge) {
      var chn0 = chaines[0]; // "ce "
      var chn1 = chaines[1]; // " est un "

      // Techniquement, il y a une chaîne après
      // l'expression finale (dans notre exemple),
      // mais elle est vide (""), donc ne pas en tenir compte.
      // var chn2 = chaines[2];

      var chnAge;
      if (expAge > 99){
        chnAge = 'centenaire';
      } else {
        chnAge = 'jeunot';
      }
      // On peut tout à fait renvoyer une chaîne construite
      // avec un gabarit
      return `${chn0}${expPersonne}${chn1}${chnAge}`;
    }
    var sortie = monEtiquette`ce ${ personne } est un ${ age }`;
    console.log(sortie);
    // ce Michou est un jeunot

    Ex2:
    // Lors de l'exécution, le contenu du littéral est transmis à la fonction
    // strings : reçoit dans un tableau les chaînes intermédiaires (« Le résultat de la somme de » , « et » , « est ») ;
    // ...values : reçoit dans un tableau les valeurs des interpolations (a, b et a + b)
    var a = 2.3265;
    var b = 5.02154;
    function tag(strings, ...values) {
      var sortie = strings[0]
      + values[0].toFixed(2)
      + strings[1]
      + values[1].toFixed(2)
      + strings[2]
      + values[2].toFixed(2);
      return sortie;
    }
    var message = tag`Le résultat de la somme de ${a} et ${b} est ${a + b}`;

3. La propriété spéciale raw, disponible sur le premier argument de la fonction du gabarit étiqueté, vous permet d'accéder aux chaînes brutes, 
telles qu'elles ont été entrées, sans traiter les séquences d'échappement.

    Ex1:
    function etiquette(chaines) {
      console.log(chaines.raw[0]);
    }
    etiquette`ligne de texte 1 \n ligne de texte 2`;
    // affichera dans la console : 
    // "ligne de texte 1 \n ligne de texte 2"

    Ex2:
    // La méthode String.raw() a pour fonction de créer des chaînes de caractères brutes, 
    // exactement comme la fonction de gabarit et de concaténation de chaînes par défaut
    var chn = String.raw`Salut\n${2+3}!`; 
    // "Salut\n5!"
    chn.length;
    // 9
    chn.split('').join(',');
    // "S,a,l,u,t,\,n,5,!"
  

Les différents types de fonctions
-------------------------------
1. Une fonction anonyme est une fonction sans nom de fonction
    Ex1:    
    function () {};
    // ou en utilisant la notation de flèche de ECMAScript 2015
    () => {};

2. Une fonction nommée est une fonction avec un nom de fonction
    Ex1:
    function foo() {};
    // ou en utilisant la notation de flèche de ECMAScript 2015
    const foo = () => {};

3. Une fonction imbriquée (ou fonction interne) est une fonction à l'intérieur d'une autre fonction (square dans l'exemple suivant). 
Une fonction externe est une fonction qui contient une fonction (addSquares dans l'exemple suivant)
    Ex1:
    function addSquares(a,b) {
      function square(x) {
          return x * x;
      }
      return square(a) + square(b);
    };
    //En utilisant la notation de flèche de ECMAScript 2015
    const addSquares = (a,b) => {
      const square = x => x*x;
      return square(a) + square(b);
    };

4. Une fonction récursive est une fonction qui fait appel à elle-même
    Ex1:
    function loop(x) {
      if (x >= 10)
          return;
      loop(x + 1);
    };
    //En utilisant la notation de flèche de ECMAScript 2015
    const loop = x => {
      if (x >= 10)
          return;
      loop(x + 1);
    };

5. Une expression de fonction invoquée immédiatement (IIFE) est une fonction appelée directement après le chargement de la fonction dans le compilateur du navigateur. 
La façon d'identifier une IIFE est de localiser les parenthèses gauche et droite supplémentaires à la fin de la déclaration de la fonction.
    Ex1:
    (function foo() {
        console.log("Hello Foo");
    }());


L'objet arguments
-------------------------------
1. Les arguments d'une fonction sont maintenus dans un objet semblable à un tableau. 
Dans une fonction, il est possible d'utiliser les arguments passés 
à la fonction de la façon suivante : arguments[i]
ù i représente l'index ordinal de l'argument (le premier argument ayant un indice à 0). On accède donc au premier argument avec arguments[0]. 
Le nombre total d'arguments est fourni grâce à arguments.length. En utilisant l'objet arguments, il est possible de recenser 
les arguments supplémentaires fournis à la fonction si jamais il y a plus d'arguments fournis que requis. 
Cet objet est souvent utile si on ne connaît pas le nombre d'arguments passés à la fonction. 
La propriété arguments.length permet de déterminer le nombre d'arguments réellement passés à la fonction. 
On peut donc ensuite accéder aux différents arguments en parcourant l'objet arguments.
    Ex1:
    // Fonction qui concatène plusieurs chaînes
    // Le seul argument formellement défini sera la chaîne utilisée comme séparateur 
    // pour concaténer les différentes chaînes. 
    function monConcat(séparateur) {
      var result = ""; // on initialise la liste
      var i;
      // on parcourt les arguments
      for (i = 1; i < arguments.length; i++) {
          result += arguments[i] + séparateur;
      }
      return result;
    }
    // On peut passer autant d'arguments que nécessaire à cette fonction. Ils seront tous concaténés dans une chaîne finale
    // renverra "rouge, orange, bleu, "
    monConcat(", ", "red", "orange", "blue");

    // renverra "éléphant; girafe; lion; singe; "
    monConcat("; ", "éléphant", "girafe", "lion", "singe");

    // renverra "sauge. basilic. origan. poivre. échalotte. "
    monConcat(". ", "sauge", "basilic", "origan", "poivre", "échalotte");    

Les expressions de fonctions
-------------------------------
1. Une expression de fonction est très similaire et a presque la même syntaxe qu'une déclaration de fonction. La différence principale entre une expression de fonction et une instruction est le nom de la fonction. En effet, pour les expressions, celui peut être omis (on parle alors d'une fonction anonyme). 
    Ex1:
    var getRectArea = function(width, height) {
    return width * height;
    }
    console.log(getRectArea(3,4));
    // expected output: 12    

2. En JavaScript, les expressions de fonction ne sont pas remontées (à la différence des déclarations de fonction). Il est donc impossible d'utiliser les expressions de fonction avant leur définition.
    Ex1:
    nonRemontée(); // TypeError: nonRemontée is not a function
    var nonRemontée = function() {
      console.log("truc");
    }

3. On peut utiliser une expression de fonction pour créer une « IIFE » (Immediately Invoked Function Expression), c'est-à-dire une expression de fonction qu'on appelle dès sa définition.
    Ex1:
    var a = "coucou";
    var b = "monde";
    // IIFE
    (function(x, y) {
      console.log(x + " " + y);
    })(a, b);
    // coucou monde


Les fonctions flechées (arrow function en anglais)
-------------------------------
    // Avant ES6
    const add = function(x, y) {
        return x + y
    }
    console.log(add(5, 4)) // 9
1. Une expression de fonction fléchée permet d'avoir une syntaxe plus courte que les expressions de fonction. Les fonctions fléchées sont souvent anonymes et ne sont pas destinées à être utilisées pour déclarer des méthodes.    
    Ex1:    
    // ES6
    const addES6 = (x, y) => { return x + y }
    console.log(addES6(5, 6)) // 11

2. Les accolades ne sont même pas obligatoire ici et le mot clé return aussi, parce que l'on renvoie une seule instruction.
    Ex1:
    // ES6
    const addES6 = (x, y) => x + y
    console.log(addES6(5, 6)) // 11

3. Quand on a un seul paramètre, nous n'avons donc pas besoin des parenthèses, on renseigne juste le nom du paramètre.
    Ex1:
    // ES6
    const hello = name => `Hello ${name}`
    console.log(hello('Niang')) // Hello Niang

    Ex2:
    var simple = a => a > 15 ? 15 : a; 
    simple(16); // 15
    simple(10); // 10


4. Pour définir une fonction sans paramètre, on met juste des parenthèses vides.
    Ex1:
    // ES6
    const helloWorld = () => 'Hello World!'
    console.log(helloWorld()) // Hello World!

5. Pour retourner un objet, il y a une petite différence, parce que l'objet doit être dans des accolades, il faut donc mettre le return entre parenthèses cette fois-ci pour faire la différence.
    Ex1:
    const setContent = (title, content) => ({title: title, content: content})
    console.log(setContent('Hello', 'ES6')) // {title: "Hello", content: "ES6"}

6. Il ne peut pas y avoir de saut de ligne entre les paramètres et la flèche d'une fonction fléchée.
    Ex1:
    var func = ()
            => 1; // SyntaxError: expected expression,
                  //              got '=>'

7. La flèche utilisée pour une fonction fléchée n'est pas un opérateur. Les fonctions fléchées ont des règles spécifiques quant à leur place dans la syntaxe et interagissent différemment de la précédence des opérateurs par rapport à une fonction classique.
    Ex1:
    let fonctionRappel;
    fonctionRappel = fonctionRappel || function () {};
    // OK
    fonctionRappel = fonctionRappel || () => {};
    // SyntaxError: invalid arrow-function arguments
    fonctionRappel = fonctionRappel || (() => {});
    // OK

8. Les fonctions fléchées sont mieux indiquées pour les fonctions qui ne sont pas des méthodes (fonctions dans un objet).
    Ex1:
    'use strict';
    var objet = {
      i: 10,
      b: () => console.log(this.i, this),
      c: function() {
        console.log(this.i, this);
      }
    }
    objet.b(); 
    // affiche undefined, Window (ou l'objet global de l'environnement)
    objet.c();
    // affiche 10, Object {...}

9. Les fonctions fléchées ne créent pas de nouveau contexte, elles utilisent la valeur this de leur contexte. Aussi, si le mot-clé this est utilisé dans le corps de la fonction, le moteur recherchera la référence à cette valeur dans une portée parente.
    Ex1:
    // Avant ES6
    function Personne () {
      var that = this; 
      that.age = 0;
      setInterval(function grandir () {
        // La fonction callback se réfère à la variable `that`
        // qui est le contexte souhaité
        that.age++;
      }, 1000);
    }
    // ES6
    function Personne () {
      this.age = 0;
      setInterval(() => {
        this.age++; 
          // |this| fait bien référence à l'objet personne
      }, 1000);
    }
    var p = new Personne();

    Ex2:
    // Dans React
    class App extends Component {
        constructor( {
            super()

            this.state = {
                monster: [],
                searchfield: ''
            };


            // Sans utilisation d'une arrow function pour la méthode handlechange
            // On doit attacher le contexte de la classe au this de la méthode handlechange
            // this.handleChange = this.handleChange.bind(this);
        })        

        handleChange = e => {
            // Avec une arrow function le this est automatiquement attaché au contexte
            // où la méthode est déclarée, ici la class App
            this.setState({ searField: e.target.value });
        }

        [...]
    }



10. Exemples d'utilisation
    Ex1:
    (() => "tototruc")() 
    // exemple d'une fonction immédiatement 
    // invoquée (IIFE en anglais) qui renvoie 
    // "tototruc" 

    var complexe = (a, b) => {
      if (a > b) {
          return a;
      } else {
          return b;
      }
    }

    var arr = [5, 6, 13, 0, 1, 18, 23];
    var sum = arr.reduce((a, b) => a + b);
    // 66
    var even = arr.filter(v => v % 2 == 0);
    // [6, 0, 18]
    var double = arr.map(v => v * 2);       
    // [10, 12, 26, 0, 2, 36, 46]


IIFE (Expression de fonction invoquée immédiatement)
-------------------------------
1. IIFE (Immediately Invoked Function Expression) (Expression de fonction invoquée immédiatement) 
est une fonction JavaScript qui est exécutée dès qu'elle est définie.
C'est un modèle de conception qui est également connu sous le nom de Fonction anonyme auto-exécutable et contient deux parties principales. 
La première est la fonction anonyme avec portée lexicale incluse dans le groupement opérateur(). Cela empêche l'accès aux variables dans 
l'expression idiomatique IIFE ainsi que la pollution de la portée globale.
La deuxième partie crée la fonction immédiatement exécutable (), à travers laquelle le moteur JavaScript interprétera directement la fonction.
La fonction devient une expression de fonction qui est immédiatement exécutée. La variable dans l'expression ne peut pas être atteinte de l'extérieur.

    Ex1:
    (function () { 
        var aName = "Barry";
    })();
    // Le nom de la variable n'est pas accessible depuis le périmètre externe
    aName // lancement "Exception ReferenceError: aName n'est pas défini"

2. Affecter l'IIFE à une variable ne la stocke pas mais reçoit son résultat.

    Ex1:
    var result = (function () { 
        var name = "Barry"; 
        return name; 
    })(); 
    // Crée immédiatement la sortie: 
    result; // "Barry"

    var myFunction = function hello() {
        console.log(hello.name); //affiche hello
    }();
    console.log(myFunction); //affiche undefined




Objet Map
-------------------------------
1. L'objet Map représente un dictionnaire, autrement dit une carte de clés/valeurs. 
N'importe quelle valeur valable en JavaScript (que ce soit les objets ou les valeurs de types primitifs) 
peut être utilisée comme clé ou comme valeur. Un objet Map permet de retrouver ses éléments dans leur ordre d'insertion. 
Par exemple, une boucle for...of renverra un tableau de [clé, valeur] pour chaque itération.

//new Map([itérable])
    [itérable]
        Un tableau (Array) ou tout autre objet itérable dont les éléments sont des paires clé/valeur (par exemple un tableau de la forme [[1 , "toto"],[2, "truc"]]). Chaque paire clé/valeur sera ajoutée au nouvel objet Map. null est traité comme undefined.
    
    Ex1:
    // Utiliser un objet Map
    var maMap = new Map();
    var objetCle = {},
        fonctionCle = function () {},
        chaineCle = "une chaîne";
    // définir les valeurs
    maMap.set(chaineCle, "valeur associée à 'une chaîne'");
    maMap.set(objetCle, "valeur associée à objetCle");
    maMap.set(fonctionCle, "valeur associée à fonctionCle");
    maMap.size; // 3
    // récupérer les valeurs
    maMap.get(chaineCle);     // "valeur associée à 'une chaîne'"
    maMap.get(objetCle);      // "valeur associée à objetCle"
    maMap.get(fonctionCle);   // "valeur associée à fonctionCle"
    maMap.get("une chaîne");  // "valeur associée à 'une chaîne'"
                              // car chaineCle === 'une chaîne'

    Ex2:
    // Parcourir des objets Maps avec for..of
    var maMap = new Map();
    maMap.set(0, "zéro");
    maMap.set(1, "un");
    for (var [cle, valeur] of maMap) {
      console.log(cle + " = " + valeur);
    }
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"
    for (var cle of maMap.keys()) {
      console.log(cle);
    }
    // On aura 2 lignes : la première avec "0"
    // et la seconde avec "1"
    for (var valeur of maMap.values()) {
      console.log(valeur);
    }
    // On aura 2 lignes : la première avec "zéro"
    // et la seconde avec "un"
    for (var [cle, valeur] of maMap.entries()) {
      console.log(cle + " = " + valeur);
    }
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"
    maMap.forEach(function(valeur, cle) {
      console.log(cle + " = " + valeur);
    });
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"

    Ex3:
    // Relation avec les objets Array
    var tableauCleValeur = [["cle1", "valeur1"], ["cle2", "valeur2"]];
    // On utilise le constructeur Map
    // pour transformer un tableau de cles/valeurs
    // en un objet map
    var maMap = new Map(tableauCleValeur);
    maMap.get("cle1"); // renvoie "valeur1"
    // On utilise la fonction Array.from pour transformer
    // une map en un tableau de cles/valeurs
    console.log(Array.from(maMap)); // affichera la même chose que tableauCleValeur
    // On peut aussi l'utiliser pour n'extraire que les cles
    // ou les valeurs et créer le tableau associé
    console.log(Array.from(maMap.keys())); // affichera ["cle1", "cle2"]

    Ex4:
    // Fusionner des objets Map
    var premier = new Map([
      [1, 'un'],
      [2, 'deux'],
      [3, 'trois'],
    ]);
    var second = new Map([
      [1, 'uno'],
      [2, 'dos']
    ]);
    // On fusionne les deux maps. C'est la "dernière" version
    // de la clé qui l'emporte.
    // L'opérateur de décomposition nous permet principalement ici
    // de convertir une map en un tableau
    var fusion = new Map([...premier, ...second]);
    console.log(fusion.get(1)); // uno
    console.log(fusion.get(2)); // dos
    console.log(fusion.get(3)); // trois

    // Fusionner des objets Map avec des objets Array
    var premier = new Map([
      [1, 'un'],
      [2, 'deux'],
      [3, 'trois'],
    ]);
    var second = new Map([
      [1, 'uno'],
      [2, 'dos']
    ]);
    // On peut fusionner des Maps avec un tableau 
    // Là encore c'est le dernier exemplaire de la clé qui l'emporte
    var fusion = new Map([...premier, ...second, [1, 'eins']]);
    console.log(fusion.get(1)); // eins
    console.log(fusion.get(2)); // dos
    console.log(fusion.get(3)); // trois


Object Property Value Shorthand
-------------------------------
1. If you want to define or set an object who's keys have the same name as the variables passed-in as properties, you can use the shorthand and simply pass the key name.
    Ex1:
    // Avant ES6
    var cat = 'Miaow';
    var dog = 'Woof';
    var bird = 'Peet peet';
    var someObject = {
      cat: cat,
      dog: dog,
      bird: bird
    }
    // ES6
    let cat = 'Miaow';
    let dog = 'Woof';
    let bird = 'Peet peet';
    let someObject = {
      cat,
      dog,
      bird
    }
    console.log(someObject);
    //{
    //  cat: "Miaow",
    //  dog: "Woof",
    //  bird: "Peet peet"
    //}

    Ex2:
    state = {
      text: sampleText
    };

    editText = (event) => {
      const text = event.target.value;
      this.setState({ text }); // au lieu de this.setState({ text: text});
    };


Boucles
-------------------------------
FOR...OF (ES6)
for (variable of iterable)
  instruction

    [variable]
      À chaque itération, la valeur d'une propriété différente est affectée à variable (cette variable peut être déclarée avec const, let ou var).
    [iterable]
      L'objet dont on parcourt les propriétés énumérables.
    [instruction]
      Une instruction à exécuter pour chaque propriété, cette instruction peut être composée de plusieurs instructions en utilisant un bloc d'instructions.

1. L'instruction for...of permet de créer une boucle Array qui parcourt un objet itérable 
(ce qui inclut les objets Array, Map, Set, String, TypedArray, l'objet arguments, etc.) et 
qui permet d'exécuter une ou plusieurs instructions pour la valeur de chaque propriété.

    Ex1:
    // Sur un tableau
    let tableauIterable = [1, 2, 3];
    for (let valeur of tableauIterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3

    Ex2:
    // Parcourir une chaîne de caractères
    let iterable = 'pixel';
    for (let valeur of iterable) {
      console.log(valeur);
    }
    // p
    // i
    // x
    // e
    // l

    Ex3:
    // Parcourir une Map
    let iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);
    for (let element of iterable) {
      console.log(element);
    }
    // ['a', 1]
    // ['b', 2]
    // ['c', 3]
    for (let [clef, valeur] of iterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3


FOR...IN
for (variable in objet) {...
}

    [variable]
      Un nom de propriété différent est assigné à la variable à chaque itération de la boucle.
    [objet]
      L'objet dont les propriétés énumérables et qui ne sont pas des symboles sont parcourues par la boucle.

1. L'instruction for...in permet d'itérer sur les propriétés énumérables d'un objet qui ne sont pas des symboles. 
Pour chaque propriété obtenue, on exécute une instruction (ou plusieurs grâce à un bloc d'instructions).
for...in ne doit pas être utilisée pour parcourir un Array lorsque l'ordre des éléments est important.

    Ex1:
    // Sur un objet
    var obj = {a:1, b:2, c:3};    
    for (var prop in obj) {
      console.log(`obj.${prop} = ${obj[prop]}`);
    }
    // Affiche dans la console :
    // "obj.a = 1"
    // "obj.b = 2"
    // "obj.c = 3"

    Ex2:
    // Parcourir une chaîne de caractères
    let iterable = 'pixel';
    for (let valeur of iterable) {
      console.log(valeur);
    }
    // p
    // i
    // x
    // e
    // l


LES DIFFÉRENCES ENTRE FOR...OF ET FOR...IN
1. (Voir exemple ci-dessous) Chaque objet héritera de la propriété objCustom et chaque objet qui est un tableau (Array) héritera de la propriété arrCustom car 
on les ajoute aux prototypes Object.prototype et Array.prototype. L'objet iterable hérite donc des propriétés objCustom et 
arrCustom grâce à l'héritage et à la chaîne de prototypes.
Cette boucle ne parcourt que les propriétés énumérables de l'objet iterable dans un ordre arbitraire. 
Les éléments du tableau 3, 5, 7 ou "coucou" ne sont pas affichés car ce ne sont pas des propriétés 
(et encore moins des propriétés énumérables). En revanche, on retrouve bien les indices du tableau et 
les propriétés arrCustom et objCustom. Pour décrire plus précisément ce comportement, vous pouvez consulter for...in.

    Ex1:
    Object.prototype.objCustom = function() {}; 
    Array.prototype.arrCustom = function() {};
    let iterable = [3, 5, 7];
    iterable.toto = 'coucou';
    for (let i in iterable) {
      console.log(i); // affiche 0, 1, 2, "toto",
                      // "arrCustom", "objCustom"
    }
    for (let i in iterable) {
      if (iterable.hasOwnProperty(i)) {
        console.log(i); // affiche 0, 1, 2, "toto"
      }
    }
    // Cette boucle parcourt les valeurs définies comme itérables par l'objet itérable et 
    // dans ce cas ce sont les éléments du tableau 3, 5, 7 et pas les propriétés de l'objet (ici toto et sa valeur "coucou")
    for (let i of iterable) {
      console.log(i); // affiche 3, 5, 7
    }

Fonctions sur les tableaux
-------------------------------
FOREACH()
// arr.forEach(callback);
// arr.forEach(callback, thisArg);
1. Permet d'exécuter une fonction donnée sur chaque élément du tableau.
    
    [callback] est appelé avec trois arguments :
      - la valeur de l'élément
      - l'index de l'élément
      - le tableau utilisé

    Ex1:
    var array1 = ['a', 'b', 'c'];
    array1.forEach(function(element) {
      console.log(element);
    });

    Ex2:
    let arr = [3, 5, 7];
    arr.toto = "coucou";
    arr.forEach(function (element, index) {
      console.log(element); // affiche "3", "5", "7"
      console.log(index);  // affiche "0", "1", "2"
    });


CONSOLE.TABLE()
// console.table(data [, columns]);
    [data]
      La donnée à afficher. Doit être un tableau ou un objet.
    [columns]
      Un tableau contenant les noms des colonnes à inclure dans la sortie.

    Ex1:
    // data peut contenir un tableau ou un objet.
    // un tableau de chaînes de caractères
    console.table(["apples", "oranges", "bananas"]);

    Ex2:
    // un objet dont les propriétés sont des chaînes de caractères
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var me = new Person("John", "Smith");
    console.table(me);

    Ex3:
    // un tableau de tableaux
    var people = [["John", "Smith"], ["Jane", "Doe"], ["Emily", "Jones"]]
    console.table(people);

    Ex4:
    // un tableau d'objets
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var john = new Person("John", "Smith");
    var jane = new Person("Jane", "Doe");
    var emily = new Person("Emily", "Jones");
    console.table([john, jane, emily]);

    Ex5:
    // un objet contenant des propriétés qui sont des objets
    var family = {};
    family.mother = new Person("Jane", "Smith");
    family.father = new Person("John", "Smith");
    family.daughter = new Person("Emily", "Smith");
    console.table(family);

    Ex6:
    // un tableau d'objets, affichant seulement firstName
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var john = new Person("John", "Smith");
    var jane = new Person("Jane", "Doe");
    var emily = new Person("Emily", "Jones");
    console.table([john, jane, emily], ["firstName"]);


REDUCE()
// arr.reduce(callback) 
// arr.reduce(callback, valeurInitiale)
1. reduce() exécute la fonction callback une fois pour chaque élément présent dans le tableau et ignore les éléments vides du tableau. La fonction callback utilise quatre arguments. 
La première fois que la fonction callback est appelée, valeurInitiale et valeurCourante peuvent correspondre à un ou deux éléments. Si valeurInitiale est fournie dans l'appel de reduce(), 
alors accumulateur sera égale à valeurInitiale et valeurCourante sera égale à la première valeur de la liste. Si valeurInitiale n'est pas fournie, alors accumulateur sera égale à la première valeur de la liste, et valeurCourante sera alors égale à la seconde.
Autrement dit, si valeurInitiale n'est pas fournie, reduce exécutera la fonction de rappel à partir de l'indice 1 et la première valeur du tableau (d'indice 0) sera utilisée pour valeurInitiale.

    [callback]
      La fonction à exécuter sur chaque valeur de la liste (sauf le premier si aucune valeurInitiale n'est fournie), elle prend quatre arguments en entrée :
        [accumulateur]
          La valeur précédemment retournée par le dernier appel du callback, ou valeurInitiale, si elle est fournie (voir ci-après) (c'est la valeur « accumulée » au fur et à mesure des appels
        [valeurCourante]
          La valeur de l'élément courant actuellement manipulé dans le tableau.
        [index] (Facultatif)
          L'index de l'élément courant actuellement manipulé dans le tableau.
        [array] (Facultatif)
          Le tableau sur lequel on a appelé la méthode reduce().
    [valeurInitiale] (Facultatif)
      Une valeur utilisée comme premier argument lors du premier appel de la fonction callback. Si aucune valeur initiale n'est fournie, le premier élément du tableau est utilisé. Si on appelle reduce() sur un tableau vide sans fournir de valeur initiale, on aura une erreur.
    
    Ex1:
    // Sans fonction fléchée
    [0, 1, 2, 3, 4].reduce(function(accumulateur, valeurCourante, index, array){
      return accumulateur + valeurCourante;
    });
    // 10

    // Avec fonction fléchée
    [0, 1, 2, 3, 4].reduce((accumulateur, valeurCourante) => accumulateur + valeurCourante);
    // 10

    Ex2:
    // Avec valeurInitiale
    [0, 1, 2, 3, 4].reduce((accumulateur, valeurCourante) => accumulateur + valeurCourante, 10);
    // 20

MAP()
// let nouveauTableau = arr.map(callback [, thisArg])
1. La fonction callback fournie en argument est exécutée une fois pour chacun des éléments du tableau, dans l'ordre du tableau. 
Chaque résultat de l'opération sur un élément sera un élément du nouveau tableau. La fonction callback est appelée uniquement pour les indices du tableau 
pour lesquels il y a des valeurs affectées (y compris si cette valeur est undefined). Si les valeurs ont été supprimées ou qu'elles n'ont jamais été initialisées, la fonction ne sera pas appelée.
Si on utilise cette méthode sans utiliser le résultat, mieux vaudra utiliser forEach ou for...of. 

    [callback]
      La fonction qui est utilisée pour créer un élément du nouveau tableau. Elle utilise trois arguments
        [valeurCourante]
          La valeur de l'élément du tableau à traiter.
        [index]
          L'index de l'élément qui est traité par la fonction.
        [tableau] (Facultatif)
          Le tableau sur lequel on a appelé la méthode map.
    [thisArg] (Facultatif)
      La valeur à utiliser pour this lors de l'exécution de callback. La valeur par défaut est l'objet global de l'environnement (Window pour un navigateur).
    
    Ex1:
    // On crée un tableau composé des racines carrées des éléments d'un premier tableau
    var nombres = [1, 4, 9];
    var racines = nombres.map(Math.sqrt);
    // racines vaut désormais [1, 2, 3]
    // nombres vaut toujours [1, 4, 9]

    Ex2:
    // Créer un tableau de nombres avec une fonction à un argument. 
    // Cet argument sera automatiquement remplacé par chaque élément du tableau au fur et à mesure que map parcourt le tableau
    var nombres = [1, 4, 9];
    var doubles = nombres.map(function(num) {
      return num * 2;
    });
    // doubles vaut désormais [2, 8, 18].
    // nombres vaut toujours [1, 4, 9]

    Ex3:
    // On utilise un tableau d'objets pour créer un autre tableau contenant de nouveaux objets dans un autre format 
    var tableauOrig = [{cle:1, valeur:10}, {cle:2, valeur:20}, {cle:3, valeur: 30}];
    var tableauFormaté = tableauOrig.map(obj => { 
      var rObj = {};
      rObj[obj.cle] = obj.valeur; 
      return rObj;
    });
    // tableauFormaté vaut maintenant [{1:10}, {2:20}, {3:30}], 
    // tableauOrig vaut toujours 
    // [{cle:1, valeur:10},
    //  {cle:2, valeur:20},
    //  {cle:3, valeur: 30}
    // ]

    Ex4:
    // Utiliser map de façon générique sur autre chose qu'un tableau
    // Sur une chaine de caractère
    var map = Array.prototype.map;
    var a = map.call('Hello World', function(x) { return x.charCodeAt(0); });
    // a vaut désormais [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
    
    Ex5:
    // Utiliser map de façon générique sur autre chose qu'un tableau
    // Sur un tableau d'objets collectés grâce à querySelectorAll
    var elems = document.querySelectorAll('select option:checked');
    var values = Array.prototype.map.call(elems, function(obj) {
      return obj.value;
    });

    Ex6:
    // On peut passer à map() simplement le nom de la fonction sans paramètres
    myArray = [1,2,3]
    add3 = function(val) {
      return val+2;
    }
    myArray.map(add3) // [3,4,5]
    // Equivaut à 
    myArray.map(function(valCouranteDuTableau) {
      return valCouranteDuTableau+2;
    })

ENTRIES()
// arr.entries()
1. La méthode entries() renvoie un nouvel objet de type Array Iterator qui contient le couple clef/valeur pour chaque éléments du tableau.

    Ex1:
    var array1 = ['a', 'b', 'c'];
    var iterator1 = array1.entries();
    console.log(iterator1.next().value);
    // expected output: Array [0, "a"]
    console.log(iterator1.next().value);
    // expected output: Array [1, "b"]

FROM()
// Array.from(arrayLike [, fonctionMap[, thisArg]])
1. La méthode Array.from() permet de créer une nouvelle instance d'Array (une copie superficielle) 
à partir d'un objet itérable ou semblable à un tableau.

    [arrayLike]
        Un objet semblable à un tableau ou bien un objet itérable dont on souhaite créer un tableau, instance d'Array.
    [fonctionMap] (Facultatif)
        Argument optionnel, une fonction à appliquer à chacun des éléments du tableau.
    [thisArg] (Facultatif)
        Argument optionnel. La valeur à utiliser pour this lors de l'exécution de la fonction fonctionMap.

    Valeur de retour :
        Une nouvelle instance de Array.

    Ex1:
    // créer une instance d'Array à partir de l'objet arguments qui est semblable à un tableau
    function f() {
      return Array.from(arguments);
    }
    f(1, 2, 3); 
    // [1, 2, 3]

    Ex2:
    // Ça fonctionne avec tous les objets itérables...
    // Set
    const s = new Set(["toto", "truc", "truc", "bidule"]);
    Array.from(s);   
    // ["toto", "truc", "bidule"]
    // Map
    const m = new Map([[1, 2], [2, 4], [4, 8]]);
    Array.from(m);                          
    // [[1, 2], [2, 4], [4, 8]]  
    const mapper = new Map([["1", "a"], ["2", "b"]]);
    Array.from(mapper.values());
    // ["a", "b"] 
    Array.from(mapper.keys());
    // ["1", "2"]
    // String
    Array.from("toto");                      
    // ["t", "o", "t", "o"]

SLICE()
// arr.slice()
// arr.slice(début)
// arr.slice(début, fin)
1. La méthode slice() renvoie un objet tableau, contenant une copie superficielle (shallow copy) d'une portion du tableau d'origine, 
la portion est définie par un indice de début et un indice de fin (EXCLUS). Le tableau original ne sera pas modifié.

    [début] (Facultatif)
        Indice (à partir de zéro) depuis lequel commencer l'extraction.
        S'il s'agit d'un indice négatif, début indique un décalage depuis la fin de la séquence. Par exemple, slice(-2) 
        extrait les avant-dernier et dernier éléments dans la séquence.
        Si début est absent, slice() commencera depuis 0. 
        Si début est supérieur à la taille du tableau, c'est un tableau vide qui sera renvoyé.
    [fin] (Facultatif)
        Indice (à partir de zéro) auquel arrêter l'extraction. slice() extrait jusqu'à cet indice, 
        mais pas l'élément situé en fin lui-même. slice(1,4) extrait du deuxième au quatrième élément (les éléments d'indices 1, 2 et 3).
        S'il s'agit d'un indice négatif, fin indique un décalage depuis la fin de la séquence. slice(2,-1) extrait du troisième à l'avant-dernier élément dans la séquence.
        Si fin n'est pas fourni, slice() extraira jusqu'à la fin de la séquence (arr.length). 
        Si fin est supérieur à la longueur de la séquence, slice() fera une extraction jusqu'à la fin de la séquence.

    Valeur de retour :
        Un nouveau tableau contenant les éléments extraits.

2. slice() ne modifie pas le tableau original, mais renvoie une nouvelle copie du tableau (shallow copy — copie superficielle) dont les éléments sont des copies des éléments extraits du tableau original. 
Les éléments du tableau original sont copiés dans le nouveau tableau de la manière suivante :
Pour les références à des objets (et non les objets eux-mêmes), slice() copie ces références dans le nouveau tableau. 
Tant l'original que le nouveau tableau font référence au même objet. Si un objet référencé est modifié, ces changements sont visibles tant pour le nouveau que pour l'ancien tableau.
Pour les chaines de caractères, les nombres et les booléens, slice() copie ces chaines de caractères, ces nombres et ces valeurs booléennes dans le nouveau tableau. 
Les modifications sur ces chaînes, nombres ou booléens dans l'un des tableaux n'affectent pas l'autre tableau 
(NB : lorsque l'on parle de chaine de caractères, de nombre ou de booléen ici, on parle exclusivement de leur type primitif, 
pas des objets String, Number ou Boolean — voir par exemple différences entre objet String et type primitif pour les chaines de caractères).
Si un nouvel élément est ajouté à l'un ou l'autre tableau, le second n'est pas affecté.

    Ex1:
    var fruits = ["Banane", "Orange", "Citron", "Pomme", "Mangue"];
    var agrumes = fruits.slice(1, 3);
    // fruits vaut --> ["Banane", "Orange", "Citron", "Pomme", "Mangue"]
    // agrumes vaut --> ["Orange", "Citron"]

    Ex2:
    var animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];
    console.log(animals.slice(2));
    // expected output: Array ["camel", "duck", "elephant"]
    console.log(animals.slice(2, 4));
    // expected output: Array ["camel", "duck"]
    console.log(animals.slice(1, 5));
    // expected output: Array ["bison", "camel", "duck", "elephant"]

    Ex3:
    var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
    var myBest = fruits.slice(-2); // Equivaut à fruits.slice(fruits.length-2) équivaut à fruits.slice(3)
    // Apple,Mango
    var myBest = fruits.slice(-4, -2); // Equivaut à fruits.slice(fruits.length-4, fruits.length-2) équivaut à fruits.slice(1, 3)
    // Orange,Lemon
    var myBest = fruits.slice(-4, 2);  // Equivaut à fruits.slice(fruits.length-4, 2) équivaut à fruits.slice(1, 2)
    // Orange

FILTER()
// var nouveauTableau = arr.filter(callback, thisArg);
// callback(elementCourant[, index[, tableauEntier]])
1. filter() appelle la fonction callback fournie pour chacun des éléments d'un tableau, et 
construit un nouveau tableau contenant tous les éléments pour lesquels l'appel de callback 
retourne true ou une valeur équivalente à true dans un contexte booléen. La fonction callback 
n'est utilisée que pour les éléments du tableau ayant une valeur assignée — les index supprimés 
ou pour lesquels il n'y a jamais eu de valeur ne sont pas pris en compte. Les éléments du tableau 
qui ne passent pas le test effectué par la fonction callback sont ignorés, ils ne sont pas 
inclus dans le nouveau tableau.
La liste des éléments parcourus par filter() est définie avant la première invocation de la fonction callback. 
Les éléments qui sont ajoutés à la liste après le début de l'appel de filter() (grâce à la fonction callback par exemple) 
ne seront pas concernés par le filtre. Si des éléments de la liste sont modifiés ou supprimés au cours du traitement, 
la valeur fournie à la fonction callback sera la valeur de ces éléments au moment où filter() les traite — 
les éléments supprimés ne seront pas traités par la fonction.

    [callback] 
        La fonction de test (ou prédicat) à appliquer à chaque élément du tableau. Cette fonction est appelée avec les arguments suivants :

        [elementCourant]
            L'élément à traiter

        [index] (Facultatif)
            Son indice
            
        [tableauEntier] (Facultatif)            
            Le tableau complet

        Valeur de retour :
            Cette fonction renvoie true — ou une valeur équivalente — si l'élément doit être conservé pour le tableau résultat et false dans le cas contraire.        

    [thisArg] (Facultatif)
        Objet à utiliser en tant que this quand la fonction callback est exécutée.

    Valeur de retour :
        Un nouveau tableau contenant les éléments qui respectent la condition du filtre. Si aucun élément ne respecte la condition, c'est un tableau vide qui est renvoyé.

    Ex1:
    // Filtrer les petites valeurs
    function suffisammentGrand(element) {
      return element >= 10;
    }
    var filtre = [12, 5, 8, 130, 44].filter(suffisammentGrand);
    // filtre vaut [12, 130, 44]

    Ex2:
    Filtrer des éléments JSON invalides en fonction d'un id
    var arr = [
      { id: 15 },
      { id: -1 },
      { id: 0 },
      { id: 3 },
      { id: 12.2 },
      { },
      { id: null },
      { id: NaN },
      { id: 'undefined' }
    ];
    var elementsInvalides = 0;

    function filtrerParID(obj) {
      // Si c'est un nombre
      if (obj.id !== undefined && typeof(obj.id) === 'number' && !isNaN(obj.id)) {
        return true;
      } else {
        elementsInvalides++;
        return false;
      }
    }
    var arrByID = arr.filter(filtrerParID);

    console.log('Tableau filtré\n', arrByID);
    // Le tableau filtré est :
    // [{ id: 15 }, { id: -1 }, { id: 0 }, { id: 3 }, { id: 12.2 }]
    console.log('Nombre d\'éléments invalides = ', elementsInvalides);
    // Nombre d'éléments invalides 4

INCLUDES()
// arr.includes(élémentRecherché)
// arr.includes(élémentRecherché, indiceDépart)
1. Permet de déterminer si un tableau contient une valeur et renvoie true si c'est le cas, false sinon.
includes() est une méhtode générique : l'objet sur lequel elle est appelée ne doit pas nécessairement être un tableau. 
On peut l'utiliser sur des objets semblables à des tableaux (ex. arguments ou des chaînes de caractères)

    [élémentRecherché] 
        La valeur qu'on souhaite trouver dans le tableau (lorsqu'on manipule des caractères et des chaînes, 
        la comparaison est sensible à la casse).

    [indiceDépart]  (Facultatif)
        La position du tableau à partir de laquelle commencer à chercher élémentRecherché. 
        Si on utilise une valeur négative, la recherche commencera à partir de la fin du tableau (autrement dit à l'indice array.length - indiceDépart). 
        La valeur par défaut est 0.
        SI indiceDépart est supérieur ou égal à la longueur du tableau, la méthode retourne false. Le tableau n'est pas parcouru.
        Si indiceDépart est strictement négatif, l'indice de départ effectif est la somme entre la taille du tableau et indiceDépart. 
        Si cette somme est toujours négative, le tableau est intégralement parcouru.

    Valeur de retour :
        Un booléen qui vaut true si élémentRecherché est trouvé dans le tableau (à partir de l'indiceDépart si celui-ci est indiqué). 
        Les valeurs -0, +0 et 0 sont considérées comme équivalentes mais false n'est pas considéré comme équivalent à 0.

    Ex1:
    [1, 2, 3].includes(2);     // true
    [1, 2, 3].includes(4);     // false
    [1, 2, 3].includes(3, 3);  // false
    [1, 2, 3].includes(3, -1); // true
    [1, 2, NaN].includes(NaN); // true
    ['a', 'b', 'c'].includes('c', 5);    // false
    ['a', 'b', 'c'].includes('c', -100); // true

    var array1 = [1, 2, 3];
    console.log(array1.includes(2));
    // expected output: true

    var pets = ['cat', 'dog', 'bat'];
    console.log(pets.includes('cat'));
    // expected output: true
    console.log(pets.includes('at'));
    // expected output: false

    // indiceDépart supérieur ou égal à la longueur du tableau
    var arr = ['a', 'b', 'c'];
    arr.includes('c', 3);   // false
    arr.includes('c', 100); // false

    // indiceDépart strictement négatif
    // Le tableau a une taille de 3
    // indiceDépart vaut -2
    // L'indice de départ effectif vaut is 3 + (-2) = 1
    var arr = ['a', 'b', 'c'];
    arr.includes('a', -2); // false
    arr.includes('b', -2); // true
    arr.includes('c', -100); // true


Méthodes sur les objets
-------------------------------
KEYS()
// Object.keys(obj)
1. La méthode Object.keys() renvoie un tableau contenant les noms des propriétés propres à un objet 
(qui ne sont pas héritées via la chaîne de prototypes) et qui sont énumérables. L'ordre de ce tableau est le même que celui obtenu par une boucle for...in 
(à la différence qu'une boucle for-in liste également les propriétés héritées).
Si on souhaite lister toutes les propriétés, y compris celles qui ne sont pas énumérables, on pourra utiliser Object.getOwnPropertyNames().

    [obj]
        L'objet dont on souhaite lister les propriétés propres et énumérables.
   
    Valeur de retour :
        Un tableau de chaînes de caractères qui sont les noms des propriétés énumérables de l'objet passé en argument.

    Ex1:
    const object1 = {
      a: 'somestring',
      b: 42,
      c: false
    };
    console.log(Object.keys(object1));
    // expected output: Array ["a", "b", "c"]

    Ex2:
    var arr = ["a", "b", "c"];
    console.log(Object.keys(arr));
    // affichera ['0', '1', '2']

    Ex3:
    // un objet semblable à un tableau
    var obj = { 0 : "a", 1 : "b", 2 : "c"};
    console.log(Object.keys(obj));
    // affichera ['0', '1', '2']

    Ex4:
    // un objet semblable à un tableau avec
    // un ordre de clé aléatoire
    var an_obj = { 100: "a", 2: "b", 7: "c"};
    console.log(Object.keys(an_obj));
    // affichera ['2', '7', '100'] Les clés se classent dans l'ordre croissant de la valeur des indices

ASSIGN()
// Object.assign(cible, ...sources)

    [cible]
        L'objet cible. Ce peut être un objet vide {}

    [sources]
        Le(s) objet(s) source(s).
   
    Valeur de retour :
        L'objet cible, éventuellement modifié, est renvoyé.

1. La méthode Object.assign permet de ne copier que les propriétés énumérables et propres 
(les propriétés qui ne sont pas héritées) depuis un objet source vers un objet cible. 
Elle utilise [[Get]] sur l'objet source et [[Set]] sur l'objet cible, ainsi, elle déclenchera 
les accesseurs/mutateurs. De cette façon, elle affecte les propriétés plutôt que de juste 
les copier ou d'en définir de nouvelles. Aussi, il est déconseillé d'utiliser cette méthode 
si on souhaite uniquement fusionner de nouvelles propriétés dans un prototype si un des 
objets sources contient des accesseurs. Pour uniquement copier les définitions des 
propriétés (y compris leur énumérabilité) dans des prototypes, on utilisera plutôt 
Object.getOwnPropertyDescriptor() et Object.defineProperty().

Les propriétés String et Symbol sont copiées. Les propriétés de l'objet cible sont 
surchargées par celles de l'objet source si elles ont la même clé.

En cas d'erreur, si une propriété n'est pas accessible en écriture par exemple, une 
exception TypeError sera levée mais l'objet cible aura été modifié avec les propriétés ajoutées avant l'erreur.

Object.assign ne donnera pas d'erreur si on fournit les valeurs null ou undefined pour la valeur source.

2. Cloner un objet
Attention, pour un clone réel (deep clone), il faudra utiliser d'autres méthodes car Object.assign() 
ne copie que les valeurs des propriétés depuis l'objet source, il ne recopie pas intégralement une nouvelle propriété. 
Si la valeur est une référence à un objet, il copiera uniquement la référence.
    
    Ex1:
    var obj = { a: 1 };
    var copie = Object.assign({}, obj);
    console.log(copie); // {a: 1}

3. Fusionner des objets

    Ex1:
    var o1 = { a: 1 };
    var o2 = { b: 2 };
    var o3 = { c: 3 };

    var obj = Object.assign(o1, o2, o3);
    console.log(obj); // { a: 1, b: 2, c: 3 }
    console.log(o1);  // { a: 1, b: 2, c: 3 }, l'objet cible est aussi modifié

4. Fusionner des objets partageant des propriétés

    Ex1:
    var o1 = { a: 1, b: 1, c: 1 };
    var o2 = { b: 2, c: 2 };
    var o3 = { c: 3 };

    var obj = Object.assign({}, o1, o2, o3);
    console.log(obj); // { a: 1, b: 2, c: 3 }
    // Les propriétés communes sont surchargées selon l'ordre des paramètres.



Méthodes sur les fonctions
-------------------------------
CALL()
//fun.call(thisArg, arg1, arg2, ...)
1. La méthode call() réalise un appel à une fonction avec une valeur this donnée et des arguments fournis individuellement.
Ce qui peut se traduire par : J'appelle ma fonction avec call et je remplace le this qui se trouve 
dans la fonction par l'objet que je passe en premier argument et j'utilise les arguments attendus 
passé par call dans les arguments passés en second et après.

    [thisArg]
        La valeur this fournie pour l'appel de la fonction fun.

    [arg1, arg2, ...]
        Les arguments pour la fonction.
       
    Valeur de retour :
        Le résultat de l'appel de la fonction invoquée avec la valeur this indiquée et les arguments fournis.

2. La méthode call() permet d'appeler une fonction rattachée à un objet donné sur un autre objet. Il est possible d'utiliser call pour chaîner le constructeur d'un objet.

    Ex1:
    /* 
    Dans l'exemple suivant, le constructeur de l'objet Product est défini avec deux paramètres, name et price. 
    Deux autres fonctions, Food et Toy invoquent Product en passant this, name et price. 
    Product initialise les propriétés name et price, tandis que les fonctions spécialisées définissent la propriété category.
    */

    function Product(name, price) {
      this.name = name;
      this.price = price;
    }

    function Food(name, price) {
      Product.call(this, name, price);
      this.category = 'food';
    }

    function Toy(name, price) {
      Product.call(this, name, price);
      this.category = 'toy';
    }

    var cheese = new Food('feta', 5);
    var fun = new Toy('robot', 40);


    Ex2:
    function Product(name, price) {
      this.name = name;
      this.price = price;
    }

    function Food(name, price) {
      Product.call(this, name, price);
      this.category = 'food';
    }

    console.log(new Food('cheese', 5).name);
    // expected output: "cheese"

3. Utiliser call() pour invoquer une fonction anonyme

    Ex1:
    /*
    Dans cet exemple (purement inventé), on crée une fonction anonyme et on utilise call pour 
    l'invoquer sur chaque objet d'un tableau. Le principal but de cette fonction anonyme est 
    d'ajouter une fonction print sur chaque élément qui permet d'afficher l'index de l'objet
    */

    var animaux = [
      {espece: 'Lion', nom: 'Roi'},
      {espece: 'Éléphant', nom: 'Dumbo'}
    ];

    for (var i = 0; i < animaux.length; i++) {
      (function (i) { 
        this.print = function () { 
          console.log('#' + i  + ' ' + this.espece + ' : ' + this.nom); 
        } 
        this.print();
      }).call(animaux[i], i);
      // Ce qui peut se traduire par : J'appelle ma fonction anonyme avec call et je remplace le this 
      // qui se trouve dans la fonction par l'objet que je passe en premier argument et j'utilise les arguments attendus
      // passé par call dans les arguments passés en second et après.
    }

4. Utiliser call() pour appeler une fonction avec un objet pour this

    Ex1:
    /*
    Dans l'exemple qui suit, on utilise la méthode call() 
    sur la fonction saluer() afin de l'appliquer à l'objet personne1
    */

    function saluer() {
      var reponse = [this.nom, "est un", this.role, "."].join(" ");
      console.log(reponse);
    }

    var personne1 = {
      nom: "Sénèque",
      role: "philosophe"
    };

    saluer.call(personne1); // Sénèque est un philosophe.

5. Utiliser call() pour appeler une fonction sans indiquer de premier argument

    Ex1:
    /*
    Dans l'exemple qui suit, on appelle la fonction afficher() sans lui passer d'argument. 
    C'est donc l'objet global qui est utilisé comme contexte
    */
    var prenom = 'Archibald';

    function afficher() {
      console.log('prenom vaut ' + this.prenom);
    }
    afficher.call(); // prenom est Archibald

    /*
    La valeur de this sera undefined en mode strict.
    */
    'use strict';

    var prenom = 'Archibald';

    function afficher() {
      console.log('prenom vaut ' + this.prenom);
    }
    afficher.call(); // Cannot read the property prenom' of undefined


APPLY()
//fun.apply(thisArg, argsArray)
1. La méthode apply() appelle une fonction en lui passant une valeur this et des arguments sous forme d'un tableau (ou d'un objet semblable à un tableau).
apply() est similaire à call(), hormis pour le type d'arguments supporté. Il est possible d'utiliser un tableau à la place d'un ensemble de paramètres. 
Avec apply(), il est également possible d'utiliser un littéral de tableau, par exemple, fun.apply(this, ['manger', 'bananes']), 
ou un objet Array, par exemple, fun.apply(this, new Array('manger', 'bananes')).

On peut aussi passer arguments en tant que paramètre argsArray. arguments étant une variable locale à la fonction. 
Celle-ci peut également être utilisée pour tous les arguments non spécifiés de l'objet appelé. 
Ainsi, il n'est pas nécessaire de connaître les arguments de l'objet appelé lors d'un appel à la méthode apply. 
arguments peut être utilisé pour passer tous les arguments à l'objet appelé. L'objet appelé gèrera alors la manipulation des arguments.

Depuis la cinquième édition d'ECMAScript, il est possible d'utiliser des objet semblables à des tableaux à la place. 
En pratique tout objet possédant une propriété length et une propriété entière comprise entre [0..length[ est un objet semblable à un tableau. 
On peut ainsi, par exemple, utiliser un objet NodeList ou un objet quelconque comme {'length': 2, '0': 'manger', '1': 'bananes'}.

    [thisArg]
        La valeur this fournie pour l'appel de la fonction fun.

    [argsArray]
        Un objet semblable à un tableau qui définit les arguments avec lesquel fun devrait être appelée, 
        ou null ou undefined si aucun argument n'est passé à la fonction. Avec ECMAScript 5, 
        ces arguments peuvent être représentés par un objet semblable un tableau. 
       
    Valeur de retour :
        Le résultat de l'appel de la fonction invoquée avec la valeur this indiquée et les arguments fournis.

2. Utiliser apply et des fonctions natives.
Quand on utilise undefined ou null comme premier argument pour cette fonction, on peut obtenir un résultat similaire à la syntaxe de décomposition.

    Ex1:
    function sum(x, y, z) {
      return x + y + z;
    }

    const numbers = [1, 2, 3];

    console.log(sum.apply(null, numbers));
    // expected output: 6

    console.log(sum(...numbers));
    // expected output: 6


    Ex2:
    var numbers = [5, 6, 2, 3, 7];

    var max = Math.max.apply(null, numbers);

    console.log(max);
    // expected output: 7

    var min = Math.min.apply(null, numbers);

    console.log(min);
    // expected output: 2


BIND()
//fun.bind(thisArg, arg1, arg2, ...)
1. La fonction bind() crée une nouvelle fonction qui, lorsqu'elle est appelée, 
a pour contexte this la valeur passée en paramètre et éventuellement une suite d'arguments 
qui précéderont ceux fournis à l'appel de la fonction créée.
Ce qui peut se traduire par : Je crée une nouvelle fonction avec bind et je remplace le this qui se trouve 
dans la fonction par l'objet que je passe en premier argument et je précède les arguments attendus par ma fonction
par les arguments passés en second et après dans bind. 

    [thisArg]
        La valeur que l'on doit passer au paramètre this de la fonction cible quand la fonction est appelée. 
        La valeur est ignorée si la fonction liée est construite en utilisant l'opérateur new.

    [arg1, arg2, ...]
        Les arguments qui doivent précéder les arguments fournis lors de l'appel à la fonction liée lors 
        de l'appel à la fonction cible.
       
    Valeur de retour :
        Une copie de la fonction fournie avec la valeur this indiquée et les arguments initiaux fournis.

2. Créer une fonction liée

    Ex1:
    this.x = 9; // en dehors de tout contexte,
                // pour un navigateur, this est
                // l'objet window
    var module = {
      x: 81,
      getX: function() { return this.x; }
    };

    module.getX(); // 81

    var getX = module.getX;
    getX(); // 9, car ici, this fait référence à l'objet global

    // On crée une nouvelle fonction à laquelle on lie module en
    // tant que 'this'
    var boundGetX = getX.bind(module);
    boundGetX(); // 81


    Ex2:
    var module = {
      x: 42,
      getX: function() {
        return this.x;
      }
    }

    var unboundGetX = module.getX;
    console.log(unboundGetX()); // The function gets invoked at the global scope
    // expected output: undefined

    var boundGetX = unboundGetX.bind(module);
    console.log(boundGetX());
    // expected output: 42

3. Utiliser bind() afin de créer une fonction avec des arguments initiaux prédéfinis.

    Ex1:
    /*
    Dans l'exemple suivant, on utilise bind() afin de créer une fonction avec des arguments initiaux prédéfinis.
    Ces arguments, s'il y en a, suivent le this fourni et sont ensuite insérés au début des arguments passés 
    à la fonction cible, suivis par les arguments passés à la fonction liée au moment où celle-ci est appelée.
    */

    function list() {
      // Retourne un tableau à partir du tableau arguments des paramètres que l'on passe à la fonction list
      return Array.prototype.slice.call(arguments); 
    }

    var list1 = list(1, 2, 3); // [1, 2, 3]

    // Créer une fonction avec un argument prédéfini (ici 37)
    var leadingThirtysevenList = list.bind(null, 37); 

    var list2 = leadingThirtysevenList(); // [37]
    var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]


    function sommeArguments(arg1, arg2){
      return arg1 + arg2;
    }

    var ajouter37 = sommeArguments.bind(null, 37);

    var resultat = ajouter37(5); // 37 + 5 = 42


Méthodes sur les chaînes de caratères
-------------------------------
INCLUDES()
// str.includes(chaîneRecherchée);
// str.includes(chaîneRecherchée, position);
1. La méthode includes() détermine si une chaîne de caractères est contenue dans une 
autre et renvoie true ou false selon le cas de figure. includes() est sensible à la casse.

    [chaîneRecherchée]
        Une chaîne à rechercher dans la chaîne courante.

    [position] (Facultatif)
        La position dans la chaîne à partir de laquelle commencera la recherche. La valeur par défaut de position est 0.
       
    Valeur de retour :
        true si la chaîne de caractères contient la sous-chaîne recherchée, false sinon.

    Ex1:
    // includes() est sensible à la casse
    'Baleine bleue'.includes('baleine'); // false

    Ex2:
    const str = "Être ou ne pas être, telle est la question.";
    console.log(str.includes("Être"));       // true
    console.log(str.includes("question"));   // true
    console.log(str.includes("pléonasme"));  // false
    console.log(str.includes("Être", 1));    // false
    console.log(str.includes("ÊTRE"));       // false
    console.log(str.includes(""));           // true


Rest parameters
-------------------------------
1. Cette syntaxe permet de représenter un nombre indéfini d'arguments sous forme d'un tableau.
    Ex1:
    // ES6
    function sum(...theArgs) {
      return theArgs.reduce((previous, current) => {
        return previous + current;
      });
    }
    console.log(sum(1, 2, 3));
    // expected output: 6
    console.log(sum(1, 2, 3, 4));
    // expected output: 10

    Ex2:
    // S'il n'y a qu'un seul argument qui est décomposé par la syntaxe, la valeur sera toujours un tableau
    function maFonction(a, b, ...autres);
      console.log(a);
      console.log(b);
      console.log(autres);
    }
    maFonction("un", "deux", "trois");
    // affichera ceci dans la console
    // "un"
    // "deux"
    // ["trois"]
    maFonction("un", "deux", "trois", "quatre", "cinq");
    // affichera ceci dans la console :
    // "un"
    // "deux"
    // ["trois", "quatre", "cinq"]

    Ex3:
    // S'il n'y a pas suffisamment d'arguments, ce sera un tableau vide
    function maFonction(a, b, ...autres);
      console.log(a);
      console.log(b);
      console.log(autres);
    }
    maFonction("un", "deux");
    // affichera ceci dans la console
    // "un"
    // "deux"
    // []

    Ex4:
    // lesArguments est un tableau et dispose donc d'une propriété length permettant de compter ses éléments
    function fun1(...lesArguments) {
      console.log(lesArguments.length);
    }
    fun1();  // 0
    fun1(5); // 1
    fun1(5, 6, 7); // 3

  
Spread operator (opérateur de décomposition)
-------------------------------
1. Il permet de développer un objet itérable (comme un Array) en plusieurs arguments (pour les appels de fonctions) 
ou en plusieurs éléments (pour les littéraux de tableaux) ou en paires clés-valeurs (pour les littéraux d'objets)

    Ex1:
    // Dans les appels de fonction
    f(...objetIterable);
    // Pour les littéraux de tableaux
    [...objetIterable, 4, 5, 6]
    // Pour les littéraux objets
    let objClone = { ...obj };

    Ex2:
    // Utiliser la décomposition dans les appels de fonction
    const myArray = [1991, 8, 1]
    new Date(...myArray) // object Date - équivaut à: new Date(1991, 8, 1)
    // spread peut être mélangé aux autres arguments d'une fonction
    const myArray = [8, 1];
    new Date(1991, ...myArray, 12); 
    // object Date - équivaut à: new Date(1991, 8, 1, 12)
    
    Ex3:
    // Les objets String étant itérables
    const myString = "foo bar"    
    [...myString] // ["f", "o", "o", " ", "b", "a", "r"]

    Ex4:
    // Éviter l'utilisation de .apply()
    // ES5
    console.log.apply(console, ["foo", "bar"]);
    // ES6
    console.log(...["foo", "bar"]); // même résultat

    Ex5:
    // Concaténer plusieurs itérables
    const stronglyTyped = ["scala", "haskell"]
    // ES5
    ["go", "rust"].concat(stronglyTyped) 
    // ["go", "rust", "scala", "haskell"]
    // ES6 / ES2015
    ["go", "rust", ...stronglyTyped] 
    // ["go", "rust", "scala", "haskell"]
    var articulations = ['épaules', 'genoux'];
    var corps = ['têtes', ...articulations, 'bras', 'pieds'];
    // ["têtes", "épaules", "genoux", "bras", "pieds"]
    var arr1 = [4, 5, 6];
    var arr2 = [1, 2, 3];
    arr1 = [...arr2, ...arr1];
    // arr1 vaut désormais [1, 2, 3, 4, 5, 6]

    Ex6:
    // Copier un tableau (seulement au premier niveau de profondeur)
    var arr = [1, 2, 3];
    var arr2 = [...arr];
    arr2.push(4);
    console.log(arr2); // [1, 2, 3, 4]
    console.log(arr);  // [1, 2, 3] (inchangé)

    Ex7:
    // Clonage superficiel d'objet   
    const cat = { age: 4 };
    const kitten = { ...cat }; // Nouvel objet créé
    kitten.age = 1;
    console.log(kitten.age); // 1
    console.log(cat.age); // 4
    // Superficiel car les valeurs des propriétés de l'objet cloné pointent vers les mêmes références que l'objet copié et ne sont pas de nouvelles instances) 
    const cat = { age: 4, toys: ["mouse", "catnip"] };
    const kitten = { ...cat };
    kitten.toys[1] = "yarn";
    console.log(kitten.toys); // ["mouse", "yarn"]
    console.log(cat.toys); // ["mouse", "yarn"] <-- problem!

2. Il permet de mettre une ou plusieurs valeurs de propriété d'un objet. 
Les propriétés sont ajoutées dans l'ordre. Par conséquent, si vous souhaitez remplacer des propriétés existantes, 
vous devez les placer à la fin et non au début

  Ex1:
  const obj1 = {
    a: "original a",
    b: "original b"
  }
  // Doesn't work
  const obj2 = {
    a: "updated a",
    ...obj1
  }
  console.log(obj2); // Affiche Object {a: "original a", b: "original b"}
  // Works
  const obj3 = {
    ...obj1, 
    a: "updated a"
  }
  console.log(obj3); // Affiche Object {a: "updated a", b: "original b"}


Le protocole « itérable » (Objets itérables)
-------------------------------
1. Le protocole « itérable » permet aux objets JavaScript de définir ou de personnaliser leur comportement lors d'une itération, 
par exemple la façon dont les valeurs seront parcourues avec une boucle for..of. 
Certains types natifs tels que Array ou Map possèdent un comportement itératif par défaut, d'autres types, 
comme Object n'ont pas ce type de comportement.

    Ex1:
    // Certains types natifs possèdent un comportement par défaut pour l'itération, d'autres types (tels qu'Object) n'ont pas de tel comportement. Les types natifs qui disposent d'une méthode @@iterator sont :
    Array.prototype[@@iterator]()
    TypedArray.prototype[@@iterator]()
    String.prototype[@@iterator]()
    Map.prototype[@@iterator]()
    Set.prototype[@@iterator]()

    Ex2:
    // Les API natives utilisant des itérables
    Map([itérable])
    WeakMap([itérable])
    Set([itérable])
    WeakSet([itérable])
    Promise.all(itérable)
    Promise.race(itérable)
    Array.from()

    var monObjet = {};
    new Map([[1,"a"],[2,"b"],[3,"c"]]).get(2); // "b"
    new WeakMap([[{},"a"],[monObjet,"b"],[{},"c"]]).get(monObjet); // "b"
    new Set([1, 2, 3]).has(3); // true
    new Set("123").has("2"); // true
    new WeakSet(function*() {
        yield {};
        yield monObjet;
        yield {};
    }()).has(monObjet);  // true

    Ex3:
    // Les éléments de syntaxe utilisant des itérables
    for..of
    la syntaxe de décomposition (opérateur spread)
    yield*
    l'affectation par décomposition

    for(let value of ["a", "b", "c"]){
      console.log(value);
    }
    // "a"
    // "b"
    // "c"
    [..."abc"]; // ["a", "b", "c"]
    function* gen(){
      yield* ["a", "b", "c"];
    }
    gen().next(); // { value:"a", done:false }
    [a, b, c] = new Set(["a", "b", "c"]);
    a; // "a"

2. Afin d'être itérable, un objet doit implémenter la méthode @@iterator, cela signifie que l'objet (ou un des objets de sa chaîne de prototypes) 
doit avoir une propriété avec une clé @@iterator qui est accessible via Symbol.iterator. 
Lorsqu'on doit itérer sur un objet (ex. : au début d'une boucle for..of), sa méthode @@iterator est appelée sans argument et l'itérateur 
qui est renvoyé est utilisé afin d'obtenir les valeurs sur lesquelles itérer.

    Ex1:
    // Itérables définis par l'utilisateur
    const iterable1 = new Object();
    iterable1[Symbol.iterator] = function* () {
      yield 1;
      yield 2;
      yield 3;
    };
    console.log([...iterable1]);
    // expected output: Array [1, 2, 3]

    // Dans des déclarations de classe ou dans des littéraux objets
    class Toto {
      *[Symbol.iterator] () {
        yield 1;
        yield 2;
        yield 3;
      }
    }
    const monObj = {
      *[Symbol.iterator] () {
        yield "a";
        yield "b";
      }
    }
    [... new Toto] // [1, 2, 3]
    [... monObj]   // ["a", "b"]

3. Si une méthode @@iterator d'un objet itérable ne renvoie pas d'objet itérateur,
on dira que cet objet est un itérable mal-formé. Utiliser de tels itérables peut provoquer 
des exceptions lors de l'exécution ou un comportement erratique
    Ex1:
    // Itérables mal-formés
    var itérableMalForme = {}
    iterableMalForme[Symbol.iterator] = () => 1
    [...iterableMalForme] // TypeError: [] is not a function


Le protocole « itérateur »
-------------------------------
1.Le protocole « itérateur » définit une façon standard pour produire une suite de valeurs (finie ou infinie) 
ainsi qu'une valeur de retour lorsque toutes les valeurs ont été générées.
Un objet est considéré comme un itérateur lorsqu'il implémente une méthode next() avec la sémantique suivante:
Une fonction sans argument qui doit toujours renvoyer un objet contenant les propriétés done et value. 
Si c'est une valeur primitive qui est renvoyée (ex. false ou undefined), une exception TypeError sera levée ("iterator.next() returned a non-object value").
  [done] (un booléen)
      Qui vaut true lorsque l'itérateur a fini la suite. Dans ce cas, la propriété value sera facultative et permettra de spécifier la valeur de retour de l'itérateur. Les valeurs de retour sont détaillées ici.
      Qui vaut false lorsque l'itérateur a pu produire la prochaine valeur de la suite. Si on ne définit pas la propriété done, on aura ce comportement par défaut.
  [value]
      N'importe quelle valeur JavaScript, renvoyée par l'itérateur. Cette propriété peut être absente lorsque done vaut true.

    Ex1:
    // L'itérateur par défaut d'un objet String renverra les caractères de la chaîne les uns à la suite des autres
    var uneChaine = "coucou";
    typeof uneChaine[Symbol.iterator]; // "function"
    var iterateur = uneChaine[Symbol.iterator](); // On récupère l'objet itérateur de l'objet String
    iterateur + "";     // "[object String Iterator]"
    iterateur.next();  // { value: "c", done: false }
    iterateur.next();  // { value: "o", done: false }
    iterateur.next();  // { value: "u", done: false }
    iterateur.next();  // { value: "c", done: false }
    iterateur.next();  // { value: "o", done: false }
    iterateur.next();  // { value: "u", done: false }
    iterateur.next();  // { value: undefined, done: true }

    Ex2:
    // Redéfinir le comportement par défaut de l'itérateur en définissant soi-même le symbole @@iterator
    var uneChaine = new String("yo"); // on construit un objet String explicitement afin d'éviter la conversion automatique
    uneChaine[Symbol.iterator] = function() {
      return { // l'objet itérateur qui renvoie un seul élément, la chaîne "bop"
        next: function() {
          if (this._first) {
            this._first = false;
            return { value: "bop", done: false };
          } else {
            return { done: true };
          }
        },
        _first: true
      };
    };
    [...uneChaîne];  // ["bop"]
    uneChaîne + "";  // "yo"

    Ex3:
    // Un itérateur simple
    function creerIterateur(tableau){
        var nextIndex = 0;
        
        return {
          next: function(){
              return nextIndex < tableau.length ?
                  {value: tableau[nextIndex++], done: false} :
                  {done: true};
          }
        }
    }
    var it = creerIterateur(['yo', 'ya']);
    console.log(it.next().value); // 'yo'
    console.log(it.next().value); // 'ya'
    console.log(it.next().done);  // true

    Ex4:
    // Un itérateur infini
    function créateurID(){
        var index = 0;
        
        return {
          next: function(){
              return {value: index++, done: false};
          }
        };
    }
    var it = créateurID();
    console.log(it.next().value); // '0'
    console.log(it.next().value); // '1'
    console.log(it.next().value); // '2'
    // ...

    Ex5:
    // Avec un générateur
    function* creerUnGenerateurSimple(tableau){
        var nextIndex = 0;
        
        while(nextIndex < tableau.length){
            yield tableau[nextIndex++];
        }
    }
    var gen = creerUnGenerateurSimple(['yo', 'ya']);
    console.log(gen.next().value); // 'yo'
    console.log(gen.next().value); // 'ya'
    console.log(gen.next().done);  // true

    Ex6:
    // Avec une classe (ES6)
    class ClasseSimple {
      constructor(data) {
        this.index = 0;
        this.data = data;
      }
      [Symbol.iterator]() {
        return {
          next: () => {
            if (this.index < this.data.length) {
              return {value: this.data[this.index++], done: false};
            } else {
              this.index = 0; 
              // En réinitialisant l'index, on peut 
              // "reprendre" l'itérateure sans avoir
              // à gérer de mise à jour manuelle
              return {done: true};
            }
          }
        };
      }
    }
    const simple = new ClasseSimple([1,2,3,4,5]);
    for (const val of simple) {
      console.log(val);  // '1' '2' '3' '4' '5' 
    }


Les générateurs function*
-------------------------------
1. La déclaration function* (le mot-clé function suivi par un astérisque) permet de définir un générateur
(aussi appelé une fonction génératrice) (un générateur est un objet Generator).
Les générateurs sont des fonctions qu'il est possible de quitter puis de reprendre. 
Le contexte d'un générateur (les liaisons avec ses variables) est sauvegardé entre les reprises successives.

2. Les générateurs, combinés avec les promesses, sont des outils de programmation asynchrones puissants qui permettent de réduire 
les inconvénients causés par les callbacks (fonctions de rappel) et l'inversion de contrôle.
Lorsqu'on appelle une fonction génératrice, son corps n'est pas exécuté immédiatement, c'est un itérateur 
qui est renvoyé pour la fonction. Lorsque la méthode next() de l'itérateur est appelée, le corps de la fonction génératrice 
est utilisé jusqu'à ce que la première expression yield soit trouvée. Cette expression définira la valeur à renvoyer pour l'itérateur.
Si on utilise yield*, on pourra déléguer la génération des valeurs à une autre fonction génératrice. La méthode next() renvoie 
un objet dont la propriété value contient la valeur générée et une propriété done qui indique si le générateur a produit sa dernière 
valeur ou non. Lorsqu'on appelle la méthode next() avec un argument, cela reprendra l'exécution de la fonction génératrice et remplacera 
la valeur de l'expression yield (là où l'exécution avait été interrompue) avec la valeur de l'argument passé à next().

3. On peut utiliser une instruction return dans un générateur. Lorsque cette instruction sera exécutée, 
le générateur sera terminé (done vaudra true). La valeur renvoyée par l'instruction return sera la valeur de terminaison du générateur. 
Une fois qu'un générateur est terminé, il ne peut plus produire d'autres valeurs.

4. À l'instar d'une instruction return, une exception levée à l'intérieur du générateur entraînera la terminaison du 
générateur sauf si cette exception est interceptée. Lorsqu'un générateur est terminé, les appels suivants à next() n'exécuteront 
aucun code provenant du générateur, ils renverront simplement un objet de la forme {value: undefined, done: true}.

    Ex1:
    // Exemple simple
    function* creerID(){
      var index = 0;
      while(index < 3){
        yield index++;
      }
    }
    var gen = creerID();
    console.log(gen.next().value); // 0
    console.log(gen.next().value); // 1
    console.log(gen.next().value); // 2
    console.log(gen.next().value); // undefined

    Ex2:
    // Avec des arguments
    function* logGenerator() {
      console.log(yield);
      console.log(yield);
      console.log(yield);
    }
    var gen = logGenerator();
    // le premier appel à next exécute la fonction depuis son 
    // début jusqu'au premier yield rencontré
    gen.next(); 
    gen.next('bretzel');    // bretzel
    gen.next('california'); // california
    gen.next('mayonnaise'); // mayonnaise

    Ex3:
    // Exemple utilisant yield* (Pour déléguer la génération des valeurs à un autre générateur)
    function* autreGenerateur(i) {
      yield i + 1;
      yield i + 2;
      yield i + 3;
    }
    function* generateur(i){
      yield i;
      yield* autreGenerateur(i);
      yield i + 10;
    }
    var gen = generateur(10);
    console.log(gen.next().value); // 10
    console.log(gen.next().value); // 11
    console.log(gen.next().value); // 12
    console.log(gen.next().value); // 13
    console.log(gen.next().value); // 20

    Ex4:
    // Utilisation de return
    function* yieldAndReturn() {
      yield "Y";
      return "R";
      yield "inaccessible";
    }
    var gen = yieldAndReturn();
    console.log(gen.next()); // { value: "Y", done: false }
    console.log(gen.next()); // { value: "R", done: true }
    console.log(gen.next()); // { value: undefined, done: true }

    Ex5:
    // Utiliser un générateur comme propriété
    const monObj = {
      *generator () {
        yield "a";
        yield "b";
      }
    }
    const gen = monObj.generator();
    console.log(gen.next()); // { value: "a", done: false }
    console.log(gen.next()); // { value: "b", done: false }
    console.log(gen.next()); // { value: undefined, done: true }

    Ex6:
    // Utiliser un générateur comme propriété calculée
    class Toto {
      *[Symbol.iterator] () {
        yield 1;
        yield 2;
      }
    }
    const monObj = {
      *[Symbol.iterator] () {
        yield "a";
        yield "b";
      }
    }
    console.log(Array.from(new Toto)); // [1, 2]
    console.log(Array.from(monObj));   // [ "a", "b"]

    Ex7:
    // Générateur défini avec une expression
    const toto = function* () {
      yield 10;
      yield 20;
    };
    const truc = toto();
    console.log(truc.next()); // {value: 10, done: false}


Héritage et chaîne de prototype
-------------------------------
1. JavaScript continue de reposer sur l'héritage prototypique. En ce qui concerne l'héritage, JavaScript n'utilise qu'une seule structure : les objets. 
Chaque objet possède une propriété privée qui contient un lien vers un autre objet appelé le prototype. Ce prototype possède également son prototype et 
ainsi de suite, jusqu'à ce qu'un objet ait null comme prototype. Par définition, null ne possède pas de prototype et est ainsi le dernier maillon de la chaîne de prototype.

2. La majorité des objets JavaScript sont des instances de Object qui est l'avant dernier maillon de la chaîne de prototype.

3. Les objets JavaScript sont des ensembles dynamiques de propriétés (les propriétés directement rattachées à un objet sont 
appelées propriétés en propre (own properties)). Les objets JavaScript possèdent également un lien vers un objet qui est leur prototype. 
Lorsqu'on tente d'accéder aux propriétés d'un objet, la propriété sera recherchée d'abord sur l'objet même, puis sur son prototype, puis 
sur le prototype du prototype et ainsi de suite jusqu'à ce qu'elle soit trouvée ou que la fin de la chaîne de prototype ait été atteinte.

4. Dans la spécification ECMAScript, on utilise la notation unObjet.[[Prototype]] pour faire référence au prototype de unObjet. 
Depuis ECMAScript 2015, on peut accéder à [[Prototype]] grâce aux accesseurs Object.getPrototypeOf() et Object.setPrototypeOf(). 
Cela est équivalent à la propriété JavaScript __proto__ qui était non-standard avant ES2015 mais qui était de fait implémentée par la majorité des navigateurs.

    Ex1:
    // On commence par créer un objet o pour lequel la fonction f sera 
    // son constructeur et lui créera deux propriétés en propre
    // a et b :
    let f = function () {
      this.a = 1;
      this.b = 2;
    }
    let o = new f(); // {a: 1, b: 2}

    // on ajoute des propriétés au prototype de la fonction
    // f
    f.prototype.b = 3;
    f.prototype.c = 4;

    // Note : on ne définit pas le prototype de f avec f.prototype = {b:3,c:4};
    // car cela briserait la chaîne de prototype

    // o.[[Prototype]] possède les propriétés b and c.
    // o.[[Prototype]].[[Prototype]] est Object.prototype.
    // Enfin, o.[[Prototype]].[[Prototype]].[[Prototype]] vaut null.
    // On a alors atteint la fin de la chaîne de prototype car,
    // par définition, null n'a pas de [[Prototype]].
    // Ainsi, la chaîne complète est ici :
    // {a: 1, b: 2} ---> {b: 3, c: 4} ---> Object.prototype ---> null

    console.log(o.a); // 1
    // Existe-t-il une propriété 'a' en propre sur o ? Oui, elle vaut 1.

    console.log(o.b); // 2
    // Existe-t-il une propriété 'b' en propre sur o ? Oui, elle vaut 2.
    // Le prototype possède également une propriété 'b' mais elle n'est pas
    // utilisée.
    // C'est ce qu'on appelle l'ombrage (shadowing en anglais)

    console.log(o.c); // 4
    // Existe-t-il une propriété 'c' en propre sur o ? Non, on vérifie le
    // prototype.
    // Existe-t-il une propriété 'c' en propre sur o.[[Prototype]] ?
    // Oui, elle vaut 4.

    console.log(o.d); // undefined
    // Existe-t-il une propriété 'd' en propre sur o ? Non, on vérifie le
    // prototype.
    // Existe-t-il une propriété 'd' en propre sur o.[[Prototype]] ? Non, on vérifie le 
    // prototype.
    // o.[[Prototype]].[[Prototype]] est Object.prototype et ne contient pas 
    // de propriété 'd' par défaut. On vérifie son prototype.
    // o.[[Prototype]].[[Prototype]].[[Prototype]] est null, on arrête la recherche
    // aucune propriété n'est trouvée, le moteur renvoie undefined.

5. Si un objet et son prototype possèdent la même propriété, celle du prototype n'est pas utilisée.
C'est ce qu'on appelle l'ombrage (shadowing en anglais)

6.Lorsquon définit une propriété sur un objet, cela définit une propriété en propre. 
La seule exception se produit lorsqu'on définit un accesseur et/ou un mutateur sur une propriété héritée.

7. JavaScript ne possède pas de méthodes au sens des langages de classe. En effet, en JavaScript, toute fonction associée à un objet est également une propriété. 
Une fonction héritée se comportera comme n'importe quelle autre propriété (y compris pour l'ombrage mentionné ci-avant où on pourra parler de surcharge).

8. Lorsqu'une fonction héritée est exécutée, la valeur de this pointe vers l'objet hérité et non vers l'objet prototype qui possède la fonction comme propriété en propre.

    Ex1:
    var o = {
      a: 2,
      m: function() {
        return this.a + 1;
      }
    };

    console.log(o.m()); // 3
    // Quand on appelle o.m ici, 'this' fera référence à o

    var p = Object.create(o);
    // p est un objet qui hérite de o

    p.a = 4; // on crée une propriété 'a' en propre sur p
    console.log(p.m()); // 5
    // lorsque p.m est appelée, 'this' fait référence à p.
    // Ainsi quand p hérite de m via o, 
    // 'this.a' signifie p.a, soit la propriété 'a' de p

9. En JavaScript, les fonctions peuvent avoir des propriétés. Toutes les fonctions ont une propriété spéciale intitulée prototype.

    Ex1:
    function faireUnTruc(){}
    console.log( faireUnTruc.prototype ); // Object {...}
    // Peu importe comment vous déclarez la fonction.
    // une fonction en JavaScript aura toujours une propriété
    // prototype par défaut.
    var faireUnTruc= function(){}; 
    console.log(faireUnTruc.prototype); // Object {...}
    
    Ex2:
    // Ajouter des propriétés au prototype de faireUnTruc()
    function faireUnTruc(){}
    faireUnTruc.prototype.toto = "truc";
    console.log( faireUnTruc.prototype );
    // {
    //   toto: "truc",
    //   constructor: ƒ faireUnTruc(),
    //   __proto__: {
    //       constructor: ƒ Object(),
    //       hasOwnProperty: ƒ hasOwnProperty(),
    //       isPrototypeOf: ƒ isPrototypeOf(),
    //       propertyIsEnumerable: ƒ propertyIsEnumerable(),
    //       toLocaleString: ƒ toLocaleString(),
    //       toString: ƒ toString(),
    //       valueOf: ƒ valueOf()
    //   }
    // }

    Ex3:
    // Toute fonction déclaré possède nativement une propriété « prototype » initialement vide
    var Dog = function() {}; // declaring constructor
    Dog.prototype;     // prints "{}" : prototype exists and is empty

10. On peut utiliser l'opérateur new afin de créer une instance de faireUnTruc() basée sur ce prototype. 
Pour utiliser l'opérateur new, il suffira d'appeler la fonction et de précéder cet appel avec le mot-clé new. 
Lorsqu'on appelle une fonction avec un opérateur new, celle-ci renvoie un objet qui est une instance de la fonction. 
On peut ensuite ajouter des propriétés sur cet objet.
    
    Ex1:
    function faireUnTruc(){}
    faireUnTruc.prototype.toto = "truc"; // on ajoute une propriété au prototype
    var uneInstance = new faireUnTruc();
    uneInstance.prop = "une valeur"; // on ajoute une propriété sur l'objet
    console.log(uneInstance);
    // {
    //   prop: "une valeur",
    //   __proto__: {
    //       toto: "truc",
    //       constructor: ƒ faireUnTruc(),
    //       __proto__: {
    //           constructor: ƒ Object(),
    //           hasOwnProperty: ƒ hasOwnProperty(),
    //           isPrototypeOf: ƒ isPrototypeOf(),
    //           propertyIsEnumerable: ƒ propertyIsEnumerable(),
    //           toLocaleString: ƒ toLocaleString(),
    //           toString: ƒ toString(),
    //           valueOf: ƒ valueOf()
    //       }
    //   }
    // }
    
    Ex2:
    function faireUnTruc(){}
    faireUnTruc.prototype.toto = "truc";
    var uneInstance = new faireUnTruc();
    uneInstance.prop = "une valeur";
    console.log("uneInstance.prop: " + uneInstance.prop);
    console.log("uneInstance.toto: " + uneInstance.toto);
    console.log("faireUnTruc.prop: " + faireUnTruc.prop);
    console.log("faireUnTruc.toto: " + faireUnTruc.toto);
    console.log("faireUnTruc.prototype.prop: " + faireUnTruc.prototype.prop);
    console.log("faireUnTruc.prototype.toto:  " + faireUnTruc.prototype.toto);
    // uneInstance.prop: une valeur
    // uneInstance.toto: truc
    // faireUnTruc.prop: undefined
    // faireUnTruc.toto: undefined
    // faireUnTruc.prototype.prop: undefined
    // faireUnTruc.prototype.toto: truc

    Ex3:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    bobby.bark(); // using the prototype declaration - prints "wouf wouf" to the console
    var felix = new Dog();
    (bobby.bark == felix.bark); // instances share same reference - returns true;
    bobby.bark = Dog.prototype.bark // which is the prototype property - returns true;

11. Performance. Le temps de recherche des propriétés sera plus élevé si ces propriétés sont situées plus loin dans la chaîne de prototype. 
Tenter d'accéder à ces propriétés éloignées pourra avoir un impact négatif sur les performances. 
De plus, tenter d'accéder à des propriétés inexistantes entraîntera toujours le parcours de l'ensemble de la chaîne de prototype.
Lorsqu'on parcourt les propriétés d'un objet, toutes les propriétés énumérables situées sur la chaîne de prototype seront parcourues. 
Pour vérifier si un objet possède une propriété en propre plus que via sa chaîne de prototype, on devra utiliser la méthode hasOwnProperty() 
qui est héritée grâce à Object.prototype.

    Ex1:
    function Graphe() {
      this.sommets = [];
      this.aretes = [];
    }
    Graphe.prototype = {
      ajoutSommet: function(v) {
        this.sommets.push(v);
      }
    };
    var g = new Graphe();
    // g est un objet qui possède les propriétés 'sommets' and 'aretes' en propre.
    // g.[[Prototype]] est la valeur de Graphe.prototype lorsque "new Graphe()" est exécuté.
    console.log(g.hasOwnProperty('aretes'));
    // true
    console.log(g.hasOwnProperty('nononon'));
    // false
    console.log(g.hasOwnProperty('ajoutSommet'));
    // false
    console.log(g.__proto__.hasOwnProperty('ajoutSommet'));
    // true

12. Tester si une propriété vaut undefined ne suffit pas à vérifier la présence de la propriété sur un objet : 
une propriété peut très bien exister sur un objet mais valoir undefined.

14. Mauvaise pratique : étendre les prototypes natifs. On peut parfois voir du code qui étend Object.prototype ou l'un des prototypes natifs.
Cette technique est intitulée monkey patching et brise l'encapsulation. Bien qu'elle soit utilisée par certains frameworks, il n'existe pas de 
raison suffisante pour étendre les objets natifs avec des fonctionnalités non-standard.
La seule raison qui peut prévaloir pour l'extension de prototypes natifs est l'ajout de fonctionnalités JavaScript apparues 
avec les nouvelles versions des spécifications et moteurs afin d'en disposer dans de plus anciens environnements.

15. On peut surcharger sur une instance une propriété définie sur son prototype. 
Cependant cela ne surcharge que sa propre référence, et ne touche donc pas à la déclaration du prototype.

    Ex1:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    var felix = new Dog();
    bobby.bark = function() { console.log("beeeee !") }; // setting the bark property on dogA
    bobby.bark(); // using the instance function, prints "beeee !" to the console
    felix.bark(); // still using the prototype function, prints "wouf wouf" to the console.

16. Une modification du prototype est immédiate sur les instances déjà existantes et les futures. 
En effet le prototype est une référence des instances, et le « fallback » se fait au moment de l'accès à la propriété.

    Ex1:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    bobby.bark(); // prints "wouf wouf" to the console
    Dog.prototype.bark = function() { console.log("meow meow"); } // overrides the prototype bark method
    bobby.bark(); // now prints "meow meow" to the console.

17. Une méthode modifiée sur le prototype est immédiatement active, un rajout l'est aussi.

    Ex1:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    bobby.sleep(); // Raise a TypeError : has no method sleep
    Dog.prototype.sleep = function() { console.log("Zzz Zzz"); }
    bobby.sleep(); // now prints "Zzz Zzz" to the console.

18. La classe d'une instance (enfin, techniquement, le constructeur) est accessible via la propriété constructor. 
Cela permet également d'accéder à son prototype (même s'il est très rare d'y voir une utilité).

    Ex1:
    var Dog = function() {}; // declaring constructor
    // Une propriété rajouté sur le prototype du constructeur devient disponible sur les instances
    Dog.prototype.bark = function() { // defining a method on the Dog prototype
      console.log("wouf wouf");
    };
    var bobby = new Dog();
    bobby.constructor === Dog; // bobby constructor is Dog, returns true
    bobby.constructor.prototype.bark // direct access to the prototype

    // Le mot clef instanceof de javascript fonctionne bien avec les constructeurs
    bobby instanceof Dog; // bobby is an instance of Dog, returns true


Les différentes façons de créer des objets et les impacts sur la chaîne de prototype
-------------------------------
    Ex1:
    // Objets créés avec les raccourcis syntaxiques (littéraux)
    var o = {a: 1};
    // Le nouvel objet possède Object.prototype comme [[Prototype]]
    // o ne possède pas de propriété 'hasOwnProperty' en propre
    // hasOwnProperty est une propriété en propre de Object.prototype. 
    // o hérite de hasOwnProperty via Object.prototype
    // Object.prototype possède null comme prototype.
    // o ---> Object.prototype ---> null
    var myObject = {
      a : 1,
      b : 2,
      sum : function() {
        return this.a + this.b;
      }
    };
    // myObject ---> Object.prototype ---> null

    var b = ['coucou', 'ça va', '?'];
    // Les tableaux (Array) héritent de Array.prototype 
    // (qui possède les méthodes indexOf, forEach, etc.)
    // La chaîne de prototype est donc :
    // b ---> Array.prototype ---> Object.prototype ---> null

    function f() {
      return 2;
    }
    // Les fonctions héritent de Function.prototype 
    // (qui possède les méthodes call, bind, etc.)
    // La chaîne de prototype est donc
    // f ---> Function.prototype ---> Object.prototype ---> null
    
    Ex2:
    // Objets créés avec un constructeur
    // En JavaScript, un constructeur est juste une fonction que l'on invoque avec l'opérateur new.
    function Graphe() {
      this.sommets = [];
      this.arêtes = [];
    }
    Graphe.prototype = {
      ajoutSommet: function(v) {
        this.sommets.push(v);
      }
    };
    var g = new Graphe();
    // g est un objet qui possède les propriétés 'sommets' and 'arêtes' en propre.
    // g.[[Prototype]] est la valeur de Graphe.prototype lorsque "new Graphe()" est exécuté.

    // Toute fonction peut servir de constructeur : il suffit simplement de l'appeler avec l'opérateur new.
    var Dog = function() {   // defining Dog constructor
      this.hasTail = true; // defining a property
      this.bark = function() { // defining a method property
        console.log("wouf wouf");
      }
    }
    var bobby = new Dog(); // instanciating the constructor
    bobby.hasTail; // returns true
    bobby.bark();  // print "wouf wouf" to the console

    // Pour définir une propriété des futures instances, il faut utiliser le mot clef this. En effet var ne suffit pas. 
    // C'est d'ailleurs une particularité intéressante dont on peut se servir pour déclarer des variables privées de l'instance
    var Dog = function() {
      var shout = "wouf wouf"; // defining a local var.
      this.bark = function() {
        console.log(shout); // local scope access the 'shout' variable
      }
    }
    var bobby = new Dog();
    bobby.bark();  // print "wouf wouf" to the console
    bobby.shout;   // undefined , not attached to the instance

    // Il est également possible de passer des paramètres à un constructeur 
    var Dog = function(breed) {
      this.breed = breed;
    }
    var bobby = new Dog("terrier");
    bobby.breed;  // returns "terrier"

    // Problème : comme la déclaration des méthodes se fait lors de l'instanciation, les instances ne partageant pas leurs méthodes.
    var Dog = function() {
      this.bark = function() {
        console.log(shout);
      }
    }
    var bobby = new Dog();
    var felix = new Dog();
    (boddy.bark == felix.bark); // returns false. They both declared their own method. 
    
    Ex3:
    // Objets créés avec Object.create()
    // Appeler cette méthode crée un nouvel objet et le prototype de cet objet est le premier argument de cette fonction
    var a = {a: 1}; 
    // a ---> Object.prototype ---> null

    var b = Object.create(a);
    // b ---> a ---> Object.prototype ---> null
    console.log(b.a); // 1 (héritée)

    var c = Object.create(b);
    // c ---> b ---> a ---> Object.prototype ---> null

    var d = Object.create(null);
    // d ---> null
    console.log(d.hasOwnProperty); 
    // undefined, car d n'hérite pas de Object.prototype  
    
    Ex4:
    // Objets créés avec le mot-clé class
    // ECMAScript 2015 introduit plusieurs mots-clés destinés à créer du sucre syntaxique pour manipuler des classes. 
    // Ces mots-clés sont class, constructor, static, extends et super
    'use strict';
    class Polygone {
      constructor(hauteur, largeur) {
        this.hauteur = hauteur;
        this.largeur = largeur;
      }
    }
    class Carre extends Polygone {
      constructor(longueurCote) {
        super(longueurCote, longueurCote);
      }
      get aire() {
        return this.hauteur * this.largeur;
      }
      set longueurCote(nouvelleLongueur) {
        this.hauteur = nouvelleLongueur;
        this.largeur = nouvelleLongueur;
      }
    }
    var carre = new Carre(2);
    

Comparer des objets
-------------------------------
1. En JavaScript, les objets fonctionnent par référence. Deux objets distincts ne sont jamais égaux, même s'ils ont les mêmes valeurs 
pour les mêmes propriétés. On aura une équivalence uniquement si on compare un objet avec lui-même.

    Ex1:
    // Deux variables avec deux objets distincts qui ont les mêmes propriétés
    var fruit = {nom: "pomme"};
    var fruit2 = {nom: "pomme"};
    fruit == fruit2  // return false
    fruit === fruit2 // return false
    // Deux variables avec un même objet
    var fruit = {nom: "pomme"};
    var fruit2 = fruit;  // On affecte la même référence
    // dans ce cas fruit et fruit2 pointent vers le même objet
    fruit == fruit2  // return true
    fruit === fruit2 // return true
    fruit.nom = "raisin";
    console.log(fruit2); // affiche {nom: "raisin"} et non {nom: "pomme"}


Utiliser this
-------------------------------
1. JavaScript possède un mot-clé spécial this, qui peut être utiliser à l'intérieur d'une méthode pour faire référence à l'objet courant.

    Ex1:
    // Si on a une fonction valider qui permet de valider la propriété 
    // valeur d'un objet en fonction d'un seuil minimum et d'un seuil maximum
    function valider(obj, seuilMin, seuilMax) {
      if ((obj.value < seuilMin) || (obj.valeur > seuilMax))
        console.log("Valeur invalide !");
    }

    // Cette fonction pourrait ensuite être appelée via le gestionnaire d'événement onchange 
    // pour les éléments d'un formulaire et la valeur pour l'élément du formulaire serait passée en argument
    <input type="text" name="age" size="3" onChange="valider(this, 18, 99)">

2. En général, this fait référence à l'objet appelant de la méthode.


Promise, Async et Await
-------------------------------
 1. La nature asynchrone du JavaScript pose souvent des problèmes en terme d'organisation. Si on vient d'un langage plus classique 
 il est parfois difficile de concevoir des fonctions avec une résolution asynchrone. 
 Comment renvoyer les résultats quand le code n'est pas exécuté de manière synchrone ?

 2. Les callbacks
 Nous souhaitons donc créer une fonction pour faire un appel Ajax. 
 La résolution de la requête Ajax se fait de manière asynchrone et il n'est donc pas possible d'utiliser un simple return.
 Il faut donc être capable de détecter la résolution de la requête afin d'effectuer la suite de nos traitements. La solution pour remédier cette problématique est d'utiliser 
 des fonctions anonymes que l'on va éxécuter lors de la résolution de notre code. Ces fonctions sont appellées callbacks.

    Ex1:
    var ajax = function (url) {
      var req = new XMLHttpRequest()
      req.open('GET', url, true)
      req.onreadystatechange = function (aEvt) {
        if (req.readyState == 4) {
          if(req.status == 200)
            // return req.responseText n'est pas possible
            // On ne peut pas utiliser de "return" ici car on est dans la fonction 
            // onReadyStateChange
          else
            // ...
        }
      };
      req.send(null)
    }
    ajax('https://jsonplaceholder.typicode.com/users') 
    // Comment détecter la fin de la requête ajax ?

    Ex2:
    var ajax = function (url, success, error) {
      var req = new XMLHttpRequest()
      req.open('GET', url, true)
      req.onreadystatechange = function (aEvt) {
        if (req.readyState == 4) {
          if(req.status == 200)
            success(req.responseText)
          else
            error(req)
        }
      };
      req.send(null)
    }
    ajax('https://jsonplaceholder.typicode.com/users', function (response) {
      // response contient la réponse de la requête, on peut faire le reste du traitement
    }, function (req) {
      // Le serveur n'a pas répondu comme attendu, on traite l'erreur
    })

    Ex3:
    // Cette méthode fonctionne mais si vous souhaitez effectuer des opérations asynchrones en cascade votre code va vite ressembler à ça...
    ajax('https://jsonplaceholder.typicode.com/users', function (response) {
      ajax('https://jsonplaceholder.typicode.com/posts', function (response) {
        ajax('https://jsonplaceholder.typicode.com/tutoriels', function (response) {
          // Là j'ai tout !
        }, function (req) { })
      }, function (req) { })
    }, function (req) { })

3. Les promesses
Les promesses permettent une approche différente du problème et sont apparues avec l'ES2015.
A vu de nez cette méthode semble proche de la méthode précédente. Cependant, les promesses peuvent 
être enchainées ce qui simplifie grandement la gestion en cascades et en parallèle.

    Ex1:
    let ajax = function (url) {
      // On renvoie une promesse qui prend en paramettre une fonction 
      // avec 2 paramètres, le callback de succès et d'erreur
      return new Promise(function (resolve, reject) {
        // Le reste du code ressemble à la méthode précédente
        let req = new XMLHttpRequest()
        req.open('GET', url, true)
        req.onreadystatechange = function (aEvt) {
          if (req.readyState == 4) {
            if(req.status == 200)
              resolve(req.responseText)
            else
              reject(req)
          }
        };
        req.send(null)
      })
    }
    // L'appel à la fonction peut se faire de cette manière là
    ajax('https://jsonplaceholder.typicode.com/users')
    .then(function (response) {
      // Le serveur a correctement répondu
    }).catch(function (req) {
      // Le serveur n'a pas répondu comme attendu
    })

    Ex2:
    let ajax = function (url) {
      // On renvoie une promesse qui prend en paramettre une fonction 
      // avec 2 paramètres, le callback de succès et d'erreur
      return new Promise(function (resolve, reject) {
        // Le reste du code ressemble à la méthode précédente
        let req = new XMLHttpRequest()
        req.open('GET', url, true)
        req.onreadystatechange = function (aEvt) {
          if (req.readyState == 4) {
            if(req.status == 200)
              resolve(req.responseText)
            else
              reject(req)
          }
        };
        req.send(null)
      })
    }
    // Cascade
    ajax('https://jsonplaceholder.typicode.com/users')
    .then(function (response) {
      // Si le then retourne une promesse on peut enchainer
      return ajax('https://jsonplaceholder.typicode.com/posts')
    })
    .then(function (response) {
      // Si le then retourne une promesse on peut enchainer
      return ajax('https://jsonplaceholder.typicode.com/comments')
    })
    .then(function (response) {
      // La série d'opération est finie
    })
    .catch(function (req) {
      // Une des requête a échouée
    })

    Ex3:
    // En parallèle
    Promise.all([
      ajax('https://jsonplaceholder.typicode.com/users'),
      ajax('https://jsonplaceholder.typicode.com/posts'),
      ajax('https://jsonplaceholder.typicode.com/comments')
    ]).then(function (responses) {
      responses // [response1, response2, response3]
    }).catch(function (errors) { })

4. Async & Await
L'ES2017 propose en draft une amélioration du système de promesses avec la création de fonction asynchrones.

    Ex1:
    let ajax = function (url) {
      // On renvoie une promesse qui prend en paramettre une fonction 
      // avec 2 paramètres, le callback de succès et d'erreur
      return new Promise(function (resolve, reject) {
        // Le reste du code ressemble à la méthode précédente
        let req = new XMLHttpRequest()
        req.open('GET', url, true)
        req.onreadystatechange = function (aEvt) {
          if (req.readyState == 4) {
            if(req.status == 200)
              resolve(req.responseText)
            else
              reject(req)
          }
        };
        req.send(null)
      })
    }
    // Une fonction qui renvoie une promesse peut être marqué comme "async"
    // Elle peut alors attendre la résolution d'une autre promesse avec "await"
    let getPost = async function () {
      // Plutot que d'utiliser le then on peut attendre la résolution
      let response = await ajax('https://jsonplaceholder.typicode.com/posts')
      // Return permettra le resolve de la promesse
      return JSON.parse(response) 
      // Un throw permettra de reject la promesse
    }
    // Cette fonction s'utilise comme précédemment
    getPost().then(posts => {
      console.log(posts)
    }).catch(error => { })

    Ex2:
    let ajax = function (url) {
      // On renvoie une promesse qui prend en paramettre une fonction 
      // avec 2 paramètres, le callback de succès et d'erreur
      return new Promise(function (resolve, reject) {
        // Le reste du code ressemble à la méthode précédente
        let req = new XMLHttpRequest()
        req.open('GET', url, true)
        req.onreadystatechange = function (aEvt) {
          if (req.readyState == 4) {
            if(req.status == 200)
              resolve(req.responseText)
            else
              reject(req)
          }
        };
        req.send(null)
      })
    }
    let getPosts = async function () {
      let response = await ajax('https://jsonplaceholder.typicode.com/users')
      let users = JSON.parse(response)
      response = await ajax(`https://jsonplaceholder.typicode.com/comments?usersId=${user[0].id}`)
      let posts = JSON.parse(response)
      return posts
    }
    let getFirtPost = async function () {
       let posts = await getPosts()
       return posts[0]
    }
    getFirtPost().then(function(post) {
      console.log(post)
    }).catch(function(error) {
      console.log(error)
    }).then(function() {
      console.log('Fin des requêtes AJAX')
    })


Fetch
-------------------------------
1. Fetch est une nouvelle API qui vient remplacer XMLHttpRequest avec un support natif des Promesses.

    Ex1:
    const getUsers = async function() {
      try {
        let response = await fetch(https://jsonplaceholder.typicode.com/users)
        if (response.ok) {
          let data = await response.json()
            console.log(data)          
        } else {
          console.error(`Retour du serveur : `${response.status})
        }
      } catch(e) {
        console.log(e)
      }
    }
    const insertPost = async function(data) {
      let response = await fetch(https://jsonplaceholder.typicode.com/posts), {
        method: 'POST',
        headers: {
        'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
      let responseData = await response.json()
    }
    insertPost({
      name:Jean,
      age:29
    })

    Ex2:
    // Validation AJAX d'un formulaire avec fetch
    let form = document.querySelector('#contact')
    let button = form.querySelector('button[type=submit]')
    let buttonText = button.textContent
    form.addEventListener('submit', async function (e) {
      button.disabled = true
      button.textContent = 'Chargement...'
      let errorElements = form.querySelectorAll('.has-error')
      for (let i = 0; i < errorElements.length; i++) {
        errorElements[i].classList.remove('has-error')
        let span = errorElements[i].querySelector('.help-block')
        if (span) {
          span.parentNode.removeChild(span)
        }
      }
      e.preventDefault()
      let data = new FormData(form)
      try {
        let response = await fetch(form.getAttribute('action'), {
          method: 'POST',
          headers: {
            'X-Requested-With': 'xmlhttprequest'
          },
          body: data
        })
        let responseData = await response.json()
        // La réponse n'est pas bonne (pas 200), on affiche les erreurs
        if (!response.ok) {
          let errors = responseData
          let errorsKey = Object.keys(errors)
          for (let i = 0; i < errorsKey.length; i++) {
            let key = errorsKey[i]
            let error = errors[key]
            let input = document.querySelector('[name=' + key + ']')
            let span = document.createElement('span')
            span.className = 'help-block'
            span.innerHTML = error
            input.parentNode.classList.add('has-error')
            input.parentNode.appendChild(span)
          }
        // La réponse est ok, on vide le formulaire
        } else {
          let inputs = form.querySelectorAll('input, textarea')
          for (let i = 0; i < inputs.length; i++) {
            inputs[i].value = ''
          }
          alert('Merci pour votre message')
        }
      } catch (e) {
        alert(e)
      }
      // Dans tous les cas on permet la soumission du formulaire à nouveau
      button.disabled = false
      button.textContent = buttonText
    })


AJAX
-------------------------------
1. L'Ajax permet d'appeller une page en JavaScript et de récupérer les informations 
afin d'effectuer un traitement particulier.
Le point d'entré de l'Ajax est l'utilisation d'un objet spécifique : XMLHttpRequest. 
Malheureusement cet objet n'est pas disponible dans tous les navigateur et il est donc conseillé d'utiliser une fonction pour générer l'objet dont on va avoir besoin.

    Ex1:
    var getHttpRequest = function () {
      var httpRequest = false;
      if (window.XMLHttpRequest) { // Mozilla, Safari,...
        httpRequest = new XMLHttpRequest();
        if (httpRequest.overrideMimeType) {
          httpRequest.overrideMimeType('text/xml');
        }
      }
      else if (window.ActiveXObject) { // IE
        try {
          httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
        }
        catch (e) {
          try {
            httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
          }
          catch (e) {}
        }
      }
      if (!httpRequest) {
        alert('Abandon :( Impossible de créer une instance XMLHTTP');
        return false;
      }
      return httpRequest
    }
    var xhr = getHttpRequest()
    xhr.open('GET', 'https://jsonplaceholder.typicode.com/users', true)
    // On envoit un header pour indiquer au serveur que la page est appellée en Ajax
    xhr.setRequestHeader('X-Requested-With', 'xmlhttprequest')
    // On lance la requête
    xhr.send()
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
            console.log(xhr.responseText) // xhr.responseText contient le résultat de la page
        } else {
            alert('Impossible de contacter le serveur')// Le serveur a renvoyé un status d'erreur
        }
      }
    }

2. Si vous souhaitez soumettre des informations vous pouvez utiliser l'objet FormData

    Ex1:
    var data = new FormData() 
    data.append('name', 'John Doe')
    data.append('email, 'contact@local.dev')

    var xhr = getHttpRequest()
    xhr.open('POST', 'http://localhost/demo.php', true)
    xhr.setRequestHeader('X-Requested-With', 'xmlhttprequest')
    xhr.send(data)

    Ex2:
    // si l'on veut poster un formulaire
    var form = document.querySelector('#form')
    var data = new FormData(form) 

    var xhr = getHttpRequest()
    xhr.open('POST', 'http://localhost/demo.php', true)
    xhr.setRequestHeader('X-Requested-With', 'xmlhttprequest')
    xhr.send(data)

3. Ajax + JSON 
Le problème lorsque l'on appelle la page est que l'on récupère les informations sous forme 
de chaine de caractères. Le problème est que parfois on souhaite transmettre des informations plus complexes. Dans ce cas là on utilisera la format JSON. 
Ce format à l'avantage d'être facilement compréhensible en JavaScript.

    Ex1:
    var test = 'UN TRUC EN JSON'
    var items = JSON.parse(test)

4. Limitation et CORS
Attention, on ne peut pas appeler une page provenant d'un domaine différent. 
Si on souhaite appeller une page différente de la page en cours, il faudra que le serveur dispose du CORS.


Les modules JavaScript import / export
-------------------------------
Voir https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules