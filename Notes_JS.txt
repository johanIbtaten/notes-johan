var, let, const
-------------------------------
Déclaration (var a;) initialisation : var a=2;
Déclaration (let a;) initialisation : let a=2;
Déclaration, initialisation : const a=2;
Scope (ou Portée en français)

var   : Scope dans les fonctions 
        Pas de scope dans les blocs (blocs types if, for, while, etc.)
        Si var est déclaré sans valeur initiale (ex: var a;) elle aura la valeur undefined

let   : Scope dans les fonctions 
        Scope dans les blocs (blocs types if, for, while, etc.)
        Si let est déclaré sans valeur initiale (ex: let a;) elle aura la valeur undefined

const : Scope dans les fonctions 
        Scope dans les blocs (blocs types if, for, while, etc.)
        const a besoin d'être déclaré avec une valeur initiale (ex: const a=2;)
	      On ne peut pas réassigner la valeur d'une constante (ex: a=4;)
        On ne peut pas re-déclarer dans la même portée une autre constante avec le même nom (ex: const a=4;)
        --------------------------------------------
        On peut ajouter ou supprimer les éléments d'un tableau
        On ne peut pas changer la structure d'un objet littéral
        On peut changer les valeurs d'un objet littéral


Types de données
-------------------------------
Numbers — var age = 23
Variables — var x
Text (strings) — var a = "init"
Operations — var b = 1 + 2 + 3
True or false statements (boolean) — var c = true
Constant numbers — const PI = 3.14
Objects — var name = {firstName:"John", lastName:"Doe"}
Undefined — var a; console.log(a); retourne undefined
Null  — var a = null


Différence entre undefined et null
-------------------------------
/// undefined : ///
1. Une variable possède la valeur undefined si elle n'est pas déclarée ou si elle est déclarée mais n'a pas encore eu de valeur d'assignée.

    Ex1: 
    var maVariable;
    alert(maVariable); // Le texte undefined s'affichera à l'écran, car la variable est non définie.
   
    Ex2: 
    function direBonjour(message) {
      console.log(message)
    }
    direBonjour(); // Le texte undefined s'affichera à l'écran, car la variable message déclarée en paramètre est non définie.

2. Il y a une faille dans JavaScript à connaître : le mot undefined n'est pas un mot-clé du langage. Il est donc possible de nommer une variable undefined, puis de lui attribuer une valeur.

    Ex1: 
    var undefined = toto; //Cette déclaration n'est pas fausse, contrairement à ce que l'on pourrait croire.
    if(maVariable === undefined) {
      alert(Vous avez été trompés!);
    }

3. Pour tester si une variable n'a pas été déclaré ou assignée, il faut utiliser typeof. 
typeof renvoie une chaîne qui indique le type de l'opérande (Quantité, donnée qui entre dans une opération arithmétique, une instruction informatique).

    Ex1:
    if (typeof maVariable === "undefined") {
      alert("La variable maVariable n'est pas définie");
    }

    Ex2:
    var x;
    if (typeof x === 'undefined') {
       // ces instructions seront exécutées
    }
    if (typeof x !== 'undefined') {
       // ces instructions ne seront pas exécutées
    }

4. Pour tester si une propriété d'objet est indéfinie on peut aussi utiliser typeof

    Ex1:
    const list = []
    const count = 2
    typeof list // "object"
    typeof count // "number"
    typeof "test" // "string"
    typeof color // "undefined"
    const car = {
      model: 'Fiesta'
    }
    if (typeof car.color === "undefined") {
      // color is undefined
    }

5. Une fonction qui n'a pas de valeur de return affiche undefined

    Ex1:
    function add() {
      const a = 3;
    }
    add(); // affiche undefined

/// null : ///
1. null sert à définir l'absence de valeur, on s'en sert par exemple pour assigner une valeur par défaut à des variables ou des paramètres de fonction, c'est une méthode beaucoup plus propre que d'assigner une valeur arbitraire comme 0 pour un entier, ou une chaine de caractère vide pour une chaine de caractère.

    Ex1:
    // toto n'existe pas, n'a pas été défini (déclaré) et n'a jamais été initialisé (assigné)
    toto;
    "ReferenceError: toto is not defined"
    // toto existe mais n'a ni type ni valeur
    var toto = null;
    console.log(toto); // null

    Ex2:
    function direBonjour(message = null) { // Valeur par défaut de message égale à null
      console.log(message); // null
    }

    Ex3:
    typeof null;           // "object" (pas null pour des raisons historiques)
    typeof undefined;      // "undefined"
    null === undefined;    // false
    null  == undefined;    // true
    null === null;         // true
    null  == null;         // true
    !null;                 // true
    isNaN(1 + null);       // false
    isNaN(1 + undefined);  // true


Double ou simple quotes ou accent grave (backquote ou backtick en anglais)
-------------------------------
1. C'est selon les préférences. L'avantage des doubles quotes est qu'il permet d'échapper les apostrophes et se conforme à JSON

    Ex1:
    alert('Say "Hello"');
    alert("Say 'Hello'");
    alert("It's \"game\" time.");
    alert('It\'s "game" time.');

2. En ES6 on peut aussi utiliser les template literals

    Ex1:
    alert(`Use "double" and 'single' quotes in the same string`);
    alert(`Escape the \` back-tick character and the \${ dollar-brace sequence in a string`);


Opérateur void
-------------------------------
1. L'opérateur void évalue (exécute) l'expression donnée void(0) équivaut à void 0 et retourne ensuite undefined.
    Ex1:
    void 2 == '2';    // renvoie false, attention à la précédence et donc mieux vaut utiliser des parenthèses
    void (2 === '2'); // renvoie undefined

2. On peut utiliser void pour ajouter un comportement preventDefault () pour un lien
    Ex1:
    <a href="javascript: void(0)"> À propos de </a>

3. On peut utiliser void pour qu'une function retourne undefined même si elle possède une valeur de retour.
    Ex1:
    function add() {
      const a = 3; return a
    };
    console.log(add()); // affiche 3
    console.log(void add()); // affiche undefined


La « remontée » des déclarations de fonction
-------------------------------
1. Lorsqu'on utilise une déclaration de fonction pour créer une fonction, la définition de la fonction est « remontée » (hoisting). Il devient donc possible d'utiliser la fonction avant de l'avoir déclarée
    Ex1:
    remontée(); // affiche "toto" dans la console
    function remontée() {
      console.log("toto");
    }


Les expressions de fonctions
-------------------------------
1. Une expression de fonction est très similaire et a presque la même syntaxe qu'une déclaration de fonction. La différence principale entre une expression de fonction et une instruction est le nom de la fonction. En effet, pour les expressions, celui peut être omis (on parle alors d'une fonction anonyme). 
    Ex1:
    var getRectArea = function(width, height) {
    return width * height;
    }
    console.log(getRectArea(3,4));
    // expected output: 12    

2. En JavaScript, les expressions de fonction ne sont pas remontées (à la différence des déclarations de fonction). Il est donc impossible d'utiliser les expressions de fonction avant leur définition.
    Ex1:
    nonRemontée(); // TypeError: nonRemontée is not a function
    var nonRemontée = function() {
      console.log("truc");
    }

3. On peut utiliser une expression de fonction pour créer une « IIFE » (Immediately Invoked Function Expression), c'est-à-dire une expression de fonction qu'on appelle dès sa définition.
    Ex1:
    var a = "coucou";
    var b = "monde";
    // IIFE
    (function(x, y) {
      console.log(x + " " + y);
    })(a, b);
    // coucou monde


Les fonctions flechées (arrow function en anglais)
-------------------------------
    // Avant ES6
    const add = function(x, y) {
        return x + y
    }
    console.log(add(5, 4)) // 9
1. Une expression de fonction fléchée permet d’avoir une syntaxe plus courte que les expressions de fonction. Les fonctions fléchées sont souvent anonymes et ne sont pas destinées à être utilisées pour déclarer des méthodes.    
    Ex1:    
    // ES6
    const addES6 = (x, y) => { return x + y }
    console.log(addES6(5, 6)) // 11

2. Les accolades ne sont même pas obligatoire ici et le mot clé return aussi, parce que l'on renvoie une seule instruction.
    Ex1:
    // ES6
    const addES6 = (x, y) => x + y
    console.log(addES6(5, 6)) // 11

3. Quand on a un seul paramètre, nous n'avons donc pas besoin des parenthèses, on renseigne juste le nom du paramètre.
    Ex1:
    // ES6
    const hello = name => `Hello ${name}`
    console.log(hello('Niang')) // Hello Niang

    Ex2:
    var simple = a => a > 15 ? 15 : a; 
    simple(16); // 15
    simple(10); // 10


4. Pour définir une fonction sans paramètre, on met juste des parenthèses vides.
    Ex1:
    // ES6
    const helloWorld = () => 'Hello World!'
    console.log(helloWorld()) // Hello World!

5. Pour retourner un objet, il y a une petite différence, parce que l'objet doit être dans des accolades, il faut donc mettre le return entre parenthèses cette fois-ci pour faire la différence.
    Ex1:
    const setContent = (title, content) => ({title: title, content: content})
    console.log(setContent('Hello', 'ES6')) // {title: "Hello", content: "ES6"}

6. Il ne peut pas y avoir de saut de ligne entre les paramètres et la flèche d’une fonction fléchée.
    Ex1:
    var func = ()
            => 1; // SyntaxError: expected expression,
                  //              got '=>'

7. La flèche utilisée pour une fonction fléchée n’est pas un opérateur. Les fonctions fléchées ont des règles spécifiques quant à leur place dans la syntaxe et interagissent différemment de la précédence des opérateurs par rapport à une fonction classique.
    Ex1:
    let fonctionRappel;
    fonctionRappel = fonctionRappel || function () {};
    // OK
    fonctionRappel = fonctionRappel || () => {};
    // SyntaxError: invalid arrow-function arguments
    fonctionRappel = fonctionRappel || (() => {});
    // OK

8. Les fonctions fléchées sont mieux indiquées pour les fonctions qui ne sont pas des méthodes (fonctions dans un objet).
    Ex1:
    'use strict';
    var objet = {
      i: 10,
      b: () => console.log(this.i, this),
      c: function() {
        console.log(this.i, this);
      }
    }
    objet.b(); 
    // affiche undefined, Window (ou l'objet global de l'environnement)
    objet.c();
    // affiche 10, Object {...}

9. Les fonctions fléchées ne créent pas de nouveau contexte, elles utilisent la valeur this de leur contexte. Aussi, si le mot-clé this est utilisé dans le corps de la fonction, le moteur recherchera la référence à cette valeur dans une portée parente.
    Ex1:
    // Avant ES6
    function Personne () {
      var that = this; 
      that.age = 0;
      setInterval(function grandir () {
        // La fonction callback se réfère à la variable `that`
        // qui est le contexte souhaité
        that.age++;
      }, 1000);
    }
    // ES6
    function Personne () {
      this.age = 0;
      setInterval(() => {
        this.age++; 
          // |this| fait bien référence à l'objet personne
      }, 1000);
    }
    var p = new Personne();


10. Exemples d'utilisation
    Ex1:
    (() => "tototruc")() 
    // exemple d'une fonction immédiatement 
    // invoquée (IIFE en anglais) qui renvoie 
    // "tototruc" 

    var complexe = (a, b) => {
      if (a > b) {
          return a;
      } else {
          return b;
      }
    }

    var arr = [5, 6, 13, 0, 1, 18, 23];
    var sum = arr.reduce((a, b) => a + b);
    // 66
    var even = arr.filter(v => v % 2 == 0);
    // [6, 0, 18]
    var double = arr.map(v => v * 2);       
    // [10, 12, 26, 0, 2, 36, 46]


Objet Map
-------------------------------
1. L'objet Map représente un dictionnaire, autrement dit une carte de clés/valeurs. 
N'importe quelle valeur valable en JavaScript (que ce soit les objets ou les valeurs de types primitifs) 
peut être utilisée comme clé ou comme valeur. Un objet Map permet de retrouver ses éléments dans leur ordre d'insertion. 
Par exemple, une boucle for...of renverra un tableau de [clé, valeur] pour chaque itération.

//new Map([itérable])
    [itérable]
        Un tableau (Array) ou tout autre objet itérable dont les éléments sont des paires clé/valeur (par exemple un tableau de la forme [[1 , "toto"],[2, "truc"]]). Chaque paire clé/valeur sera ajoutée au nouvel objet Map. null est traité comme undefined.
    
    Ex1:
    // Utiliser un objet Map
    var maMap = new Map();
    var objetCle = {},
        fonctionCle = function () {},
        chaineCle = "une chaîne";
    // définir les valeurs
    maMap.set(chaineCle, "valeur associée à 'une chaîne'");
    maMap.set(objetCle, "valeur associée à objetCle");
    maMap.set(fonctionCle, "valeur associée à fonctionCle");
    maMap.size; // 3
    // récupérer les valeurs
    maMap.get(chaineCle);     // "valeur associée à 'une chaîne'"
    maMap.get(objetCle);      // "valeur associée à objetCle"
    maMap.get(fonctionCle);   // "valeur associée à fonctionCle"
    maMap.get("une chaîne");  // "valeur associée à 'une chaîne'"
                              // car chaineCle === 'une chaîne'

    Ex2:
    // Parcourir des objets Maps avec for..of
    var maMap = new Map();
    maMap.set(0, "zéro");
    maMap.set(1, "un");
    for (var [cle, valeur] of maMap) {
      console.log(cle + " = " + valeur);
    }
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"
    for (var cle of maMap.keys()) {
      console.log(cle);
    }
    // On aura 2 lignes : la première avec "0"
    // et la seconde avec "1"
    for (var valeur of maMap.values()) {
      console.log(valeur);
    }
    // On aura 2 lignes : la première avec "zéro"
    // et la seconde avec "un"
    for (var [cle, valeur] of maMap.entries()) {
      console.log(cle + " = " + valeur);
    }
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"
    maMap.forEach(function(valeur, cle) {
      console.log(cle + " = " + valeur);
    });
    // On aura 2 lignes : la première avec "0 = zéro"
    // la seconde avec "1 = un"

    Ex3:
    // Relation avec les objets Array
    var tableauCleValeur = [["cle1", "valeur1"], ["cle2", "valeur2"]];
    // On utilise le constructeur Map
    // pour transformer un tableau de cles/valeurs
    // en un objet map
    var maMap = new Map(tableauCleValeur);
    maMap.get("cle1"); // renvoie "valeur1"
    // On utilise la fonction Array.from pour transformer
    // une map en un tableau de cles/valeurs
    console.log(Array.from(maMap)); // affichera la même chose que tableauCleValeur
    // On peut aussi l'utiliser pour n'extraire que les cles
    // ou les valeurs et créer le tableau associé
    console.log(Array.from(maMap.keys())); // affichera ["cle1", "cle2"]

    Ex4:
    // Fusionner des objets Map
    var premier = new Map([
      [1, 'un'],
      [2, 'deux'],
      [3, 'trois'],
    ]);
    var second = new Map([
      [1, 'uno'],
      [2, 'dos']
    ]);
    // On fusionne les deux maps. C'est la "dernière" version
    // de la clé qui l'emporte.
    // L'opérateur de décomposition nous permet principalement ici
    // de convertir une map en un tableau
    var fusion = new Map([...premier, ...second]);
    console.log(fusion.get(1)); // uno
    console.log(fusion.get(2)); // dos
    console.log(fusion.get(3)); // trois

    // Fusionner des objets Map avec des objets Array
    var premier = new Map([
      [1, 'un'],
      [2, 'deux'],
      [3, 'trois'],
    ]);
    var second = new Map([
      [1, 'uno'],
      [2, 'dos']
    ]);
    // On peut fusionner des Maps avec un tableau 
    // Là encore c'est le dernier exemplaire de la clé qui l'emporte
    var fusion = new Map([...premier, ...second, [1, 'eins']]);
    console.log(fusion.get(1)); // eins
    console.log(fusion.get(2)); // dos
    console.log(fusion.get(3)); // trois


Object Property Value Shorthand
-------------------------------
1. If you want to define or set an object who's keys have the same name as the variables passed-in as properties, you can use the shorthand and simply pass the key name.
    Ex1:
    // Avant ES6
    var cat = 'Miaow';
    var dog = 'Woof';
    var bird = 'Peet peet';
    var someObject = {
      cat: cat,
      dog: dog,
      bird: bird
    }
    // ES6
    let cat = 'Miaow';
    let dog = 'Woof';
    let bird = 'Peet peet';
    let someObject = {
      cat,
      dog,
      bird
    }
    console.log(someObject);
    //{
    //  cat: "Miaow",
    //  dog: "Woof",
    //  bird: "Peet peet"
    //}

    Ex2:
    state = {
      text: sampleText
    };

    editText = (event) => {
      const text = event.target.value;
      this.setState({ text }); // au lieu de this.setState({ text: text});
    };


Boucles
-------------------------------
FOR...OF (ES6)
for (variable of iterable)
  instruction

    [variable]
      À chaque itération, la valeur d'une propriété différente est affectée à variable (cette variable peut être déclarée avec const, let ou var).
    [iterable]
      L'objet dont on parcourt les propriétés énumérables.
    [instruction]
      Une instruction à exécuter pour chaque propriété, cette instruction peut être composée de plusieurs instructions en utilisant un bloc d'instructions.

1. L'instruction for...of permet de créer une boucle Array qui parcourt un objet itérable 
(ce qui inclut les objets Array, Map, Set, String, TypedArray, l'objet arguments, etc.) et 
qui permet d'exécuter une ou plusieurs instructions pour la valeur de chaque propriété.

    Ex1:
    // Sur un tableau
    let tableauIterable = [1, 2, 3];
    for (let valeur of tableauIterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3

    Ex2:
    // Parcourir une chaîne de caractères
    let iterable = 'pixel';
    for (let valeur of iterable) {
      console.log(valeur);
    }
    // p
    // i
    // x
    // e
    // l

    Ex3:
    // Parcourir une Map
    let iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);
    for (let element of iterable) {
      console.log(element);
    }
    // ['a', 1]
    // ['b', 2]
    // ['c', 3]
    for (let [clef, valeur] of iterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3


FOR...IN
for (variable in objet) {...
}

    [variable]
      Un nom de propriété différent est assigné à la variable à chaque itération de la boucle.
    [objet]
      L'objet dont les propriétés énumérables et qui ne sont pas des symboles sont parcourues par la boucle.

1. L'instruction for...in permet d'itérer sur les propriétés énumérables d'un objet qui ne sont pas des symboles. 
Pour chaque propriété obtenue, on exécute une instruction (ou plusieurs grâce à un bloc d'instructions).
for...in ne doit pas être utilisée pour parcourir un Array lorsque l'ordre des éléments est important.

    Ex1:
    // Sur un objet
    var obj = {a:1, b:2, c:3};    
    for (var prop in obj) {
      console.log(`obj.${prop} = ${obj[prop]}`);
    }
    // Affiche dans la console :
    // "obj.a = 1"
    // "obj.b = 2"
    // "obj.c = 3"

    Ex2:
    // Parcourir une chaîne de caractères
    let iterable = 'pixel';
    for (let valeur of iterable) {
      console.log(valeur);
    }
    // p
    // i
    // x
    // e
    // l

    Ex3:
    // Parcourir une Map
    let iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);
    for (let element of iterable) {
      console.log(element);
    }
    // ['a', 1]
    // ['b', 2]
    // ['c', 3]
    for (let [clef, valeur] of iterable) {
      console.log(valeur);
    }
    // 1
    // 2
    // 3


LES DIFFÉRENCES ENTRE FOR...OF ET FOR...IN
1. Chaque objet héritera de la propriété objCustom et chaque objet qui est un tableau (Array) héritera de la propriété arrCustom car 
on les ajoute aux prototypes Object.prototype et Array.prototype. L'objet iterable hérite donc des propriétés objCustom et 
arrCustom grâce à l'héritage et à la chaîne de prototypes.
Cette boucle ne parcourt que les propriétés énumérables de l'objet iterable dans un ordre arbitraire. 
Les éléments du tableau 3, 5, 7 ou "coucou" ne sont pas affichés car ce ne sont pas des propriétés 
(et encore moins des propriétés énumérables). En revanche, on retrouve bien les indices du tableau et 
les propriétés arrCustom et objCustom. Pour décrire plus précisément ce comportement, vous pouvez consulter for...in.

    Ex1:
    Object.prototype.objCustom = function() {}; 
    Array.prototype.arrCustom = function() {};
    let iterable = [3, 5, 7];
    iterable.toto = 'coucou';
    for (let i in iterable) {
      console.log(i); // affiche 0, 1, 2, "toto",
                      // "arrCustom", "objCustom"
    }
    for (let i in iterable) {
      if (iterable.hasOwnProperty(i)) {
        console.log(i); // affiche 0, 1, 2, "toto"
      }
    }
    // Cette boucle parcourt les valeurs définies comme itérables par l'objet itérable et 
    // dans ce cas ce sont les éléments du tableau 3, 5, 7 et pas les propriétés de l'objet (ici toto et sa valeur "coucou")
    for (let i of iterable) {
      console.log(i); // affiche 3, 5, 7
    }

Fonctions sur les tableaux
-------------------------------
FOREACH()
// arr.forEach(callback);
// arr.forEach(callback, thisArg);
1. Permet d'exécuter une fonction donnée sur chaque élément du tableau.
    
    [callback] est appelé avec trois arguments :
      - la valeur de l'élément
      - l'index de l'élément
      - le tableau utilisé

    Ex1:
    var array1 = ['a', 'b', 'c'];
    array1.forEach(function(element) {
      console.log(element);
    });

    Ex2:
    let arr = [3, 5, 7];
    arr.toto = "coucou";
    arr.forEach(function (element, index) {
      console.log(element); // affiche "3", "5", "7"
      console.log(index);  // affiche "0", "1", "2"
    });


CONSOLE.TABLE()
// console.table(data [, columns]);
    [data]
      La donnée à afficher. Doit être un tableau ou un objet.
    [columns]
      Un tableau contenant les noms des colonnes à inclure dans la sortie.

    Ex1:
    // data peut contenir un tableau ou un objet.
    // un tableau de chaînes de caractères
    console.table(["apples", "oranges", "bananas"]);

    Ex2:
    // un objet dont les propriétés sont des chaînes de caractères
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var me = new Person("John", "Smith");
    console.table(me);

    Ex3:
    // un tableau de tableaux
    var people = [["John", "Smith"], ["Jane", "Doe"], ["Emily", "Jones"]]
    console.table(people);

    Ex4:
    // un tableau d'objets
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var john = new Person("John", "Smith");
    var jane = new Person("Jane", "Doe");
    var emily = new Person("Emily", "Jones");
    console.table([john, jane, emily]);

    Ex5:
    // un objet contenant des propriétés qui sont des objets
    var family = {};
    family.mother = new Person("Jane", "Smith");
    family.father = new Person("John", "Smith");
    family.daughter = new Person("Emily", "Smith");
    console.table(family);

    Ex6:
    // un tableau d'objets, affichant seulement firstName
    function Person(firstName, lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }
    var john = new Person("John", "Smith");
    var jane = new Person("Jane", "Doe");
    var emily = new Person("Emily", "Jones");
    console.table([john, jane, emily], ["firstName"]);


REDUCE()
// arr.reduce(callback) 
// arr.reduce(callback, valeurInitiale)
1. reduce() exécute la fonction callback une fois pour chaque élément présent dans le tableau et ignore les éléments vides du tableau. La fonction callback utilise quatre arguments. 
La première fois que la fonction callback est appelée, valeurInitiale et valeurCourante peuvent correspondre à un ou deux éléments. Si valeurInitiale est fournie dans l'appel de reduce(), 
alors accumulateur sera égale à valeurInitiale et valeurCourante sera égale à la première valeur de la liste. Si valeurInitiale n'est pas fournie, alors accumulateur sera égale à la première valeur de la liste, et valeurCourante sera alors égale à la seconde.
Autrement dit, si valeurInitiale n'est pas fournie, reduce exécutera la fonction de rappel à partir de l'indice 1 et la première valeur du tableau (d'indice 0) sera utilisée pour valeurInitiale.

    [callback]
      La fonction à exécuter sur chaque valeur de la liste (sauf le premier si aucune valeurInitiale n'est fournie), elle prend quatre arguments en entrée :
        [accumulateur]
          La valeur précédemment retournée par le dernier appel du callback, ou valeurInitiale, si elle est fournie (voir ci-après) (c'est la valeur « accumulée » au fur et à mesure des appels
        [valeurCourante]
          La valeur de l'élément courant actuellement manipulé dans le tableau.
        [index] (Facultatif)
          L'index de l'élément courant actuellement manipulé dans le tableau.
        [array] (Facultatif)
          Le tableau sur lequel on a appelé la méthode reduce().
    [valeurInitiale] (Facultatif)
      Une valeur utilisée comme premier argument lors du premier appel de la fonction callback. Si aucune valeur initiale n'est fournie, le premier élément du tableau est utilisé. Si on appelle reduce() sur un tableau vide sans fournir de valeur initiale, on aura une erreur.
    
    Ex1:
    // Sans fonction fléchée
    [0, 1, 2, 3, 4].reduce(function(accumulateur, valeurCourante, index, array){
      return accumulateur + valeurCourante;
    });
    // 10

    // Avec fonction fléchée
    [0, 1, 2, 3, 4].reduce((accumulateur, valeurCourante) => accumulateur + valeurCourante);
    // 10

    Ex2:
    // Avec valeurInitiale
    [0, 1, 2, 3, 4].reduce((accumulateur, valeurCourante) => accumulateur + valeurCourante, 10);
    // 20

MAP()
// let nouveauTableau = arr.map(callback [, thisArg])
1. La fonction callback fournie en argument est exécutée une fois pour chacun des éléments du tableau, dans l'ordre du tableau. 
Chaque résultat de l'opération sur un élément sera un élément du nouveau tableau. La fonction callback est appelée uniquement pour les indices du tableau 
pour lesquels il y a des valeurs affectées (y compris si cette valeur est undefined). Si les valeurs ont été supprimées ou qu'elles n'ont jamais été initialisées, la fonction ne sera pas appelée.
Si on utilise cette méthode sans utiliser le résultat, mieux vaudra utiliser forEach ou for...of. 

    [callback]
      La fonction qui est utilisée pour créer un élément du nouveau tableau. Elle utilise trois arguments
        [valeurCourante]
          La valeur de l'élément du tableau à traiter.
        [index]
          L'index de l'élément qui est traité par la fonction.
        [tableau] (Facultatif)
          Le tableau sur lequel on a appelé la méthode map.
    [thisArg] (Facultatif)
      La valeur à utiliser pour this lors de l'exécution de callback. La valeur par défaut est l'objet global de l'environnement (Window pour un navigateur).
    
    Ex1:
    // On crée un tableau composé des racines carrées des éléments d'un premier tableau
    var nombres = [1, 4, 9];
    var racines = nombres.map(Math.sqrt);
    // racines vaut désormais [1, 2, 3]
    // nombres vaut toujours [1, 4, 9]

    Ex2:
    // Créer un tableau de nombres avec une fonction à un argument. 
    // Cet argument sera automatiquement remplacé par chaque élément du tableau au fur et à mesure que map parcourt le tableau
    var nombres = [1, 4, 9];
    var doubles = nombres.map(function(num) {
      return num * 2;
    });
    // doubles vaut désormais [2, 8, 18].
    // nombres vaut toujours [1, 4, 9]

    Ex3:
    // On utilise un tableau d'objets pour créer un autre tableau contenant de nouveaux objets dans un autre format 
    var tableauOrig = [{cle:1, valeur:10}, {cle:2, valeur:20}, {cle:3, valeur: 30}];
    var tableauFormaté = tableauOrig.map(obj => { 
      var rObj = {};
      rObj[obj.cle] = obj.valeur; 
      return rObj;
    });
    // tableauFormaté vaut maintenant [{1:10}, {2:20}, {3:30}], 
    // tableauOrig vaut toujours 
    // [{cle:1, valeur:10},
    //  {cle:2, valeur:20},
    //  {cle:3, valeur: 30}
    // ]

    Ex4:
    // Utiliser map de façon générique sur autre chose qu'un tableau
    // Sur une chaine de caractère
    var map = Array.prototype.map;
    var a = map.call('Hello World', function(x) { return x.charCodeAt(0); });
    // a vaut désormais [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
    // Ici sur un tableau d'objets collectés grâce à querySelectorAll
    var elems = document.querySelectorAll('select option:checked');
    var values = Array.prototype.map.call(elems, function(obj) {
      return obj.value;
    });

    Ex5:
    // Utiliser map de façon générique sur autre chose qu'un tableau
    // Sur un tableau d'objets collectés grâce à querySelectorAll
    var elems = document.querySelectorAll('select option:checked');
    var values = Array.prototype.map.call(elems, function(obj) {
      return obj.value;
    });





Rest parameters
-------------------------------
1. Cette syntaxe permet de représenter un nombre indéfini d'arguments sous forme d'un tableau.
    Ex1:
    // ES6
    function sum(...theArgs) {
      return theArgs.reduce((previous, current) => {
        return previous + current;
      });
    }
    console.log(sum(1, 2, 3));
    // expected output: 6
    console.log(sum(1, 2, 3, 4));
    // expected output: 10

    Ex2:
    // S'il n'y a qu'un seul argument qui est décomposé par la syntaxe, la valeur sera toujours un tableau
    function maFonction(a, b, ...autres);
      console.log(a);
      console.log(b);
      console.log(autres);
    }
    maFonction("un", "deux", "trois");
    // affichera ceci dans la console
    // "un"
    // "deux"
    // ["trois"]
    maFonction("un", "deux", "trois", "quatre", "cinq");
    // affichera ceci dans la console :
    // "un"
    // "deux"
    // ["trois", "quatre", "cinq"]

    Ex3:
    // S'il n'y a pas suffisamment d'arguments, ce sera un tableau vide
    function maFonction(a, b, ...autres);
      console.log(a);
      console.log(b);
      console.log(autres);
    }
    maFonction("un", "deux");
    // affichera ceci dans la console
    // "un"
    // "deux"
    // []

    Ex4:
    // lesArguments est un tableau et dispose donc d'une propriété length permettant de compter ses éléments
    function fun1(...lesArguments) {
      console.log(lesArguments.length);
    }
    fun1();  // 0
    fun1(5); // 1
    fun1(5, 6, 7); // 3
