Créer un application react avec react-app
Ajouter Boostrap
Le state
Component Lifecycle
Component Lifecycle functions
Stateless Functional Component (Composant fonctionnel sans état)
Class Components
Stateful Class Components
PureComponent
Les Hook
useSate Hook
useEffect Hook
Custom Hook
useCallback Hook
useMemo Hook
Fragments
props.children (Composition)
import SVG
heroku (déploiement)
HOC
Les selectors
Composants de présentation et conteneurs
(Redux Sagas) take(), takeEvery(), takeLatest()
Gérer les erreurs dans les gestionnaires d’événements
Différences entre SSR (Server-Side Rendering) et CSR (Client-Side Rendering)
Rendu d'un array d'éléments HTML
Passer des props à un composant
Props de rendu
React.Children.only(children) Méthode
cloneElement() Méthode
Différence entre un state et une variable de classe
Affichage conditionnel




Créer un application react avec react-app
-------------------------------
    Ex1:
    npm init react-app my-app
    // my-app correspond au nom du repertoire qui va être créé pour les fichiers
    // de l'application, on choisi le nom que l'on veut

    Ex2:
    npm install -g npx // Si il n'est pas déjà installé
    npx create-react-app nom_du_projet // Créera un dossier nom_du_projet dans le dossier courant
    // Installation d'outils
    npm install redux react-redux // Pour installer redux
    npm install react-boostrap boostrap // Pour installer react-boostrap et boostrap
    npm install styled-components // Pour installer styled-components
    npm install polished // Pour installer polished


Ajouter Boostrap
-------------------------------
1. En mode CSS
    npm install --save bootstrap

    // Import Bootstrap CSS and optionally Bootstrap theme CSS in the beginning of your src/index.js file
    import 'bootstrap/dist/css/bootstrap.css';

    // Put any other imports below (en-dessous) so that CSS from your
    // components takes precedence over default styles.

2. En mode SASS
    npm install --save bootstrap
    npm install --save node-sass

    // Créer un fichier main.scss avec les imports scss
        //////////////////////////////////// EX:
        // Override default variables before the import
        $body-bg: #000;
        // Import Bootstrap and its default variables
        @import '~bootstrap/scss/bootstrap.scss';

    // Import the newly created .scss file instead of the default 
    // Bootstrap .css in the beginning of your src/index.js file
    import './main.scss';


Le state
-------------------------------
1. A chaque fois que le state d'un composant est modifié par sa référence ou ses valeurs,
le composant est rendu ainsi que tous ses composants enfants. 


Component Lifecycle
-------------------------------
1. Mounting
These methods are called in the following order when an instance of a component is being created and inserted into the DOM :
    constructor()
    static getDerivedStateFromProps()
    render()
    componentDidMount() (Remplace componentWillMount())

2. Updating
An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered :
    static getDerivedStateFromProps()
    shouldComponentUpdate()
    render()
    getSnapshotBeforeUpdate()
    componentDidUpdate()

3. Unmounting
This method is called when a component is being removed from the DOM :
    componentWillUnmount()

4. Error Handling
These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component :
    static getDerivedStateFromError()
    componentDidCatch()

5. Voir https://fr.reactjs.org/docs/react-component.html#static-getderivedstatefromprops


Component Lifecycle functions
-------------------------------
componentDidMount() 
est appelée immédiatement après que le composant est monté (inséré dans l’arbre). C’est ici que vous devriez placer les initialisations qui requièrent l’existence de nœuds du DOM. Si vous avez besoin de charger des données depuis un point d’accès distant, c’est aussi le bon endroit pour déclencher votre requête réseau.

componentDidUpdate() 
est appelée immédiatement après que la mise à jour a eu lieu. Cette méthode n’est pas appelée pour le rendu initial.


Stateless Functional Component (Composant fonctionnel sans état)
-------------------------------
1. Composant qui ne fait qu'afficher du contenu
    Ex1:
    // Sans props
    const NotFound = () => {
        return (
            <h2 className="notFound">Y'a rien ici!</h2>
        )
    }

    Ex2:
    // Avec props
    const HelloWorld = (props) => {
      return <p>Hello {props.user}</p>
    }
    // le passage de props à notre composant se fait de la façon suivante en JSX: <HelloWorld user='Gaël' />

    Ex3:
    const Hello = ({ name }) => (<div>Hello, {name}!</div>);

    Ex4:
    // Avec export
    import React from 'react';
    const NotFound = () => {
        return (
            <h2 className="notFound">Y'a rien ici!</h2>
        )
    }
    export default NotFound;


Class Components
-------------------------------
1. Un composant class étend la classe Component de React.
    Ex1:
    class Welcome extends React.Component {
      render() {
        return <h1>Bonjour, {this.props.name}</h1>;
      }
    }
    // le passage de props à notre composant se fait de la façon suivante en JSX: <Welcome name='Gaël' />


Stateful Class Components
-------------------------------
1. Un composant class étend la classe Component de React.
    Ex1:
    // [...]
    // JS PERSO
    import { sampleText } from './sampleText';

    class App extends React.Component {
        state = {
            text: sampleText
        };

        editText = (event) => {
            const text = event.target.value;
            this.setState({ text });
        };

        render() {
            return (
                <div className="container">
                    <div className="row">

                      <div className="col-sm-6">
                        <textarea value={this.state.text} rows="35" className="form-control" onChange={(e) => this.editText(e)} >
                        </textarea>
                      </div>

                      <div className="col-sm-6">
                        <div>{this.state.text}</div>
                        </div>

                    </div>
                </div>
            )
        }

    }

    render(
      <App />,
      document.getElementById('root')
    );


PureComponent
-------------------------------
1. React.PureComponent est similaire à React.Component. La seule différence est que React.Component 
n’implémente pas la méthode shouldComponentUpdate(), alors que React.PureComponent l’implémente en 
réalisant une comparaison de surface de l’état et des propriétés.

Si la fonction render() d’un de vos composants React produit un rendu identique pour le même état et 
les mêmes propriétés, le faire étendre React.PureComponent devrait améliorer les performances dans certains cas.

La méthode shouldComponentUpdate() de React.PureComponent réalise une simple comparaison de surface. 
Avec des données complexes, elle peut produire des faux négatifs si la structure de données subit des changements profonds. 
Ne créez des composants avec PureComponent que si vous avez des états et des props simples, 
et le cas échéant utilisez forceUpdate() si vous savez que vos données ont changé en profondeur. 
Vous pouvez aussi envisager d’utiliser des objets immuables pour simplifier la comparaison rapide de données imbriquées.

De plus, la méthode shouldComponentUpdate() de React.PureComponent ignore la mise à jour des propriétés 
de tout l’arbre des composants enfants. Assurez-vous donc que tous les composants enfants sont également « purs ».

  EX:
  // shouldComponentUpdate() est appelée avant le rendu 
  // quand de nouvelles props ou un nouvel état local sont reçues. 
  // Par défaut, elle renvoie true.
  shouldComponentUpdate(nextProps, nextState) {
    console.log('shouldComponentUpdate!', nextProps)
    // Le composant sera rendu une nouvelle fois si
    // Les props sont différentes donc renvoient false 
    return nextProps.text != this.props.text
  }

A shallow equality (comparaison de surface) check means that JS only checks that the value’s object ids 
(as in, the memory address for where JS stores the information for that particular object) are the same, not that their content is the same.

    Ex1:
    const value = 'cat';

    const item1 = value;
    const item2 = value;
    console.log(item1 === item2); // Retourne true

    const array1 = [value];
    const array2 = [value];
    console.log(array1 === array2); // Retourne false pourtant les deux tableaux sont identiques mais n'ont pas la même adresse mémoire (référence)


2. React.memo
React.memo est un composant d’ordre supérieur. Il joue le même rôle que
React.PureComponent, mais pour les composants créés à l’aide de fonctions
plutôt que de classes.

Si vous avez une fonction composant qui affiche toujours le même résultat
pour un même jeu de propriétés, vous pouvez l’enrober avec React.memo, ce 
qui mémoïsera le résultat et devrait augmenter les performances dans 
certains cas. Cela signifie que React sautera le rafraîchissement du 
composant en réutilisant son dernier rendu en date.

Par défaut, seule une comparaison de surface des props et des objets de props sera faite. Si vous
voulez gérer cette comparaison vous-même, vous pouvez fournir une fonction
de comparaison personnalisée en deuxième argument.

  EX:
  function MyComponent(props) {
    /* Faire le rendu en utilisant les props */
  }
  function areEqual(prevProps, nextProps) {
    /*
    Renvoie `true` si passer l'objet nextProps à la fonction de rendu
    produira le même résultat que de lui passer l'objet prevProps.
    Renvoie `false` dans le cas contraire.
    */
  }
  export default React.memo(MyComponent, areEqual);

  EX:
  export function Movie({ title, releaseDate }) {
    return (
      <div>
        <div>Movie title: {title}</div>
        <div>Release date: {releaseDate}</div>
      </div>
    );
  }

  function moviePropsAreEqual(prevMovie, nextMovie) {
    return prevMovie.title === nextMovie.title
      && prevMovie.releaseDate === nextMovie.releaseDate;
  }
  export const MemoizedMovie = React.memo(Movie);


  // First render. React calls MemoizedMovie function.
  <MemoizedMovie 
    title="Heat" 
    releaseDate="December 15, 1995" 
  />

  // On next round React does not call MemoizedMovie function,
  // preventing rendering
  <MemoizedMovie
    title="Heat" 
    releaseDate="December 15, 1995" 
  />


Les Hook
-------------------------------
Un Hook est une fonction qui permet de « se brancher » sur des fonctionnalités React. 
Par exemple, useState est un Hook qui permet d’ajouter l’état local React à des fonctions composants.

Auparavant, si vous écriviez une fonction composant et que vous réalisiez que vous aviez besoin d’un état local à l’intérieur, 
vous deviez la convertir en classe. Désormais vous pouvez utiliser un Hook à l’intérieur de votre fonction composant.

Appelez les Hooks uniquement au niveau racine. N’appelez pas de Hooks à l’intérieur de boucles, de code conditionnel ou de fonctions imbriquées.

Appelez les Hooks uniquement depuis des fonctions composants React. N’appelez pas les Hooks depuis des fonctions JavaScript classiques. 
(Il n’y a qu’un seul autre endroit où vous pouvez appeler des Hooks : vos propres Hook personnalisés.


useSate Hook
-------------------------------
Le seul argument à passer au Hook useState() est l’état initial. Contrairement à ce qui se passe dans les classes, 
l’état local n’est pas obligatoirement un objet. Il peut s’agir d’un nombre ou d’une chaîne de caractères si ça nous suffit.

useState renvoie une paire de valeurs : l’état actuel et une fonction pour le modifier.

1. Déclaration et utilisation.

    EX:
    /*
    Cette syntaxe Javascript est appelée « déstructuration positionnelle ». 
    Ça signifie que nous créons deux nouvelles variables fruit et setFruit, avec fruit qui reçoit 
    la première valeur renvoyée par useState, et setFruit qui reçoit la deuxième. 
    */
    const [fruit, setFruit] = useState('banane');

    // C’est équivalent au code ci-dessous
    var fruitStateVariable = useState('banana'); // Renvoie une paire
    var fruit = fruitStateVariable[0]; // Premier élément dans une paire
    var setFruit = fruitStateVariable[1]; // Deuxième élément dans une paire

    EX:
    import React, { useState } from 'react';
  
    function Example() {
      const [count, setCount] = useState(0);
  
      return (
        <div>
          <p>Vous avez cliqué {count} fois</p>
          <button onClick={() => setCount(count + 1)}>
           Cliquez ici
          </button>
        </div>
      );
    }

    EX:
    import React, { useState } from 'react';

    import Card from '../card/card.component';

    // Avec les Hooks
    const UseStateExample = () => {
      const [name, setName] = useState('Yihua');
      const [address, setAddress] = useState('Amsterdam');

      return (
        <Card>
          <h1> {name} </h1>
          <h1> {address} </h1>
          <button onClick={() => setName('Andrei')}>Set Name to Andrei</button>
          <button onClick={() => setAddress('Canada')}>Set Address</button>
        </Card>
      );
    };

    // Avec une Class
    export class StateClassComponent extends React.Component {
      constructor() {
        super();

        this.state = {
          name: 'Yihua',
          address: 'Canada'
        };
      }

      render() {
        return (
          <Card>
            <h1> {this.state.name} </h1>
            <button onClick={this.setState({ name: 'Andrei' })}>
              Set Name to Andrei
            </button>
            <button onClick={this.setState({ address: 'Amsterdam' })}>
              Set Address
            </button>
          </Card>
        );
      }
    }

    export default UseStateExample;


2. Dois-je utiliser une ou plusieurs variables d’état local ?

    Ex1:
    // On pourra faire comme ceci
    function Box() {
      const [state, setState] = useState({ left: 0, top: 0, width: 100, height: 100 });    
      // ...
      useEffect(() => {
        function handleWindowMouseMove(e) {
          // La décomposition de "...state" permet de s’assurer qu’on ne « perd » pas width et height
          setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
        }
        // Remarque : cette implémentation est un peu simplifiée
        window.addEventListener('mousemove', handleWindowMouseMove);
        return () => window.removeEventListener('mousemove', handleWindowMouseMove);
      }, []);
      // ...
    }

    // Mais il est préférable de séparer les variables d'états indépendantes comme cela
    function Box() {
      const [position, setPosition] = useState({ left: 0, top: 0 });
      const [size, setSize] = useState({ width: 100, height: 100 });

      useEffect(() => {
        function handleWindowMouseMove(e) {
          setPosition({ left: e.pageX, top: e.pageY });
        }
        // ...
  

useEffect Hook
-------------------------------
1. useEffect peut être utilisé comme à une combinaison de componentDidMount, componentDidUpdate, et componentWillUnmount.

  EX:
  import React, { useState, useEffect } from 'react';

  import Card from '../card/card.component';

  const UseEffectExample = () => {
    const [user, setUser] = useState(null);
    const [searchQuery, setSearchQuery] = useState('Bret');

    useEffect(() => {
      const fetchFunc = async () => {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/users?username=${searchQuery}`
        );
        const resJson = await response.json();
        setUser(resJson[0]);
      };

      fetchFunc();
    }, [searchQuery]);

    return (
      <Card>
        <input
          type='search'
          value={searchQuery}
          onChange={event => setSearchQuery(event.target.value)}
        />
        {user ? (
          <div>
            <h3>{user.name}</h3>
            <h3> {user.username} </h3>
            <h3> {user.email} </h3>
          </div>
        ) : (
          <p>No user found</p>
        )}
      </Card>
    );
  };

  export default UseEffectExample;

2. Le fait d’appeler useEffect à l’intérieur de notre composant nous permet d’accéder aux variables d’états count (ou à n’importe quelle prop) directement depuis l’effet.

3. useEffect est exécutée par défaut après le premier affichage et après chaque mise à jour. Au lieu de penser en termes de « montage » et de « démontage », 
pensez plutôt que les effets arrivent tout simplement « après l’affichage ». React garantit que le DOM a été mis à jour avant chaque exécution des effets.

  EX:
  // Ce Hook pour indiquer à React que notre composant doit exécuter quelque chose après chaque affichage. 
  // React enregistre la fonction passée en argument (que nous appellerons « effet »), et l’appellera plus tard, 
  // après avoir mis à jour le DOM.
  import React, { useState, useEffect } from 'react';

  function Example() {
    const [count, setCount] = useState(0);

    useEffect(() => {
      document.title = `Vous avez cliqué ${count} fois`;
    });

    return (
      <div>
        <p>Vous avez cliqué {count} fois</p>
        <button onClick={() => setCount(count + 1)}>
          Cliquez ici
        </button>
      </div>
    );
  }

4. Effets avec nettoyage.
Nous pourrions souhaiter nous abonner à une source de données externe. Dans ce cas-là, il est impératif de nettoyer par la suite pour éviter les fuites de mémoire !
Dans une classe React, on s’abonne généralement dans componentDidMount, et on se désabonne dans componentWillUnmount.
React effectue le nettoyage lorsqu’il démonte le composant. Cependant, comme nous l’avons appris précédemment, 
les effets sont exécutés à chaque affichage, donc potentiellement plus d’une fois. C’est la raison pour laquelle 
React nettoie aussi les effets du rendu précédent avant de les exécuter une nouvelle fois.

  EX:
  // Avec une Class
  class FriendStatus extends React.Component {
    constructor(props) {
      super(props);
      this.state = { isOnline: null };
      this.handleStatusChange = this.handleStatusChange.bind(this);
    }

    componentDidMount() {
      ChatAPI.subscribeToFriendStatus(
        this.props.friend.id,
        this.handleStatusChange
      );
    }

    componentWillUnmount() {
      ChatAPI.unsubscribeFromFriendStatus(
        this.props.friend.id,
        this.handleStatusChange
      );
    }

    handleStatusChange(status) {
      this.setState({
        isOnline: status.isOnline
      });
    }

    render() {
      if (this.state.isOnline === null) {
        return 'Chargement...';
      }
      return this.state.isOnline ? 'En ligne' : 'Hors-ligne';
    }
  }

  // Avec un Hook
  import React, { useState, useEffect } from 'react';

  function FriendStatus(props) {
    const [isOnline, setIsOnline] = useState(null);

    useEffect(() => {
      function handleStatusChange(status) {
        setIsOnline(status.isOnline);
      }

      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
      // Indique comment nettoyer l'effet :
      return function cleanup() {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
      };
    });

    if (isOnline === null) {
      return 'Chargement...';
    }
    return isOnline ? 'En ligne' : 'Hors-ligne';
  }

5. Optimiser les performances en sautant des effets.
Dans certains cas, exécuter ou nettoyer l’effet après chaque affichage risque de nuire aux performances. Dans les composants à base de classe, 
une solution consiste à comparer prevProps ou prevState dans componentDidUpdate.

  EX:
  componentDidUpdate(prevProps, prevState) {
    if (prevState.count !== this.state.count) {
      document.title = `Vous avez cliqué ${this.state.count} fois`;
    }
  }

Ce genre de comportement est tellement courant qu’il est intégré dans l’API du Hook useEffect. 
Il est possible d’indiquer à React de sauter l’exécution d’un effet si certaines valeurs n’ont pas été modifiées entre deux affichages. 
Pour cela, il suffit de passer une liste comme second argument optionnel à useEffect.

  EX:
  useEffect(() => {
    document.title = `Vous avez cliqué ${count} fois`;
  }, [count]); // N’exécute l’effet que si count a changé

Dans le cas où la liste contiendrait plusieurs éléments, React ré-appliquera l’effet si au moins l’un d’entre eux est différent de sa version précédente.
Le fonctionnement est le même pour la phase de nettoyage.
  
  EX:
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  }, [props.friend.id]); // Ne se ré-abonne que si props.friend.id change

Si vous utilisez cette optimisation, assurez-vous que votre tableau inclut bien toutes les valeurs 
dans la portée du composant (telles que les props et l’état local) qui peuvent changer avec le temps et sont utilisées par l’effet.

Il est généralement préférable de déclarer les fonctions dont votre effet a besoin à l’intérieur de celui-ci. 
Il devient alors facile de voir de quelles valeurs de la portée du composant dépend cet effet.

  EX:
  function Example({ someProp }) {
    useEffect(() => {
      function doSomething() {
        console.log(someProp);
      }

      doSomething();
    }, [someProp]); // OK (notre effet n’utilise que `someProp`)
  }

  EX:
  function ProductPage({ productId }) {
    const [product, setProduct] = useState(null);

    useEffect(() => {
      // En déplaçant cette fonction dans l'effet, on voit clairement quelles valeurs il utilise.
      async function fetchProduct() {
        const response = await fetch('http://myapi/product' + productId);
        const json = await response.json();
        setProduct(json);
      }

      fetchProduct();
    }, [productId]); // Correct car notre effet n’utilise que `productId`
    // ...
  }

6. Exécuter l'effet une seule fois.
Si vous voulez exécuter un effet et le nettoyer une seule fois (au montage puis au démontage), vous pouvez passer un tableau vide ([]) comme second argument. 
Ça indique à React que votre effet ne dépend d’aucune valeur issue des props ou de l’état local, donc il n’a jamais besoin d’être ré-exécuté.
Autrement dit l'effet ne watch aucune valeur, donc il n'a pas de raison de réagir à un changement.
Il ne s’agit pas d’un cas particulier : ça découle directement de la façon dont le tableau des dépendances fonctionne à la base.
Si vous passez un tableau vide ([]), les props et l’état local vus depuis l’intérieur de l’effet feront toujours référence à leurs valeurs initiales. 
Même si passer [] comme second argument vous rapproche du modèle mental habituel de componentDidMount et componentWillUnmount.

  EX:
  useEffect(() => {
    function doSomething() {
      console.log('bonjour');
    }

    doSomething();
  }, []); // OK dans ce cas précis car nous n’utilisons *aucune* valeur de la portée du composant


Custom Hook
-------------------------------
1. Traditionnellement en React, nous avions deux manières répandues de partager une logique d’état 
entre des composants : les props de rendu et les composants d’ordre supérieur. Nous allons voir comment 
les Hooks règlent la majeure partie de ces problèmes sans vous obliger à ajouter des composants dans l’arbre.

2. Lorsque nous souhaitons partager de la logique entre deux fonctions JavaScript, nous l’extrayons dans une troisième fonction. 
Les composants et les Hooks sont des fonctions, ça fonctionne donc aussi pour eux !
Un Hook personnalisé est une fonction JavaScript dont le nom commence par ”use” et qui peut appeler d’autres Hooks.

3. Comme lorsque vous êtes dans un composant, assurez-vous d’appeler les autres Hooks de façon inconditionnelle et au niveau racine de votre Hook personnalisé.

4. Contrairement à un composant React, un Hook personnalisé n’a pas besoin d’avoir une signature particulière. 
Nous pouvons décider s’il a besoin d’accepter des arguments et ce qu’il doit éventuellement renvoyer. 
En d’autres termes, c’est une simple fonction. Son nom doit toujours commencer par use pour qu’au premier 
coup d’œil vous sachiez que les règles des Hooks lui sont applicables.

  EX:
  // Imaginons deux commposants qui qui affichent un message selon qu’un ami est en ligne ou hors-ligne.
  // Composant 1 
  import React, { useState, useEffect } from 'react';

  function FriendStatus(props) {
    const [isOnline, setIsOnline] = useState(null);

    useEffect(() => {
      function handleStatusChange(status) {
        setIsOnline(status.isOnline);
      }

      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
      };
    });

    if (isOnline === null) {
      return 'Chargement...';
    }
    return isOnline ? 'En ligne' : 'Hors-ligne';
  }

  // Composant 2 
  import React, { useState, useEffect } from 'react';

  function FriendListItem(props) {
    const [isOnline, setIsOnline] = useState(null);

    useEffect(() => {
      function handleStatusChange(status) {
        setIsOnline(status.isOnline);
      }

      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
      };
    });

    return (
      <li style={{ color: isOnline ? 'green' : 'black' }}>
        {props.friend.name}
      </li>
    );
  }

Nous aimerions partager la logique dupliquée entre FriendStatus et FriendListItem. Nous allons donc créer
un hook personnalisé useFriendStatus.
L’objectif de notre Hook useFriendStatus est de nous abonner au statut d’un ami. 
C’est pourquoi il prend friendID comme argument et nous renvoie si notre ami est en ligne. 

  EX:
  import React, { useState, useEffect } from 'react';

  function useFriendStatus(friendID) {
    const [isOnline, setIsOnline] = useState(null);

    useEffect(() => {
      function handleStatusChange(status) {
        setIsOnline(status.isOnline);
      }

      ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
      };
    });

    return isOnline;
  }

À la base, notre but était de supprimer la logique dupliquée entre les composants FriendStatus et FriendListItem. 
Les deux veulent savoir si un ami est en ligne. Maintenant que nous avons extrait cette logique dans un hook useFriendStatus, 
nous pouvons simplement l’utiliser dans nos deux composants.

  EX:
  // Composant 1 
  function FriendStatus(props) {
    const isOnline = useFriendStatus(props.friend.id);

    if (isOnline === null) {
      return 'Chargement...';
    }
    return isOnline ? 'En ligne' : 'Hors-ligne';
  }

  // Composant 2
  function FriendListItem(props) {
    const isOnline = useFriendStatus(props.friend.id);

    return (
      <li style={{ color: isOnline ? 'green' : 'black' }}>
        {props.friend.name}
      </li>
    );
  } 

5. Chaque appel à un Hook se voit attribuer un état isolé. Comme nous appelons useFriendStatus directement, 
du point de vue de React notre composant appelle simplement useState et useEffect. 
Et comme nous l’avons appris précédemment, nous pouvons appeler useState et useEffect plusieurs fois dans un composant et ils seront complètement indépendants.

  EX:
  // Nous pouvons ainsi savoir si l’ami actuellement sélectionné est en ligne. 
  // Si nous sélectionnons un autre ami et mettons à jour la variable d’état recipientID, 
  // notre Hook useFriendStatus va se désabonner de l’ami précédemment sélectionné et s’abonner au statut de son remplaçant.

  const friendList = [
    { id: 1, name: 'Phoebe' },
    { id: 2, name: 'Rachel' },
    { id: 3, name: 'Ross' },
  ];

  function ChatRecipientPicker() {
    const [recipientID, setRecipientID] = useState(1);
    const isRecipientOnline = useFriendStatus(recipientID);

    return (
      <>
        {/*
        Le cercle s'affiche en vert ou en rouge selon l'ami selectionné dans la drop-down list
        */}
        <Circle color={isRecipientOnline ? 'green' : 'red'} />
        <select
          value={recipientID}
          /*
          Permet de passer l'ID de l'ami au hook useFriendStatus pour qu'il nous renvoie son statut
          */
          onChange={e => setRecipientID(Number(e.target.value))}
        >
          {friendList.map(friend => (
            <option key={friend.id} value={friend.id}>
              {friend.name}
            </option>
          ))}
        </select>
      </>
    );
  }


useCallback Hook
-------------------------------
1. Prend en arguments une fonction et un tableau de dépendances des
variables utilisées par la fonction.

2. useCallback renverra une version mémoïsée de la fonction qui changera uniquement si une des dépendance a changé.
chaque valeur référencée dans la fonction de rappel devrait aussi apparaître dans le tableau d’entrées.

3. useCallback(fn, inputs) est équivalent à useMemo(() => fn, inputs)

  EX:
  import React, { useState, useCallback } from 'react';
  import logo from './logo.svg';
  import './App.css';

  const App = () => {
    const [count1, setCount1] = useState(0);
    const [count2, setCount2] = useState(0);

    // La fonction est mémoïsée et ne sera réinstancié que si count1 change
    const incrementCount1 = useCallback(() => setCount1(count1 + 1), [count1]);
    const incrementCount2 = useCallback(() => setCount2(count2 + 1), [count2]);


    return (
      <div className='App'>
        <header className='App-header'>
          <img src={logo} className='App-logo' alt='logo' />
          Count1: {count1}
          <button onClick={incrementCount1}>Increase Count1</button>
          Count2: {count2}
          <button onClick={incrementCount2}>Increase Count2</button>
        </header>
      </div>
    );
  };

  export default App;


useMemo Hook
-------------------------------
1. Prend en arguments une fonction et un tableau de dépendances des
variables utilisées par la fonction.

2. useMemo eenvoie une valeur mémoïsée et recalculera la valeur mémoïsée seulement si une des entrées a changé. 
Cette optimisation permet d’éviter des calculs coûteux à chaque rendu.

EX:
import React, { useState, useCallback, useMemo } from 'react';
import logo from './logo.svg';
import './App.css';

const App = () => {
  const [count1, setCount1] = useState(0);
  const [count2, setCount2] = useState(0);

  const incrementCount1 = useCallback(() => setCount1(count1 + 1), [count1]);
  const incrementCount2 = useCallback(() => setCount2(count2 + 1), [count2]);

  // La valeur retournée par la fonction est mémoïsée et ne sera recalculer
  // que si count1 change
  const doSomethingComplicated = useMemo(() => {
    console.log('I am computing something complex');
    return ((count1 * 1000) % 12.4) * 51000 - 4000;
  }, [count1]);

  return (
    <div className='App'>
      <header className='App-header'>
        <img src={logo} className='App-logo' alt='logo' />
        Count1: {count1}
        <button onClick={incrementCount1}>Increase Count1</button>
        Count2: {count2}
        <button onClick={incrementCount2}>Increase Count2</button>
        complexValue: {doSomethingComplicated}
      </header>
    </div>
  );
};

export default App;

Fragments
-------------------------------
1. En React, il est courant pour un composant de renvoyer plusieurs éléments. 
Les fragments nous permettent de grouper une liste d’enfants sans ajouter de nœud supplémentaire au DOM.

  EX:
  class Table extends React.Component {
    render() {
      return (
        <table>
          <tr>
            <Columns />
          </tr>
        </table>
      );
    }
  }

  // Le composant Columns sans <React.Fragment>
  class Columns extends React.Component {
    render() {
      return (
        <div>
          <td>Bonjour</td>
          <td>Monde</td>
        </div>
      );
    }
  }

  // Ce code donne en sortie le <Table /> invalide suivant avec une div dans les tr :

  <table>
    <tr>
      <div>
        <td>Bonjour</td>
        <td>Monde</td>
      </div>
    </tr>
  </table>

  // Le composant Columns avec <React.Fragment>
  class Columns extends React.Component {
    render() {
      return (
        <React.Fragment>
          <td>Bonjour</td>
          <td>Monde</td>
        </React.Fragment>
      );
    }
  }

  // Ce qui donne en sortie le <Table /> correct suivant :

  <table>
    <tr>
      <td>Hello</td>
      <td>World</td>
    </tr>
  </table>

  // Il existe une nouvelle syntaxe plus concise, que vous pouvez utiliser pour déclarer des fragments. Ça ressemble à des balises vides :

  class Columns extends React.Component {
    render() {
      return (
        <>
          <td>Bonjour</td>
          <td>Monde</td>
        </>
      );
    }
  }


props.children (Composition)
-------------------------------
1.  this.props.children or props.children does is that it is used to display whatever you include between the opening and closing tags when invoking a component.

    Ex1:
    const Picture = (props) => {
      return (
        <div>
          <img src={props.src}/>
          {props.children}
        </div>
      )
    }

    //App.js
    render () {
      return (
        <div className='container'>
          <Picture key={picture.id} src={picture.src}>
              //what is placed here is passed as props.children  
          </Picture>
        </div>
      )
    }

    Ex2:
    function FancyBorder(props) {
      return (
        <div className={'FancyBorder FancyBorder-' + props.color}>
          {props.children}
        </div>
      );
    }

    //Autre composant
    function WelcomeDialog() {
      return (
        <FancyBorder color="blue">
          <h1 className="Dialog-title">
            Bienvenue
          </h1>
          <p className="Dialog-message">
            Merci de visiter notre vaisseau spatial !
          </p>
        </FancyBorder>
      );
    }

    //Sortie du composant FancyBorder
    <div className={'FancyBorder FancyBorder-' + props.color}>
      <h1 className="Dialog-title">
        Bienvenue
      </h1>
      <p className="Dialog-message">
        Merci de visiter notre vaisseau spatial !
      </p>
    </div>

2. Bien que cela soit moins courant, vous aurez parfois besoin de plusieurs « trous » dans un composant. Dans ces cas-là, vous pouvez créer votre propre convention au lieu d’utiliser children.

    Ex1:
    function SplitPane(props) {
      return (
        <div className="SplitPane">
          <div className="SplitPane-left">
            {props.left}
          </div>
          <div className="SplitPane-right">
            {props.right}
          </div>
        </div>
      );
    }

    function App() {
      return (
        <SplitPane
          left={
            <Contacts />
          }
          right={
            <Chat />
          } />
      );
    }

    // Des éléments React tels que <Contacts /> et <Chat /> sont simplement des objets, 
    // vous pouvez les passer comme props au même titre que n’importe quelle autre donnée. 
    // Cette approche peut vous rappeler la notion de “slots” présente dans d’autres bibliothèques, 
    // mais il n’y a aucune limitation à ce que vous pouvez passer en props avec React.


import SVG
-------------------------------
1. Import d'un SVG sous forme d'un composant

    ex1:
    // Permet d'importer le svg directement sous la forme d'un composant react
    import { ReactComponent as ShoppingIcon } from '../../assets/shopping-bag.svg'

    // On l'utilise comme un composant
    const CartIcon = () => (
        <div className='cart-icon'
            <ShoppingIcon />
            <span> 0 </span>
        <div>
    ))


heroku (déploiement)
-------------------------------
1. Installer Heroku CLI pour Windows 64x
2. npm install -g heroku 
3. Vérifier l'installation 
    heroku --version
4. Se connecter à heroku
    heroku login
5. Cliquer sur Log in dans le navigateur qui s'ouvre
6. Configurer l'hébergement de l'application
    heroku create crwn-live75 --buildpack https://github.com/mars/create-react-app-buildpack.git
7. Pusher l'application sur la branche distante heroku depuis la branche master
     git push heroku master


HOC
-------------------------------
1. Un High Order Component est une fonction qui prend en paramètre un composant et d'autres paramètres 
si besoin et retourne ce même composant mais avec des props en plus ou un affichage conditionnel comme un loading par exemple.

2. On appelle un fichier js HOC souvent par with- suivi du nom qui décrit le HOC comme with-data.js ou with-spinner.js par exemple.

  EX:
  //// App.js ////
  ////////////////////////////
  import React from 'react';

  import UserProfile from './components/user-profile/user-profile.component';
  import UserList from './components/user-list/user-list.component';

  import './App.scss';

  function App() {
    return (
      <div className='App'>
        {/*
        La props dataSource est utilisée par le HOC pour fetch les datas
        et les transmettre au composant
        */} 
        <UserList dataSource='https://jsonplaceholder.typicode.com/users' />
        <UserProfile
          name='Yihua'
          email='yihuazhang@gmail.com'
          dataSource='https://jsonplaceholder.typicode.com/posts'
        />
      </div>
    );
  }
  export default App;



  //// with-data.js ////
  ////////////////////////////
  import React from 'react';

  // On prend le composant WrappedComponent en paramètre
  // On retourne un composant qui va fetch des données selon
  // une dataSource que l'on lui passe en props.
  const withData = WrappedComponent => {
    class WithData extends React.Component {
      constructor(props) {
        super(props);

        this.state = {
          data: []
        };
      }

      componentDidMount() {
        setTimeout(() => {
          fetch(this.props.dataSource)
            .then(response => response.json())
            .then(data => this.setState({ data: data.slice(0, 3) }));
        }, 1500);
      }

      render() {
        const { dataSource, ...otherProps } = this.props;

        // On affiche un loading tant que le tableau data du state est vide
        return this.state.data.length < 1 ? (
          <h1>LOADING</h1>
        ) : (
        {/*
        Sinon on affiche le composant entouré auquel on passe la props data
        ...otherProps représente les props du composant entouré
        */} 
          <WrappedComponent data={this.state.data} {...otherProps} />
        );
      }
    }

    return WithData;
  };
  export default withData;



  //// user-list.component.jsx ////
  ////////////////////////////
  import React from 'react';

  // On importe le HOC
  import withData from '../../with-data';

  // Grâce au HOC on accède aux data
  const UserList = ({ data }) => (
    <div className='container user-list'>
      <h1> Users List </h1>
      {data.map(user => (
        <div className='post' key={user.id}>
          <h1> {user.name} </h1>
          <h2> {user.email} </h2>
        </div>
      ))}
    </div>
  );
  // On passe notre composant en argument au HOC
  export default withData(UserList);



  //// user-profile.component.jsx ////
  ////////////////////////////
  import React from 'react';

  // On importe le HOC
  import withData from '../../with-data';

  // Grâce au HOC on accède aux data
  const UserProfile = ({ data, name, email }) => (
    <div className='container'>
      <h1>{name}</h1>
      <h2>{email}</h2>
      Posts:
      {data.map(post => (
        <div className='post' key={post.id}>
          <h1>{post.title}</h1>
          <p> {post.body} </p>
        </div>
      ))}
    </div>
  );
  // On passe notre composant en argument au HOC
  export default withData(UserProfile);


Les selectors
-------------------------------
1. Un selector est tout simplement une fonction qui prend en paramètre tout ou partie du state de l’application et 
en renvoie une version formatée et/ou réduite, propice aux besoins de nos vues.

  EX:
  // Selector simple qui renvoie une partie du state
  const getToDoList = state => state.toDoList;

  // Le selector est importé par les composants Container ayant besoin de la donnée formatée.
  ... 
  import { getToDoList } from '../reducers'; 

  ... 
  const mapStateToProps = (state) => {
    return {
      toDoList: getToDoList(state)
    }
  };

2. Combiner les selectors.
Au même titre que n’importe quelle fonction, un sélecteur doit être simple, pur et responsable d’une seule opération. 
Il devient alors possible d’imaginer des combinaisons de sélecteurs afin d’obtenir le modèle souhaité.
  EX:
  const getToDoList = state => state.toDoList;
  const getDone = state => state.reduce(element => element.done);
  const getDoneTodos = state => getDone(getToDoList(state)); 

3. Un selector est donc :
- une fonction prenant en paramètre au moins le state de l’application
- une fonction renvoyant un modèle spécifique à un besoin
- situé dans le même fichier que le reducer correspondant
- combinable avec d’autres selectors
- un moyen d’accéder à des sous-parties du state de l’application
- un moyen de reformater des parties du state à la volée pour les vues
- un moyen de conserver un state global simple et sans répétition

4. La librairie Reselect vous permet notamment de combiner des sélecteurs très simplement ou d’utiliser 
la memoization pour éviter de recalculer les résultats d’un sélecteur à chaque appel.


Composants de présentation et conteneurs
-------------------------------
1. Composants de présentation :
- s’intéressent à quoi les choses ressemblent,
- peuvent contenir à la fois des composants de présentation et des conteneurs et, 
  généralement, possèdent des balises DOM et des styles qui leur sont propres,
- offrent souvent de l’intégration via this.props.children,
- sont indépendants du reste de l’application comme les actions redux ou le stockage,
- ne spécifient pas comment les données sont chargées ou modifiées,
- reçoivent des données et des fonction de rappel exclusivement par props,
- ont rarement leur propre état (quand c’est le cas, il s’agit d’un état d’interface plutôt que de données),
- sont écrits en tant que composants fonctionnels à moins qu’ils ne nécessitent un état, des actions lors d’un cycle de vie ou des optimisations de performances.
- Exemples : Page, Sidebar, Story, UserInfo, List

2. Composants conteneurs :
- se préoccupent de comment les choses fonctionnent,
- peuvent contenir à la fois des composants de présentations et conteneurs** mais ne possèdent généralement pas 
  de balises DOM propres à l’exception des balises div qui les entourent, et ils  n’ont jamais de styles,
- fournissent les données et le comportement aux composants de présentation ou aux autres composants de contenu,
- appellent des actions Flux et les fournissent aux composants idiots en tant que callbacks,
- sont souvent d’état car ils tendent à servir de source de données,
- sont habituellement générés en utilisant des composants de plus haut niveau comme connect() de React Redux, createContainer() 
  de Relay ou Container.create() de Flux Utils plutôt qu’écrits à la main.
- Exemples : UserPage, FollowersSidebar, StoryContainer, FollowedUserList


(Redux Sagas) take(), takeEvery(), takeLatest(), delay()
-------------------------------
1. take() reçoit une action dispatchée et exécute le code
de sa fonction generator un seule fois, si la même action est
dispatchée une seconde fois rien ne se passera car le generator
aura été done la première fois.

  EX:
  import { take } from 'redux-saga/effects';  

  export function* incrementSaga() {
    yield take('INCREMENT');
    console.log('I am incremented')
  }


take() peut retourner le payload de l'action.

  EX:
  import { take } from 'redux-saga/effects';  

  export function* incrementSaga() {
    const incrementPayload = yield take('INCREMENT');
    console.log(incrementPayload)
  }

Pour que take() puisse répondre à chaque action reçue plutôt
qu'une seule fois à la première action, on peut
utiliser une boucle while

  EX:
  import { take } from 'redux-saga/effects';  

  export function* incrementSaga() {
    while(true) {
      yield take('INCREMENT');
      console.log('I am incremented')
    }    
  }

On peut utiliser delay() comme setTimeOut pour bloquer 
le script pendant un certain temps en millisecondes pour
simuler un appel asynchrone par exemple.

Dans le script ci-dessous l'exécution de la boucle va être
bloqué pendant 5s et les actions INCREMENT qui arriveront
pendant ce temps ne seront pas prise en compte par take
et 'I am incremented' ne s'affichera pas.

  EX:
  import { take, delay } from 'redux-saga/effects';  

  export function* incrementSaga() {
    while(true) {
      yield take('INCREMENT');
      console.log('I am incremented')
      yield delay(5000)
    }    
  }


2. takeEvery() reçoit une action dispatchée et appelle une autre
fonction generator qui va exécuter le code souhaité à chaque
fois que l'action est dispatchée mais si le code exécuté est asynchrone,
car à chaque action il génère une nouvelle fonction generator
indépendante qui va exécuter son code.
'I am incremented' sera affiché à chaque action même si il y a
un delay de 3s juste après. Et 3s après chaque action une action
INCREMENT_FROM_SAGA sera dispatchée grâce à put()


  EX:
  import { takeEvery, delay, put } from 'redux-saga/effects';

  export function* onIncrement() {
    yield console.log('I am incremented');
    yield delay(3000);
    yield put({ type: 'INCREMENT_FROM_SAGA' });
  }

  export function* incrementSaga() {
    yield takeEvery('INCREMENT', onIncrement);
  }


3. takeLatest() reçoit une action dispatchée et appelle une autre
fonction generator qui va exécuter le code souhaité seulement pour
la dernière action dispatchée. 
Dès qu'une nouvelle action est dispatchée takeLatest() supprime 
l'exécution des précédentes et ne continue l'exécution de la fonction generator que pour la dernière. 

Si la première instruction du generator est synchrone et immédiate elle s'exécutera à chaque action, c'est 
pourquoi malgré takeLatest() 'I am incremented' s'affichera à chaque click. 
Par contre comme il y a un delay de 3s avant l'action INCREMENT_FROM_SAGA,
elle ne sera dispatchée que pour le dernier click si il se produit 
avant les 3s de l'action précédente.

  EX:
  import { takeLatest, delay, put } from 'redux-saga/effects';

  export function* onIncrement() {
    yield console.log('I am incremented');
    yield delay(3000);
    yield put({ type: 'INCREMENT_FROM_SAGA' });
  }

  export function* incrementSaga() {
    yield takeLatest('INCREMENT', onIncrement);
  }


(Redux) Les actions, les action creators
-------------------------------
1. Les  actions sont des  objets servant à représenter une interaction. Elles n'apportent rien de fonctionnel, 
et ne sont là que pour apporter un nom ("type") qui les représente et, optionnellement, un ou plusieurs arguments 
qui seront transmis depuis l'application au store. Les actions sont la seule source de données du store.
Les actions sont envoyées au store grâce à dispatch().

Les actions doivent obligatoirement avoir une propriété type qui définit l'interaction. Le type est couramment définit sous forme d'une constante qui
contient une chaîne de caractère. Cela vous permettra d'éviter les fautes de frappe lorsque vous souhaitez utiliser vos types au moment de l'import. 
De plus, même dans le cas d'une faute de frappe, votre IDE ou Redux pourrait vous afficher une erreur. Cela vous permettra de localiser plus rapidement l'erreur.

  EX:
  const ADD_TODO = 'ADD_TODO'
  { 
    type: ADD_TODO,
    text: 'Build my first Redux app'
  }

2. Les action creators. Dans la pratique, on n'écrit pas d'action  directement, mais ce qu'on appelle des action creators : 
il s'agit de simples fonctions qui peuvent prendre des arguments (aussi appelés payload) et qui retournent une action.

  EX:
  //// user.types.js ////
  const UserActionTypes = {
    SET_CURRENT_USER: 'SET_CURRENT_USER',
    GOOGLE_SIGN_IN_START: 'GOOGLE_SIGN_IN_START',
    EMAIL_SIGN_IN_START: 'EMAIL_SIGN_IN_START',
    SIGN_IN_SUCCESS: 'SIGN_IN_SUCCESS',
    SIGN_IN_FAILURE: 'SIGN_IN_FAILURE',
    CHECK_USER_SESSION: 'CHECK_USER_SESSION',
    SIGN_OUT_START: 'SIGN_OUT_START',
    SIGN_OUT_SUCCESS: 'SIGN_OUT_SUCCESS',
    SIGN_OUT_FAILURE: 'SIGN_OUT_FAILURE',
    SIGN_UP_START: 'SIGN_UP_START',
    SIGN_UP_SUCCESS: 'SIGN_UP_SUCCESS',
    SIGN_UP_FAILURE: 'SIGN_UP_FAILURE'
  };
  export default UserActionTypes;


  //// user.actions.js ////
  import UserActionTypes from './user.types';

  // emailSignInStart un action creator. 
  // Pour le nommer, on reprend souvent le type de l'action mais en camelCase
  // Il prend en paramètre emailAndPassword qui est utilisé dans la
  // propriété payload de l'action
  export const emailSignInStart = emailAndPassword => (
  // Cette objet est l'action retournée par l'action creator
  // On appelle souvent payload la propriété qui contient les données contenues
  // dans l'action.
  {
    type: UserActionTypes.EMAIL_SIGN_IN_START,
    payload: emailAndPassword
  });

  export const signUpSuccess = ({ user, additionalData }) => ({
    type: UserActionTypes.SIGN_UP_SUCCESS,
    payload: { user, additionalData }
  });

  export const signOutSuccess = () => ({
    type: UserActionTypes.SIGN_OUT_SUCCESS
  });

  export const signUpFailure = error => ({
    type: UserActionTypes.SIGN_UP_FAILURE,
    payload: error
  });


3. Les  actions sont, par la suite, utilisées par les reducers.
Le  reducer a pour rôle d'utiliser l'action pour mettre à jour le store.


Gérer les erreurs dans les gestionnaires d’événements
-------------------------------
1. Les périmètres d’erreurs n’interceptent pas les erreurs qui surviennent au sein des gestionnaires d’événements.

2. React n’a pas besoin de périmètres d’erreurs pour gérer les erreurs dans les gestionnaires d’événements. 
Contrairement aux méthodes de rendu ou de cycle de vie, les gestionnaires d’événements ne sont pas appelés pendant le rendu. 
Du coup même si ces gestionnaires lèvent une erreur, React saura tout de même quoi afficher à l’écran.

3. Si vous avez besoin d’intercepter une erreur au sein d’un gestionnaire d’événements, il suffit d’utiliser un classique try / catch JavaScript

  EX:
  class MyComponent extends React.Component {
    constructor(props) {
      super(props);
      this.state = { error: null };
      this.handleClick = this.handleClick.bind(this);
    }

    handleClick() {
      try {
        // Faites ici quelque chose qui va lever une erreur
      } catch (error) {
        this.setState({ error });
      }
    }

    render() {
      if (this.state.error) {
        return <h1>Une erreur a été interceptée.</h1>
      }
      return <div onClick={this.handleClick}>Cliquez ici</div>
    }
  }


Méthodes pour bien binder this dans un gestionnaire dévènement
-------------------------------
1. Avec une arrow function.
La méthode la plus pratique est d'utiliser une arrow function.
En effet, les fonctions fléchées partagent le même this lexical que leur scope parent. 
Du coup, le this que vous pourrez utiliser dans votre corps de fonction fléchée est celui du code parent
  EX:
  class MyComponent extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
            title: 'I am Index page'
        }
    }

    updateTitle() {
        this.setState({title: 'I am updated page' })
    }

    render() {
      return (
            <BaseLayout>
                <h1> {this.state.title} </h2>
                {/*
                On passe à onClick la référence d'un fonction fléchée, 
                C'est ce gestionnaire qui va gérer son exécution au click.
                À chaque click le gestionnaire appelle la fonction fléchée qui
                elle-même exécute la méthode this.updateTitle()
                Le this fait référence a son parent qui est la classe MyComponent
                */}
                <button onClick={() => this.updateTitle()}>Change title</button>
            </BaseLayout>
        )
    }
  }

2. Avec bind()
  EX:
  class MyComponent extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
            title: 'I am Index page'
        }
      // On lie le this à la classe MyComponent
      // this.setState équivaut à MyComponent.setState
      // dans la fonction updateTitle()
      this.updateTitle = this.updateTitle.bind(this);
    }

    updateTitle() {
        this.setState({title: 'I am updated page' })
    }

    render() {
      return (
            <BaseLayout>
                <h1> {this.state.title} </h2>
                {/*
                On passe à onClick la référence de la fonction this.updateTitle, 
                C'est ce gestionnaire qui va gérer son exécution au click.
                */}
                <button onClick={this.updateTitle}>Change title</button>
            </BaseLayout>
        )
    }
  }

3. Avec une arrow function au niveau de la fonction appelée
  EX:
  class MyComponent extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
            title: 'I am Index page'
        }
    }

    // Le this de this.setState dans la fonction fléchée updateTitle 
    // fait référence a son parent qui est la classe MyComponent
    updateTitle = () => {
        this.setState({title: 'I am updated page' })
    }

    render() {
      return (
            <BaseLayout>
                <h1> {this.state.title} </h2>
                {/*
                On passe à onClick la référence de la fonction this.updateTitle, 
                C'est ce gestionnaire qui va gérer son exécution au click.
                */}
                <button onClick={this.updateTitle}>Change title</button>
            </BaseLayout>
        )
    }
  }


Différences entre SSR (Server-Side Rendering) et CSR (Client-Side Rendering)
-------------------------------
Voir : https://altalogy.com/blog/client-side-rendering-vs-server-side-rendering/

1. If you want to build site which is mostly static (blog, portfolio, landing page), use Gatsby, 
it’s not SSR, but it pre-renders (bon pour le SEO) the website into HTML at the build time

2. If you want to build a web app with react, and you care about SEO, easier social media optimization 
and faster render for user you should think about SSR and framework like next.js

3. If you building a SPA (single page application), and you don’t want to configure everything 
on the server side like: i18n, router e.t.c. you should use create-react-app


Rendu d'un array d'éléments HTML
-------------------------------
1. EN JSX on peut rendre un tableau d'éléments HTML
EX:
render() {
    let array = [<div>1</div>, <div>2</div>]
    return (
        <BaseLayout>
            <h1>I am index page</h1
            { array } // Rendra <div>1</div><div>2</div>
        </BaseLayout>
    )
}


Passer des props à un composant
-------------------------------
1. Passage de props standard
  EX:
  render() {
      // strings don't have to be wrapped with {},
      // but it's better to get used to wrapping everything
      return (
          <Movie
              /* On passe un tableau */
              actors={[
                  ...
              ]}
              /* On passe un objet */
              details={{
                  director: "Director name",
                  ...
              }}
              /* On passe un nombre */
              duration={120}
              /* On passe un booléen */
              released={true}
              /* On passe une string */
              title={"Movie title"}
              /* On passe une variable */
              budget={budget}
          />
      )
  }

2. Passage de props booléen
  EX:
  render() {
      // No need for "released={true}"!
      return (
          <Movie
              released
          />
      )
  }

  EX:
  render() {
      // On ne passe rien du tout
      // This will work the same way as if you passed "released={false}"!
      return (
          <Movie />
      )
  }

  render() {
      // You can directly calculate the value of a prop when passing it
      return (
          <Movie
              released={value1===value2}
          />
      )
  }

  EX:
  isFormValid() {
      // Various checks, whether every form field is of correct format
  }
  render() {
      // If the expression is too long, move it above the return statement or even to a separate function.
      return (
          <Form
              disabled={!this.isFormValid()}
              fields={this.state.fields}
          />
      )
  }

3. Passer une fonction
  EX:
  // Utiliser des arrow functions
  handleChange = (event) => {
      // do something here
  }
  render() {
      return (
          <div>
              <input
                  onChange={this.handleChange}
              />
          </div>
      )
  }

  EX:
  // Si on doit recevoir des arguments en plus de l'event
  handleChange = (parameter1, parameter2) => (event) => {
      // do something here
  }
  render() {
      return (
          <div>
              <input
                  onChange={this.handleChange(parameter1, parameter2)}
              />
          </div>
      )
  }

4. Passer des props avec le spread operator
  EX:
  const movie = {
      title: "Inception",
      releaseDate: "16.07.2010",
      genre: [
          "Action", "Adventure", "Sci-Fi",
      ],
  };

  // Sans le spread operator
  render() {
      return (
          <Movie
              title={movie.title}
              releaseDate={movie.releaseDate}
              genre={movie.genre}
          />
      );
  }

  // Avec le spread operator
  render() {
      return (
          <Movie {...movie} />
      );
  }


Props de rendu
-------------------------------
1. Un composant avec une prop de rendu prend une fonction qui renvoie un élément React 
et l’appelle au lieu d’implémenter sa propre logique de rendu.

  EX:
  <DataProvider render={data => (
    <h1>Bonjour {data.target}</h1>
  )}/>

2. Une prop de rendu est une prop de type fonction qu’un composant utilise pour savoir quoi afficher.
Il suffit d’afficher un <Composant> avec une prop render qui lui dit quoi afficher avec les données qu'il possède.

  EX:
  // On affiche ce composant MouseTracker sur la page d'accueil par exemple
  class MouseTracker extends React.Component {
    render() {
      return (
        <div>
          <h1>Déplacez votre souris sur l’écran !</h1>
          {/*
          Ici le composant Mouse utilise la props de rendu pour passer au composant Cat qu'il va afficher
          la valeur de son attribut mousePosition qui est un objet de structure {x: positionCurseurEnX, y: positionCurseurEnY}
          Le composant Cat récupère l'objet mousePosition à partir de l'argument de la fonction passée à la props render
          et le passe ensuite dans une props de composant mousePosition pour pouvoir y accéder dans son code.
          */}
          <Mouse render={mousePosition => (
            <Cat mousePosition={mousePosition} />
          )}/>
        </div>
      );
    }
  }

  class Mouse extends React.Component {
    constructor(props) {
      super(props);
      this.handleMouseMove = this.handleMouseMove.bind(this);
      this.state = { x: 0, y: 0 };
    }

    handleMouseMove(event) {
      this.setState({
        x: event.clientX,
        y: event.clientY
      });
    }

    render() {
      return (
        <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>

          {/*
            Au lieu de fournir une représentation statique de ce qu’affiche <Mouse>,
            utilisez la prop `render` pour déterminer dynamiquement quoi afficher.
          */}
          {/*
            Dès que la position du curseur de la souris bouge, on met à jour le state
            avec les positions x et y
            this.props.render(this.state) permet de passer un objet avec plein d'attributs qui
            pourront être utilisés par le composant ou le JSX qui seront appelés par la props
            render de Mouse
          */}
          {this.props.render(this.state)}
        </div>
      );
    }
  }

  class Cat extends React.Component {
    render() {

      // On récupère la props mousePosition fourni par la props de rendu du composant Mouse
      const mousePosition = this.props.mousePosition;
      return (
        <img src="/cat.jpg" style={{ position: 'absolute', left: mousePosition.x, top: mousePosition.y }} />
      );
    }
  }  

3. N’importe quelle props utilisée par un composant pour savoir quoi renvoyer est techniquement une « prop de rendu ».
C'est le cas de la props children.

  EX:
  <Mouse children={mouse => (
    <p>La position de la souris est {mouse.x}, {mouse.y}</p>
  )}/>

  // La propriété children n’a en fait pas besoin d’être nommée dans la liste des « attributs » de votre élément JSX. 
  // Au lieu de ça, vous pouvez l’utiliser directement dans l’élément !

  <Mouse>
    {mouse => (
      <p>La position de la souris est {mouse.x}, {mouse.y}</p>
    )}
  </Mouse>


React.Children.only(children) Méthode 
-------------------------------
1. La méthode Children.only vérifie que children n’a qu’un seul enfant (un élément React) et le renvoie. 
Si ce n’est pas le cas elle lèvera une erreur.

  EX:
  import React, { Children } from 'react';

  const child = Children.only(children);


cloneElement() Méthode
-------------------------------
1. The React.cloneElement() function returns a copy of a specified element. 
Additional props and children can be passed on in the function. 
You would use this function when a parent component wants to add or modify the prop(s) of its children.

  EX:
  import React, { Children } from 'react';
  import { Link } from '../routes';

  const ActiveLink = ({children, ...props}) => {

    const child = Children.only(children);
    let className = child.props.className || "";

    return <Link {...props}>{React.cloneElement(child, {className})}</Link>;
  }
  export default ActiveLink;

  EX:
  import React from 'react';
  export default class App extends React.Component {
    // rendering the parent and child component
    render() {
      return (
        <ParentComp>
          <MyButton/>
          <br></br>
          <MyButton/>
        </ParentComp>
      )
    }
  }
  // The parent component
  class ParentComp extends React.Component {
    render() {
      // The new prop to the added.
      let newProp = 'red';
        // Looping over the parent's entire children,
        // cloning each child, adding a new prop.
      return (
        <div>
          {React.Children.map(this.props.children,
            child => {
              return React.cloneElement(child,
              {newProp}, null);
          })}
        </div>
      )
    }
  }
  // The child component
  class MyButton extends React.Component {
    render() {
      return <button style =
      {{ color: this.props.newProp }}>
      Hello World!</button>
    }
  }


Différence entre un state et une variable de classe
-------------------------------
1. The simple answer to your question is that by using state you call the the setState() 
which automatically calls render() automatically. Which cannot be obtained by class variables
You use the state variables :
- When you want to change the component when that variable is changed.
- When you don't want to automatically call render() you use the class variables

EX:
// Avec variable de classe
export default class Test extends Component {
  constructor() {
    this.active = false;
  }

  render() {
    const active = this.props.name === 'Dan';
    return (
      <div>
        {this.active ? 'Active' : 'No Active'}
      </div>
    );
  }
}

// Avec state
export default class Test extends Component {
  constructor() {
    this.state = { active: false };
  }

  render() {
    if(this.props.name === 'Dan') {
      this.setState({active: true});
    }
    return (
      <div>
        {this.active? 'Active' : 'No Active'}
      </div>
    );
  }
}


Affichage conditionnel
-------------------------------
Voir https://blog.logrocket.com/conditional-rendering-in-react-c6b0e5af381e/
Voir https://fr.reactjs.org/docs/conditional-rendering.html

  EX:
  // Avec des variables
  render() {
    const isLoggedIn = this.state.isLoggedIn;
    let button;

    if (isLoggedIn) {
      button = <LogoutButton onClick={this.handleLogoutClick} />;
    } else {
      button = <LoginButton onClick={this.handleLoginClick} />;
    }

    return (
      <div>
        <Greeting isLoggedIn={isLoggedIn} />
        {button}
      </div>
    );
  }

  EX:
  // Avec l'opérateur &&
  function Mailbox(props) {
    const unreadMessages = props.unreadMessages;
    return (
      <div>
        <h1>Bonjour !</h1>

        {unreadMessages.length > 0 &&
          <h2>
            Vous avez {unreadMessages.length} message(s) non-lu(s).
          </h2>
        }

      </div>
    );
  }

  const messages = ['React', 'Re: React', 'Re:Re: React'];
  ReactDOM.render(
    <Mailbox unreadMessages={messages} />,
    document.getElementById('root')
  );

EX:
// Avec l'opérateur ternaire
render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      L’utilisateur <b>{isLoggedIn ? 'est actuellement' : 'n’est pas'}</b> connecté.
    </div>
  );
}

// ou

render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      {isLoggedIn ? (
        <LogoutButton onClick={this.handleLogoutClick} />
      ) : (
        <LoginButton onClick={this.handleLoginClick} />
      )}
    </div>
  );
}

EX:
// Empêcher l’affichage d’un composant.
// Pour ce faire, il suffit de renvoyer null au lieu de son affichage habituel.
function WarningBanner(props) {
  if (!props.warn) {
    return null;
  }

  return (
    <div className="warning">
      Attention !
    </div>
  );
}

class Page extends React.Component {
  constructor(props) {
    super(props);
    this.state = {showWarning: true};
    this.handleToggleClick = this.handleToggleClick.bind(this);
  }

  handleToggleClick() {
    this.setState(state => ({
      showWarning: !state.showWarning
    }));
  }

  render() {
    return (
      <div>
        <WarningBanner warn={this.state.showWarning} />
        <button onClick={this.handleToggleClick}>
          {this.state.showWarning ? 'Masquer' : 'Afficher'}
        </button>
      </div>
    );
  }
}

ReactDOM.render(
  <Page />,
  document.getElementById('root')
);

